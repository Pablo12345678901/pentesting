.globl _start

.section .data

# Set here the target exit return value and do not let the script exit while it is not reached.
target_exit_return_value:
	.quad 100
	
.section .text

# This programs aims to instruct on how to follow multiple jumps along the code.
_start:
	# 0. Entry point
	movq $25, %rax
	# '%rax' = 25
	# Compare the current with expected value
	cmp target_exit_return_value, %rax
	# Jump to end of program only if they are equal
	je last_place
	# Else jump to another place
	jmp first_place
	
first_place:
	# 1.
	movq $4, %rbx
	mulq %rbx
	# %rax = 4 * 25 = 100
	# Compare the current with expected value
	cmp target_exit_return_value, %rax
	# Jump to end of program only if they are not equal
	jne last_place
	# Else jump to another place
	jmp second_place

forth_place:
	# 4. Increment '%rax'
	incq %rax
	# '%rax' = 100
	# Comparison
	cmp target_exit_return_value, %rax
	# Jump to end of program only if '%rax' is above or equal the target value.
	jae last_place
	# Else jump to another place.
	jmp none_place

none_place:
	# This place will not be reached and is just dummy code.
	divq %rbx
	# '%rax' will be divided by '%rbx'
	jmp none_place # infinite loop

second_place:
	# 2. Decrement '%rax'
	decq %rax
	# Comparison
	cmp target_exit_return_value, %rax
	# Jump to end of program only if '%rax' is above the target value.
	ja last_place
	# Else jump to another place.
	jmp third_place
	
last_place:
	# 6. Exit point
	# Conserve '%rax' into '%rdi' to use it from exit system call.
	movq %rax, %rdi
	# Exit system call (60)
	movq $60, %rax
	syscall

third_place:
	# 3. Dummy place - no action to be taken.
	jmp forth_place	
