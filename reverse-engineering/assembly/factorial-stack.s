	.globl _start

	.section .data

number_to_compute_factorial:
	.quad 5

	.section .text
_start:
	# Set a sentinel value '0' for the stack beginning.
	pushq $0
	# Load the number for which the factorial computation has to be done.
	movq number_to_compute_factorial, %rax

push_values_into_stack:
	# Push current number on the stack
	pushq %rax
	# Decrease it.
	decq %rax
	# Check if the decrease number is '0' and if not, continue to loop.
	jnz push_values_into_stack
	# Else set register to default value of '1' as factorial of '1' is '1'
	movq $1, %rax
	
recover_values_from_stack_and_compute_factorial:
	# Get last number on the stack.
	popq %rcx
	# Check whether the end (start) of the stack was reached (with its sentinel value of '0') and if so end program.
	cmpq $0, %rcx
	je end
	# Else multiply current result (%rax) by number obtained from the stack
	mulq %rcx
	jmp recover_values_from_stack_and_compute_factorial
	
end:
	# Exit syscall
	# Set the exit return code to the result of the factorial computation.
	movq %rax, %rdi
	movq $60, %rax
	syscall
