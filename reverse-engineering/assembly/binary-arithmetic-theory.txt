These are explanation around low level arithmetic operation.
The addition, substraction, multiplication and division are explained at a binary level.

============================================================
# Introduction :

# Binary Addition: Detecting Carry

# Let's consider the addition of two single-bit numbers:
  A  # First bit
+ B  # Second bit
---
  S  # Sum bit
  C  # Carry bit

 ------------------------------------------------------------ 

# Binary multiplication with bit-wise operations 'AND' and 'XOR'

# Let's consider the multiplication of two 4-bit numbers:
  A  # Multiplicand (4 bits)
× B  # Multiplier (4 bits)
---
  P  # Product (8 bits)

# At the binary level, the sum (S) and carry (C) are determined by logical bitwise operations:

S = A XOR B  # Sum is the XOR of A and B
C = A AND B  # Carry is the AND of A and B

# Truth table for single-bit addition:
# A | B | S | C
# 0 | 0 | 0 | 0
# 0 | 1 | 1 | 0
# 1 | 0 | 1 | 0
# 1 | 1 | 0 | 1

# Example in binary logic gates:

A ----┬----XOR----┐
      │          │
B ----┴----AND----┴----
      │               │
      │               │
      └----> C        └----> S

 ------------------------------------------------------------ 

# At the bit level, multiplication can be performed as follows:

# Initialize product P to 0
P = 0

# Iterate over bits of multiplier B from LSB to MSB
#
# Example in Python :
#
for i = 0 to 3: # 0-3 = 4 indexes
    # Check if current bit of B is 1
    if B[i] == 1:
        # If bit is 1, add shifted multiplicand A to product
        P = P + (A << i)

# The final product P contains the result

# To see more, refer to the script about multiplication-at-bit-level.s within the same directory.

============================================================

# 1. Addition
  1011  # 11 in decimal
+ 1101  # 13 in decimal
------
 11000  # 24 in decimal

 ------------------------------------------------------------ 

# Step-by-step process:
# 1. 	       1 + 1 = 0, carry 1		(rightmost column)
# 2. 	       1 + 0 + 1 (carry) = 0, carry 1 	(get next column left side, the last previous column of the right)
# 3. 	       0 + 1 + 1 (carry) = 0, carry 1
# 4. 	       1 + 1 + 1 (carry) = 1, carry 1
# 5. Write down final carry as the leftmost digit
# 6. Fill the rest with 0 or 1 depending on the nature of the number manipulated (un)signed to get the wished size in byte (multiple of 8 bits).
#
# The process moves from right to left, similar to decimal addition

============================================================

# 2. Subtraction
  1011  # 11 in decimal
- 0110  # 6 in decimal
------
  0101  # 5 in decimal

 ------------------------------------------------------------ 

# Step-by-step process:
# 1. 1 - 0 = 1 (rightmost column)
# 2. 1 - 1 = 0
# 3. 0 - 1 = 1, borrow 1 from the next column
#    (0 becomes 2 in binary after borrowing, 2 - 1 = 1)
# 4. 0 - 0 = 0 (leftmost column, after lending 1 to previous column)
# The process moves from right to left, similar to decimal subtraction

============================================================

# 3. Multiplication
    101  # 5 in decimal
  × 011  # 3 in decimal
  -----
    101  # 5 in decimal (101 shifted left by 0)
   101   # 10 in decimal (101 shifted left by 1)
  -----
   1111  # 15 in decimal

 ------------------------------------------------------------ 

# Step-by-step process:
# 1. Multiply 101 by rightmost 1: 101 × 1 = 101
# 2. Multiply 101 by next 1, shift left one position: 101 × 10 = 1010
# 3. Multiply 101 by leftmost 0: 101 × 000 = 000 (omitted as it's all zeros)
# 4. Sum all partial products: 101 + 1010 = 1111
# This method is analogous to long multiplication in decimal

============================================================

# 3B. Booth's multiplication
	Initialize the multiplicand in register BR and the multiplier in register QR.
	If the two rightmost bits of QR (Qn and Qn-1) are the same (00 or 11), perform an arithmetic right shift by 1 bit on QR.
	If Qn Qn-1 = 01, add the multiplicand in BR to the accumulator register AC (AC = AC + BR), then perform an arithmetic right shift by 1 bit on QR.
	If Qn Qn-1 = 10, subtract the multiplicand in BR from the accumulator register AC (AC = AC - BR), then perform an arithmetic right shift by 1 bit on QR.
	Repeat steps 2-4 until the desired number of iterations is reached.

# Computation :
0110 (= 6) * 0010 (= 2) = 1100 (= 12)
# AC = current result, accumulator
# BR = 0110 = multiplicand
# QR = 0010 = multiplier
#
qn     q[n-1]	Result	Detail		Rule			Computation				AC	QR	sc(step count)
______________________________________________________________________________________________________________
0	-	-	-		Initialization		q0 : 0, AC : 0000, QR : 0010 		0000	0010	0
0	0	00 	001_0 & 0	rightshift		QR : 0010->0001				0000	0001	1        	  		  	 	     
1       0	10	000_1 & 0   	substract / rightshift	AC : 0000 - 0110 / QR : 0001->0000 	1010   	0000	2        
0       1	01	000_0 & 1	add / rightshift	AC : 1010 + 0110 / QR : 0000->0000	1100	0000    3    
0       0	00	100_0 & 0	rightshift		QR : 0000->0000	 	       		1100  	0000    4    

     
============================================================

# 4. Division
  11 | 1100  # 12 in decimal ÷ 3 in decimal
     - 11    # 3 in decimal
     ----
       00    # 0 in decimal
        00   # 0 in decimal
       ---
        00   # 0 in decimal

Result: 100 (Quotient)  # 4 in decimal

 ------------------------------------------------------------ 

# Step-by-step process:
# 1. Compare 11 (divisor) with 11 (first two digits of dividend)
# 2. 11 goes into 11 once, write 1 in quotient
# 3. Subtract 11 from 11, bring down next digit (0)
# 4. 11 doesn't go into 00, write 0 in quotient
# 5. Bring down last 0
# 6. 11 doesn't go into 00, write 0 in quotient
# 7. No more digits to bring down, division complete
# This process is similar to long division in decimal

============================================================
