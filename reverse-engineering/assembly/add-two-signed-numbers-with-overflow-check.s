	# This program checks whether an overflow occurred while adding two signed values.
	# First it adds two values.
	# Then it checks for the 'overflow' flag (%eflags).
	# And jump to the relevant section depending on this latter.
	# If so, returns an exit code of 1.
	# Else (and by default), return an exit code of 0.
	# Depending on the addition line uncommented (adapt by uncommenting one line and commenting the three others), the return code of the 'script' will change.
	# In the 4 lines, the overflow wrap is processed (checked) in two directions :
	# 	- first one :  add 1 + 126   = +127	Positive -> Positive 	No overflow
	#	- second one : add 2 + 126   = -128 	Positive -> Negative	Overflow
	#	- third one :  add -1 + -127 = -128	Negative -> Negative	No overflow
	#	- forth one :  add -2 + -127 = +127     Negative -> Positive    Overflow 
	
	.globl _start
	.section .text
_start:

	# Set default exit code to '0'.
	movq $0, %rdi

	# Set all register to '0' to avoid garbage values into 64 bits registers.
	movq $0, %rax
	movq $0, %rbx
	movq $0, %rcx
	movq $0, %rdx
	movq $0, %r8
	movq $0, %r9
	
	# Set signed numbers values to a byte (8 bits) level to avoid writting 64 bits values of '1|0'.

	# POSITIVE VALUES
	movb $0b01111110, %al # %rax = A = 126
	# A = sign bit  + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 0 * 2^0
	# A = (+)         64      + 32      + 16      + 8       + 4       + 2       + 0
	# A = 126
	movb $0b00000001, %bl # %rbx = B = 1 
	# B = sign bit  + 0 * 2^6 + 0 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0
	# B = (+)         0       + 0       + 0       + 0       + 0       + 0       + 1
	# B = 1
	movb $0b00000010, %cl # %rcx = C = 2
	# C = sign bit  + 0 * 2^6 + 0 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0
	# C = (+)         0       + 0       + 0       + 0       + 0       + 2       + 0
	# C = 2

	# NEGATIVE VALUES
	movb $0b10000001, %dl # %rdx = D = -127
	# In get a negative number from a binary value, if the bit is set to '0', then the 'power 2' number has to be multiplied by '1', and then the total of the addition of all 'power 2' has to be increased by 1, and the final total multiplied by (-1).
	# D = sign bit  { ( + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 0 * 2^0 ) +1 } 
	# D = (-)       { (   64      + 32      + 16      + 8       + 4       + 2       + 0       ) +1 } 
	# D = -127
	movb $0b11111111, %r8b # %r8 = E = -1
	# E = sign bit  { ( + 0 * 2^6 + 0 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 0 * 2^0 ) +1 }
	# E = (-)       { (   0       + 0       + 0       + 0       + 0       + 0       + 0       ) +1 } 
	# E = -1
	movb $0b11111110, %r9b # %r9 = F = -2
	# F = sign bit  { ( + 0 * 2^6 + 0 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0 ) +1 } 
	# F = (-)       { (   0       + 0       + 0       + 0       + 0       + 0       + 1       ) +1 }
	# F = -2
	
	# Process to addition at a byte level to check whether an overflow occured while processing arithmetic on the 8 bits values.
	# Uncomment only one line - comment the three others to check the return value of this 'script'.
	#addb %bl, %al 		# A + B = 126 + 1 = +127 -> No overflow 
	#addb %cl, %al 		# A + C = 126 + 2 = -128 -> Overflow
	#addb %r8b, %dl 		# D + E = -127 + (-1) = -128 -> No overflow
	addb %r9b, %dl 		# D + F = -127 + (-2) = +127 -> Overflow

	# Check overflow flag and if set, jump to the overflow section.
	jo overflow_occurred
	# Else jump to the end of the program.
	jno end_of_program

overflow_occurred:
	# If an overflow occurred, set exit code to '1'.
	movq $1, %rdi
	
end_of_program:
	# Exit syscall
	movq $60, %rax
	syscall
