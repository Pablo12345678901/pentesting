# This script count the number of non letter = neither lowercase nor uppercase letter in a string of characters.
# Reminder :
#	- uppercase have values between 65 and 90 inclusive x2.
#	- lowercase have values between 97 and 122 inclusive x2.
# So non letter have values between 0 and 64, 91 and 96, 123 and 255.
# There are two ways of counting them :
#	- by increasing the number of non-letter chars each time one char match one of the 3 ranges. -> This is the one that will be implemented here because of I find its complexity fun to be coded (more fun to dev !).
#	- by counting the total number of chars and deducing the number of uppercase and lowercase letter. 

	.globl _start

	.section .data

my_string:
	.ascii "This is a string of characters.\0" # 1 uppercase letter, 24 lowercase letter, 6 non-letter chars (5 spaces, 1 dot) =  total of 31 characters.

	.section .text
_start:
	# Get address of first character..
	leaq my_string, %rbx

	# Set counter of chars
	movq $0, %rcx
	
	# Set counter of non-letter chars.
	movq $0, %rdi
	
loop_chars_counter:
	# Load the char value into another register to check its value when debugging.
	movb (%rbx), %al
	
	# Check if current char is the null char '\0' and go to the part of the counting of non-letter chars if so.
	cmpb $0, %al

	# Adapt this part depending on the wished result - useful to debug.
	je re_set_address_of_first_char # Comment this line and uncomment the next one in order to get the number of non-letter char within the string ('\0' null char is not counted as a char).
	#je end_of_program_char_counter # Uncomment this line and comment the previous one in order to get total number of char within the string ('\0' null char is not counted as a char).
	
	# Else increase counter of lowercase letter.
	incq %rcx

get_next_char_address_chars_counter:
	# Increase = + 1 = get next byte address.
	incq %rbx
	jmp loop_chars_counter

re_set_address_of_first_char:
	# Substract the number of chars (byte) to the current address within %rbx (pointing on the last char = '\0') in order to re-set the address to first char.
	subq %rcx, %rbx
	
loop_counter_non_letter:
	# Uppercase letter : 65-90
	# Lowercase letter : 97-122

	# Load the char value into another register to check its value when debugging.
	movb (%rbx), %r8b

	# Check if current char is the null char '\0' and exit program if so.
	cmpb $0, %r8b
	je end_of_program

	# Check if uppercase and get next element if so
	cmpb $'A', %r8b
	jb increase_non_letters_counter

	cmpb $'z', %r8b
	ja increase_non_letters_counter

	# From here, the char is betweeen the range A-z (65-122) so still need to check if it is within the range 91-96 inclusive x2.
	# 'Eliminate' the char if it is below or equal to 'Z'
	cmpb $'Z', %r8b
	jbe set_next_char_address_non_letters_counter
	# Same if above or equal to 'a'
	cmpb $'a', %r8b	
	jae set_next_char_address_non_letters_counter

	# If it was not 'eliminated', so it is between 91-96 -> increase counter.
	jmp increase_non_letters_counter

increase_non_letters_counter:	
	# Increase counter
	incq %rdi

	# Set next char address
	jmp set_next_char_address_non_letters_counter
	
set_next_char_address_non_letters_counter:
	# Increase = + 1 = get next byte address.
	incq %rbx
	jmp loop_counter_non_letter

end_of_program:
	# Exit syscall
	movq $60, %rax
	syscall

end_of_program_char_counter:	
	# Exit syscall
	movq %rcx, %rdi
	movq $60, %rax
	syscall
	
