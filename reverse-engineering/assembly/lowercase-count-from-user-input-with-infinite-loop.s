	# This script count the number of lowercase letter in a string of characters (without space/tab/return) of maximum 49 chars (+1 for the null char) provided by the user.
	# It will ask the user again and again in an infinite loop for other strings.
	# To stop this program, use 'Ctrl^C'
	.globl main

	.section .data

ask_user_input:
	.ascii "Please provide a string of maximum length 49 chars - without space/tab.\n-> \0"

scan_format:
	# The maximum size will be 49 chars, that the final string will measure maximum 50 chars - 'null char' included
	.ascii "%49s\0"

result_message:
	.ascii "The total number of lowercase letter within the string provided is : %d \n\0"
	
	.section .text

	# The string is 50 bytes long - but the space was rounded to 8 bytes up to 56 in order to facilitate further alignment to 16 bytes.
	.equ LOCAL_OFFSET_STRING, -56
	.equ LOCAL_OFFSET_COUNTER, -64
	
main:
	# Making space for two variables, one of them containing 50 chars (rounded up to 56 bytes)
	enter $64, $0

	# Ask user input
	movq stdout, %rdi
	leaq ask_user_input, %rsi
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf
	
	# Scan user input
	movq stdin, %rdi
	leaq scan_format, %rsi
	leaq LOCAL_OFFSET_STRING(%rbp), %rdx 
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fscanf
	
	# Get address of first char and keep it within a register
	leaq LOCAL_OFFSET_STRING(%rbp), %rbx
	
	# Set counter of lowercase letter.
	movq $0, LOCAL_OFFSET_COUNTER(%rbp)
	
main_loop:
	# Load the char value into another register to check its value when debugging.
	movb (%rbx), %r8b
	
	# Check if current char is the null char '\0' and exit program if so.
	cmpb $0, %r8b
	je end
	
	cmpb $'a', %r8b
	jb get_next_char_address
	
	cmpb $'z', %r8b
	ja get_next_char_address
	
	# Else increase counter of lowercase letter.
	incq LOCAL_OFFSET_COUNTER(%rbp)

get_next_char_address:
	# Increase = + 1 = get next byte address.
	incq %rbx
	jmp main_loop

end:
	# Print result message
	movq stdout, %rdi
	leaq result_message, %rsi
	movq LOCAL_OFFSET_COUNTER(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Set a clean exit code for 'main'.
	xor %rax, %rax

	# Re-set stack to original state (before 'enter')
	leave
	# This instruction (jump) will perform an infinite loop by asking again and again the user an input - and never return
	jmp main 

	# The below instruction will never be reached.
	ret
