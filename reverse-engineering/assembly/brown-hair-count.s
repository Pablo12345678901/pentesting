# This script will count the number of persons having brown hair in the list of data records defined within 'person-data.s' ('person-data.o', when linked).
# Reminder : hair color equivalence : 1 = red, 2 = brown, 3 = blonde, 4 = black, 5 = grey, 6 = white, 7 = other
# This file has to be assembled first, and then, the object produced has to be linked with 'person-data.o'.

	
	.globl _start
	.section .text
_start:
	# Load address of first record
	leaq people, %rbx

	# Get record count to loop on it.
	movq number_of_people, %rcx

	# Set the counter of brown hair to '0'.
	movq $0, %rdi

	# Exit if there is no record
	cmp $0, %rcx
	je finish

main_loop:
	# Reminder : %rbx is the pointer to the struct.
	movq HAIR_OFFSET(%rbx), %rax

	# Hair color equivalence : 1 = red, 2 = brown, 3 = blonde, 4 = black, 5 = grey, 6 = white, 7 = other
	# If the hair value is not 2 (2 is equivalent to brown hair), get to next value - if any.
	cmpq $2, HAIR_OFFSET(%rbx) # brown

	# Other test values to comment the above line and uncomment ONE of the below line to get other hair counter.
	# Else if not commented, only the last 'cmp' will apply to the next conditions 'jne' (jump if not equal).
	#cmpq $1, HAIR_OFFSET(%rbx) # red
	#cmpq $3, HAIR_OFFSET(%rbx) # blonde
	#cmpq $4, HAIR_OFFSET(%rbx) # black
	#cmpq $5, HAIR_OFFSET(%rbx) # grey
	#cmpq $6, HAIR_OFFSET(%rbx) # white
	#cmpq $7, HAIR_OFFSET(%rbx) # other


	jne end_loop
	
	# Else increase the counter.
	incq %rdi

end_loop:
	# Get the address of next person by adding the size of one person to the address of the struct.
	addq $PERSON_RECORD_SIZE, %rbx

	loopq main_loop
	
finish:
	# Exit syscall
	movq $60, %rax
	syscall
