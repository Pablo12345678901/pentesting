	# The program will return
	#	- '0' if the bit set within the 'bitmask' was within the specified value (possibility of changing it by (un)commenting lines).
	#	- '1' else.
	# This is done with the 'testb' instruction and specific jump based on the result of the last operation 'jz' (bit not set) or 'jnz' (bit set).
	
	.globl _start
	.section .text
_start:
	# Set register to '0'
	# Just for the habit of avoiding garbage values within the 64 bits register.
	movq $0, %rax
	
	# Set least significant byte of '%rax' register to a value.
	# (Un)comment lines to modify the result of the program.
	#movb $0b01100010, %al
	movb $0b11110101, %al 

	# Check if last bit was set through the below binary bitmask.
	testb $0b00000001, %al
	jz bit_is_not_set
	jnz bit_is_set

	# The two instructions below will NEVER be executed - therefore, the program will NEVER return an exit code of 33.
	# They were written here just for FUN -> to demonstrate it.
	movq $33, %rdi
	jmp end_of_program

bit_is_set:
	movq $0, %rdi
	jmp end_of_program
	
bit_is_not_set:
	movq $1, %rdi
	jmp end_of_program
	
end_of_program:
	# Exit syscall
	movq $60, %rax
	syscall
