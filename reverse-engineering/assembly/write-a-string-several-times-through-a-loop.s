	.globl _start

	.section .data

my_string:
	.ascii "Hi\n"
my_string_end:

	# Set the length of the data to be written as the difference between data start and data end.
	.equ STRING_LENGTH, my_string_end - my_string

	.section .text
_start:
	# Set loop to X times.
	movq $10, %rcx

main_loop:	
	# Save the counter into %r8 as %rcx will be used by the syscall as where the next instructions will be when kernel returns.
	movq %rcx, %r8

write_string:
	# Set syscall to 'write' (=1)
	movq $1, %rax
	# Set 'file descriptor' to STDOUT (=1)
	movq $1, %rdi
	# Load address of string
	leaq my_string, %rsi
	# Set the length of the string to be written
	leaq STRING_LENGTH, %rdx
	syscall

check_if_continue:
	# Reload the value of %rcx
	movq %r8, %rcx
	# Loop as long as counter is >0.
	loopq main_loop
	
end:
	# Syscall exit
	xor %rdi, %rdi
	movq $60, %rax
	syscall
