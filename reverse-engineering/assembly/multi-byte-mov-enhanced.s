	# This is a shorter version of the 'multi-byte-mov.s' script.
	# The differences are that :
	#	- less code has to be written because of duplication between byte1, 3, 5, 7 and also 2, 4, 6.
	#	- Whether to obtain next address or rotate the bits to the right by 2 bytes (16 bits) depends on a counter implemented.
	#	- This counter counts the number of byte(s) processed and is set back to '0' if 8 bytes were processed.

	# This script will check byte by byte a text to see if the current char is a lowercase letter -  if so increase the counter of them.
	# It will do so by checking the two last ones of the register '%rax' that are : '%ah' (7th byte) and '%al' (8th byte).
	# During this check if will check whether the current char is :
	#	- the null char '\0' with a value of '0' and exit if so.
	#	- Else check if below the value of $'a' and if it is, check next byte.
	#		- Else check if above of the value of $'z' and if it is, check next byte.
	#			- Else increase the counter of lowercase letter because the current value is between $'a' and $'z' (inclusive x2) so it is a lowercase letter.
	# At the end, it returns the total number of lowercase letter.
	
	.globl _start

	.section .data
my_text:
	.ascii "This is a string of characters.\0"
	# There are :
	#  1 uppercase letter.
	# 24 lowercase letters.
	#  6 other chars (5 spaces and 1 dot).
	# __________________________________
	# 31 total chars.

	.section .text
_start:
	# Load the address of first char (and quadword).
	movq $my_text, %rbx

	# Set lowercase letter counter
	movq $0, %rdi

	# Set the counter of bytes processed to '0'.
	# This counter will help to know whether it is needed to check the two next bytes (counter<8) or if it is needed to get the address of next quadword (counter=8).
	movq $0, %rcx
	
main_loop:
	# Get the current quadword
	movq (%rbx), %rax
	
check_last_byte:
	# If the 8th byte (the last = least significant one) is null -> exit
	# The last byte is checked before the last previous one because memory is set in a little endian way with the least significant bit first (kind of 'natural reverse' order').
	# So the string     			"This is a string of characters.\0"
	# will be really saved in memory as : 	"\0.sretcarahc fo gnirts a si sihT"
	cmpb $0, %al
	je end_of_program
	
	# If the current char value is below the one of 'a', it is not a lowercase letter to check next byte.
	cmpb $'a', %al
	jb check_last_previous_byte

	# If the current char value is above the one of 'z', it is not a lowercase letter to check next byte.
	cmpb $'z', %al
	ja check_last_previous_byte
	
	# Else Increase the counter of lowercase letter.
	incq %rdi
	
check_last_previous_byte:
	cmpb $0, %ah
	je end_of_program
	cmpb $'a', %ah
	jb right_rotation
	cmpb $'z', %ah
	ja right_rotation
	incq %rdi

right_rotation:	
	# Rotate of 2 bytes to the right, 16 bits.
	rorq $16, %rax

	# Increase counter of 2 (bytes).
	addq $2, %rcx

	# If the current counter is below 8, check next two byte (already rotated).
	cmpq $8, %rcx
	jb check_last_byte
	
	# Else, re-set the counter to 0 byte processed and get next quadword address by adding 8 bytes to the current address.
	movq $0, %rcx
	addq $8, %rbx
	# Loop again
	jmp main_loop
	
end_of_program:
	# Exit syscall
	movq $60, %rax
	syscall
	
