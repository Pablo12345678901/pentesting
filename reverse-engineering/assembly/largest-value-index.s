	.globl _start

	.section .data

number_of_numbers:
	.quad 8
	
list_of_numbers:
	.quad 5, 20, 33, 80, 52, 10, 100
	
	.section .text
_start:
	# Registers used :
	# %rax : current index content value - and at the end, replaced by the syscall number.
	# %rbx : current index examined
	# %rcx : loop counter
	# %rdi : current result and exit return code
	
	movq number_of_numbers, %rcx

	# Set first index to '0'.
	movq $0, %rbx

	# Set default maximum
	movq $0, %rdi

	cmp $0, %rcx
	je end_of_program

main_loop:
	# Using general syntax to access address and its content : address = VALUE + BASEREG + IDREG * MULTIPLIER
	movq list_of_numbers(, %rbx, 8), %rax
	# 8 for 8 byte to access next quadword (8 bytes = 64 bits)

	# Compare current value with the current maximum
	cmp %rdi, %rax
	# If it is below or equal - no need to care more about it.
	jbe loop_control
	# Else, update current maximum value
	movq %rax, %rdi
	
loop_control:
	# Increment current index
	incq %rbx

	# Check if still index to check (%rcx > 0) and if so - compare indexed value with current maximum.
	loopq main_loop

end_of_program:
	movq $60, %rax
	syscall
