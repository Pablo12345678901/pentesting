	# This program will print two different strings to STDOUT - alternating them each time.
	# It will use a loop counter to set the number of printed message and will use check if the current counter help within '%rcx' is even or odd to alternate the messages printed.
	.globl _start

	.section .data

first_string:
	.ascii "abcde\n"
first_string_end:

second_string:
	.ascii "edcba\n"
second_string_end:

	# Set the length of the data to be written as the difference between data start and data end.
	.equ FIRST_STRING_LENGTH, first_string_end - first_string
	.equ SECOND_STRING_LENGTH, second_string_end - second_string

	.section .text
_start:
	# Set loop to X times.
	movq $10, %rcx

main_loop:	
	# Save the counter into %r8 as %rcx will be used by the syscall as where the next instructions will be when kernel returns.
	movq %rcx, %r8
	# Check if the current counter is odd or even.
	# Load current counter into accumulator register
	movq %rcx, %rax
	# Set a clean state of the reminder of the division ('0')
	movq $0, %rdx
	# Create a register holding '2' - needed during the division.
	movq $2, %rbx
	# Divide '%rax' by '%rbx' (2) to check with the rest ('%rdx') if it is even or odd - does not work if trying to divide by direct number as '$2'
	divq %rbx
	# Compare the reminder with '0'
	cmp $0, %rdx
	# If reminder is '0', then the counter is even -> write the first string.
	je write_first_string
	# Else the counter is odd -> write the second string.
	jne write_second_string

write_first_string:
	# Set syscall to 'write' (=1)
	movq $1, %rax
	# Set 'file descriptor' to STDOUT (=1)
	movq $1, %rdi
	# Load address of string
	leaq first_string, %rsi
	# Set the length of the string to be written
	leaq FIRST_STRING_LENGTH, %rdx
	syscall
	jmp check_if_continue
	
write_second_string:
	# Set syscall to 'write' (=1)
	movq $1, %rax
	# Set 'file descriptor' to STDOUT (=1)
	movq $1, %rdi
	# Load address of string
	leaq second_string, %rsi
	# Set the length of the string to be written
	leaq SECOND_STRING_LENGTH, %rdx
	syscall
	jmp check_if_continue

check_if_continue:
	# Reload the value of %rcx
	movq %r8, %rcx
	# Loop as long as counter is >0.
	loopq main_loop
	
end:
	# Syscall exit
	xor %rdi, %rdi
	movq $60, %rax
	syscall
