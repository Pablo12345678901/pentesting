	.globl _start
	
	.section .data
	
number_of_numbers:
	.quad 7
	
my_numbers:
	.quad 5, 20, 33, 80, 52, 10, 1
	
	.section .text
_start:
	# Set default value for the maximum
	movq $0, %rdi

	# Get the array length
	movq number_of_numbers, %rcx

	# If there is no number, exit
	cmp $0, %rcx
	je end_of_program

	# Get address of first number
	movq $my_numbers, %rbx

my_loop:
	# Get current number by getting its value with register indirect mode
	movq (%rbx), %rax
	
	# Compare it with current maximum.
	cmpq %rdi, %rax

	# If the current number is below or equal to the current maximum -> jump to check if there is another number to read.
	jbe loop_control

	# Otherwise, set the current number as new maximum.
	movq %rax, %rdi

loop_control:
	# Move the address to point to the next element. -> Could cause overflow by accessing not owned memory as it will be repeated after the last number of the array was read.
	add $8, %rbx
	# Check the decreased counter.
	loopq my_loop

end_of_program:	
	# Exit syscall
	movq $60, %rax
	syscall
