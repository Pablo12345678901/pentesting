	# This program will use a bitmask (with all bit unset except the fifth one) to compare it with a number in order to get the fifth bit of it.
	# It then returns the value of the fifth bit through the exit return code (0 = unset / 1 = set).
	.globl _start

	.section .data

my_number:
	#
	#.byte 0 		# 0 0 0 0 0 0 0 0 = 0
	#.byte 8		# 0 0 0 0 1 0 0 0 = 8 
	#byte 42		# 0 0 1 0 1 0 1 0 = 2 + 8 + 32 = 42
	.byte 247		# 1 1 1 1 0 1 1 1 = 255 - 8 = 247
	
	.section .text

_start:
	# Set default value of %rdi to 0
	xor %rdi, %rdi
	
	# Load the number value with %rax
	movq my_number, %rax
	
	# 'Bitmask' it to get fifth bit
	# All bits will be unset except fifth one
	testb $0b00001000, %al

	# If the bit is set (non-zero result from the 'and' (through 'test' instruction) then adapt exit return code
	jnz bit_is_set
	# Else direct exit
	jmp end

bit_is_set:
	movq $1, %rdi
	
end:	
	movq $60, %rax
	syscall
	
