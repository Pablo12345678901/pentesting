# This program computes if a number is even or odd and returns the exit code :
#	0, if odd
#	1, if even
#
# WARNING : return value is 1 = even and 0 = odd, even if it is ODD !

	.globl _start

	.section .data
	
number_to_check:	
	.byte 255

	.section .text
	
_start:
	# Get address of the number to check
	movq $number_to_check, %rdi
	
	# Copy this register into the accumulator
	# Needed for the division that will divide '%rax'
	movq (%rdi), %rax

	# Set a clean state of the reminder of the division ('0')
	movq $0, %rdx
	
	# Create a register holding '2' - needed during the division.
	movq $2, %rbx
	
	# Divide '%rax' by '%rbx' (2) to check with the rest ('%rdx') if it is even or odd - does not work if trying to divide by direct number as '$2'
	divq %rbx

	# Create the Values that can be returned by the program (0=false if odd, 1=true if evev)
	movq $1, %r8 # 1 = true = even
	movq $0, %r9 # 0 = false = odd

	# Compare the reminder with '0'
	cmp $0, %rdx
	# Set return value by setting exit code.
	# WARNING : 1 = even and 0 = odd, even if it is ODD !
	# If not equal to '0', then it is odd so returning '0'=false with '%r9' register
	cmovneq %r9, %rdi
	# If equal to '0', then it is even so returning '1'=true with '%r9' register
	cmoveq %r8, %rdi

	# System call to 'exit'
	movq $60, %rax
	syscall
