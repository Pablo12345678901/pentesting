	# This script will check byte by byte a text to see if the current char is a lowercase letter -  if so increase the counter of them.
	# It will do so by checking the two last ones of the register '%rax' that are : '%ah' (7th byte) and '%al' (8th byte).
	# During this check if will check whether the current char is :
	#	- the null char '\0' with a value of '0' and exit if so.
	#	- Else check if below the value of $'a' and if it is, check next byte.
	#		- Else check if above of the value of $'z' and if it is, check next byte.
	#			- Else increase the counter of lowercase letter because the current value is between $'a' and $'z' (inclusive x2) so it is a lowercase letter.
	# At the end, it returns the total number of lowercase letter.
	
	.globl _start

	.section .data
my_text:
	.ascii "This is a string of characters.\0"
	# There are :
	#  1 uppercase letter.
	# 24 lowercase letters.
	#  6 other chars (5 spaces and 1 dot).
	# __________________________________
	# 31 total chars.
	
	.section .text
_start:
	# Load the address of first char (and quadword).
	movq $my_text, %rbx

	# Set lowercase letter counter
	movq $0, %rdi
	
main_loop:
	# Get the current quadword
	movq (%rbx), %rax
	
byte1:
	# If the 8th byte (the last = least significant one) is null -> exit
	# The last byte is checked before the last previous one because memory is set in a little endian way with the least significant bit first (kind of 'natural reverse' order').
	# So the string     			"This is a string of characters.\0"
	# will be really saved in memory as : 	"\0.sretcarahc fo gnirts a si sihT"
	cmpb $0, %al
	je end_of_program
	
	# If the current char value is below the one of 'a', it is not a lowercase letter to check next byte.
	cmpb $'a', %al
	jb byte2

	# If the current char value is above the one of 'z', it is not a lowercase letter to check next byte.
	cmpb $'z', %al
	ja byte2
	
	# Else Increase the counter of lowercase letter.
	incq %rdi
	
byte2:
	cmpb $0, %ah
	je end_of_program
	cmpb $'a', %ah
	jb byte3
	cmpb $'z', %ah
	ja byte3
	incq %rdi

byte3:
	rorq $16, %rax
	cmpb $0, %al
	je end_of_program
	cmpb $'a', %al
	jb byte4
	cmpb $'z', %al
	ja byte4
	incq %rdi	
	
byte4:
	cmpb $0, %ah
	je end_of_program
	cmpb $'a', %ah
	jb byte5
	cmpb $'z', %ah
	ja byte5
	incq %rdi
	
byte5:
	# Shift in order to get the 2 next bytes available by rotating 16 bits = 2 bytes to the right (ro'r'q)
	rorq $16, %rax
	cmpb $0, %al
	je end_of_program
	cmpb $'a', %al
	jb byte6
	cmpb $'z', %al
	ja byte6
	incq %rdi	

byte6:
	cmpb $0, %ah
	je end_of_program
	cmpb $'a', %ah
	jb byte7
	cmpb $'z', %ah
	ja byte7
	incq %rdi

byte7:
	# Shift in order to get the 2 next bytes available by rotating 16 bits = 2 bytes to the right (ro'r'q)
	rorq $16, %rax
	cmpb $0, %al
	je end_of_program
	cmpb $'a', %al
	jb byte8
	cmpb $'z', %al
	ja byte8
	incq %rdi	

byte8:
	cmpb $0, %ah
	je end_of_program
	cmpb $'a', %ah
	jb loop_control
	cmpb $'z', %ah
	ja loop_control
	incq %rdi
	
loop_control:
	# Get next quadword by adding 8 bytes to the current address.
	addq $8, %rbx
	# Loop again
	jmp main_loop
	
end_of_program:
	# Exit syscall
	movq $60, %rax
	syscall
	
