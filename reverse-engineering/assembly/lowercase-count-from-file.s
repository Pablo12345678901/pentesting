	# This script count the number of lowercase letter in a string of characters (without space/tab/return) of maximum 49 chars (+1 for the null char) provided by a file .
	# The read file is called 'file_read.txt' and the written file with the result is called 'file_written.txt'.
	# Both file are opened and closed as quick as possible.
	.globl main

	.section .data

file_read:
	.ascii "file_read.txt\0"
file_read_open_mode:
	.ascii "r\0"
	
file_written:
	.ascii "file_written.txt\0"
file_written_open_mode:
	.ascii "w\0"
	
scan_format:
	# The maximum size will be 49 chars, that the final string will measure maximum 50 chars - 'null char' included
	.ascii "%49s\0"
result_message:
	.ascii "The total number of lowercase letter within the string provided is : %d \n\0"
	
	.section .text

	# The string is 50 bytes long - but the space was rounded to 8 bytes up to 56 in order to facilitate further alignment to 16 bytes.
	.equ LOCAL_OFFSET_STRING, -56
	.equ LOCAL_OFFSET_COUNTER, -64
	.equ LOCAL_OFFSET_FILE_STRUCT_READ, -72
	.equ LOCAL_OFFSET_FILE_STRUCT_WRITTEN, -80
		
main:
	# Making space for variables :
	# - one of them containing 50 chars (rounded up to 56 bytes)
	# - the counter of lowercase letter
	# - two pointer to file structs (one for the read file, the other for the written file)
	enter $80, $0

	# Open read file
	leaq file_read, %rdi
	leaq file_read_open_mode, %rsi
	call fopen
	# Save pointer to 'FILE' struct on stack
	movq %rax, LOCAL_OFFSET_FILE_STRUCT_READ(%rbp)
	
	# Scan input from file
	movq LOCAL_OFFSET_FILE_STRUCT_READ(%rbp), %rdi
	leaq scan_format, %rsi
	leaq LOCAL_OFFSET_STRING(%rbp), %rdx 
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fscanf

	# Close read file
	movq LOCAL_OFFSET_FILE_STRUCT_READ(%rbp), %rdi
	call fclose
	
	# Get address of first char and keep it within a register
	leaq LOCAL_OFFSET_STRING(%rbp), %rbx
	
	# Set counter of lowercase letter.
	movq $0, LOCAL_OFFSET_COUNTER(%rbp)
	
main_loop:
	# Load the char value into another register to check its value when debugging.
	movb (%rbx), %r8b
	
	# Check if current char is the null char '\0' and exit program if so.
	cmpb $0, %r8b
	je end
	
	cmpb $'a', %r8b
	jb get_next_char_address
	
	cmpb $'z', %r8b
	ja get_next_char_address
	
	# Else increase counter of lowercase letter.
	incq LOCAL_OFFSET_COUNTER(%rbp)

get_next_char_address:
	# Increase = + 1 = get next byte address.
	incq %rbx
	jmp main_loop

end:
	# Open written file
	# Open read file
	leaq file_written, %rdi
	leaq file_written_open_mode, %rsi
	call fopen
	# Save pointer to 'FILE' struct on stack
	movq %rax, LOCAL_OFFSET_FILE_STRUCT_WRITTEN(%rbp)
	
	# Write result message to file
	movq LOCAL_OFFSET_FILE_STRUCT_WRITTEN(%rbp), %rdi
	leaq result_message, %rsi
	movq LOCAL_OFFSET_COUNTER(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Close written file
	movq LOCAL_OFFSET_FILE_STRUCT_WRITTEN(%rbp), %rdi
	call fclose
	
	# Set a clean exit code for 'main'.
	xor %rax, %rax
	
	leave
	ret
