# Implementation of a multiplication in x86_64 assembly (1-bit operations):
#
# A * B = P
#
# Registers used :
# '%rax' = multiplicand low part (least significant)
# '%rdx' = multiplicand high part (most significant = the sign)
#
# '%rbx' = multiplier
#	
# '%rcx' = product low part (least significant)
# '%rsi' = product high part (most significant = the sign)
# '%r8'  = bit counter
#
# Theory about low | high part :
# Low part:
#	This refers to the least significant bits of the multiplication result.
#	For 64-bit integer multiplication, the low part is the 64 least significant bits of the product, which is what standard multiplication operations typically return.
#
# High part:
#	This refers to the most significant bits of the multiplication result that don't fit into the standard 64-bit result.
#	For 64-bit integer multiplication, the high part would be the 64 most significant bits of the full 128-bit product.
#
# When multiplying two 64-bit integers (uint64_t in C++), the result is actually a 128-bit value.
# However, standard multiplication operations only return the lower 64 bits (low part) of this result.
# The upper 64 bits (high part) are typically discarded in standard operations, but can be obtained through special functions or assembly instructions.
	
    .globl _start
    
    .section .data
    
multiplicand:
    .quad 0x1234567890abcdef
multiplier:
    .quad 0xfedcba9876543210
current_product:
    .quad 0, 0

    .section .text
    
_start: 
    # Load value to multiply into registers.
    movq multiplicand, %rax    # Load low part of multiplicand A into rax register (64 bits)
    movq multiplicand+8, %rdx  # Load high part of multiplicand A into rdx register (64 bits)
    movq multiplier, %rbx      # Load multiplier B into rbx register (64 bits)

    # Set '%rcx' (product low part), '%rsi' (product high part) and '%r8' (bit counter) to '0' in an elegant manner with 'XOR' instruction.
    xorq %rcx, %rcx  # Initialize low part of product P to 0 in rcx register (64 bits)
    xorq %rsi, %rsi  # Initialize high part of product P to 0 in rsi register (64 bits)
    xorq %r8, %r8    # Initialize bit counter to 0 in r8 register (64 bits)
    
loop_on_bit:
    # Iterate over bits of 'B'
    # Check if current bit (bit number in %r8) of B is 1
    btq %r8, %rbx    # Test bit r8 of rbx
    jnc check_if_there_is_a_next_bit_available

    # Else if bit is 1, add shifted A to P
    addq %rax, %rcx    # Add multiplicand low part to rcx (64 bits)
    adcq %rdx, %rsi    # Add multiplicand high part with carry to rsi (64 bits)

check_if_there_is_a_next_bit_available:
    # Shift A (multiplicand) left by 1 bit
    shlq $1, %rax      # Shift low part of rax left by 1 bit (64 bits)
    rclq $1, %rdx      # Shift high part of rdx left by 1 bit with carry (64 bits)

    # Increment bit counter and check if all bits processed
    incq %r8         
    cmpq $64, %r8
    
    # Loop only if not all bits processed
    jl loop_on_bit
    # Else set result
    jmp set_final_result

set_final_result:    
    movq %rcx, current_product    # Store low part of final product
    movq %rsi, current_product+8  # Store high part of final product
    jmp end_of_program

end_of_program:
    # Exit syscall with return code set to '0'.
    movq $0, %rdi
    movq $60, %rax
    syscall
