#include <stdio.h>

/* Define function prototypes */
void * allocate(int) ;
void deallocate(void *) ;
void deallocate_all_blocks(void) ;

/* This program uses (and has to be linked with) the assembly functions ('allocate', 'deallocate' and 'deallocate_all_blocks') from the file 'allocate-with-mmap.s' that reproduce the behaviour of 'malloc' and 'free' from standard C library.
   It is a modified version of the file 'use-allocate-and-deallocate-functions.c' in order to request allocation for thousands of bytes instead of max 1 thousand bytes. To do so, it will use a backend with 'mmap' system calls.
   It will perform memory allocations for several buffer, deallocate one of them and re-perform allocation.
   Printed message shows the address of such pointers demonstrating that deallocation enable re-allocating the same space if it it big enough for the requested allocation size.
 */
int main() {

  /* --------------------------- START OF DATA TO ADAPT ------------------------------------ */
  
  /* Set here size of buffers as tests values for the functions */
  /* BASE DATA - SEE COMMENTS */
  int size_of_a1_buffer = 10000 ;
  int size_of_a2_buffer = 100 ;
  int size_of_a3_buffer = 200 ;
  int size_of_a4_buffer = 500 ;
  int size_of_a5_buffer = 2000 ;
  int size_of_a6_buffer = 10000 ;
  
  /* This value should be adapted depending on the header size of an individual memory allocation rounded up to a 16 multiple.
     For the exact size, look at the individual memory allocation header elements within the file 'allocate-with-mmap.s' and deduce the rounded up size.
  */
  int buffer_header_size_aligned_to_a_16_multiple = 16 ; 
  
  /* The later value will be used within a printed message */
  int max_number_of_char_within_a1_buffer = size_of_a1_buffer -1 ;
  int max_number_of_char_within_a4_buffer = size_of_a4_buffer -1 ;
  int max_number_of_char_within_a5_buffer = size_of_a5_buffer -1 ;

  /* --------------------------- END OF DATA TO ADAPT -------------------------------------- */
  
  /* Set three pointer to the returned value from the 'allocate' function
     And print a message before and after each allocation - this helps for debugging.
  */
  fprintf(stdout, "\nAllocation of 'a1'...\n\n") ;  
  char *a1 = allocate(size_of_a1_buffer) ;
  fprintf(stdout, "\nDONE : Allocation of 'a1' at address %p.\n", a1) ;

  fprintf(stdout, "\nAllocation of 'a2'...\n\n") ;  
  char *a2 = allocate(size_of_a2_buffer) ;
  fprintf(stdout, "\nDONE : Allocation of 'a2' at address %p.\n", a2) ;

  fprintf(stdout, "\nAllocation of 'a3'...\n\n") ;  
  char *a3 = allocate(size_of_a3_buffer) ;
  fprintf(stdout, "\nDONE : Allocation of 'a3' at address %p.\n", a3) ;

  /* Print pointer values obtained */
  fprintf(stdout, "\nSUMMARIZE : Allocations V1 : a1 = %p, a2 = %p, a3 = %p\n", a1, a2, a3) ;

  /* Fill the 'a1' buffer */
  /* Require input from user */
  fprintf(stdout, "\nPlease provide a string of maximum %d chars for the a1 buffer.\n", max_number_of_char_within_a1_buffer) ;
  /* Set maximum string size to avoid buffer overflow */
  fscanf(stdin, "%9999s", a1) ;
  /* Print such string to stdout */
  fprintf(stdout, "\nThe string you provided is :\n%s\n", a1) ;
  
  /* Deallocate one of the pointers
     And print a message before and after - this helps for debugging.
   */
  fprintf(stdout, "\nDeallocation of 'a1' at address %p...\n\n", a1) ;  
  deallocate(a1) ;
  fprintf(stdout, "\nDONE : Deallocation of 'a1' : free %d bytes + header (%d bytes) = %d bytes at address %p.\n", size_of_a1_buffer, buffer_header_size_aligned_to_a_16_multiple, size_of_a1_buffer + buffer_header_size_aligned_to_a_16_multiple, a1) ;

  /* Perform three more allocations
     And print a message before and after each allocation - this helps for debugging.
  */

  fprintf(stdout, "\nAllocation of 'a4'...\n\n") ;  
  char *a4 = allocate(size_of_a4_buffer) ;
  fprintf(stdout, "\nDONE : Allocation of 'a4' at address %p.\n", a4) ;
  
  fprintf(stdout, "\nAllocation of 'a5'...\n\n") ;  
  char *a5 = allocate(size_of_a5_buffer) ;
  fprintf(stdout, "\nDONE : Allocation of 'a5' at address %p.\n", a5) ;

  fprintf(stdout, "\nAllocation of 'a6'...\n\n") ;  
  char *a6 = allocate(size_of_a6_buffer) ;
  fprintf(stdout, "\nDONE : Allocation of 'a6' at address %p.\n", a6) ;

  /* Print pointer values obtained */
  fprintf(stdout, "\nSUMMARIZE : Allocations V2 : a4 = %p, a5 = %p, a6 = %p\n", a4, a5, a6) ;
  
  /* Overwrite what was on the 'a1' buffer.
  /* Require input from user */
  fprintf(stdout, "\nPlease provide a string of maximum %d chars for the a4 buffer.\n", max_number_of_char_within_a4_buffer) ;
  /* Set maximum string size to avoid buffer overflow */
  fscanf(stdin, "%499s", a4) ;
  /* Print such string to stdout */
  fprintf(stdout, "\nThe string you provided is :\n%s\n", a4) ;

  /* This is not mandatory but was implemented for fun and for using good programming behaviour of deallocating what was allocated by the end of program. */
  deallocate_all_blocks() ;
  
  return 0 ;
}
