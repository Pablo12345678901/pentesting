# Notice that the computation here is basic A + B = C but put C into B.
# But by the same way, it sets 'exit' return code '%rdi'
# It is quite elegant even if simple.
	
	.globl _start
	
	.section .data

flag_minimum_or_maximum:
	# Set here to 0 to get the minimum
	# and to anything else (1-255) for the maximum of the below array composed of a numbers list.
	# .quad 0 # Flag unset : get the minimum of the number list.
	.quad 1 # Flag set   : get the maximum of the number list.
	# .quad 2 # Flag wrongfully set : Will cause error and exit with error '1'.
	# .quad 100

default_maximum:
	.quad 255
	
default_minimum:
	.quad 0
	
list_length:
	# Set here the number of numbers
	.quad 6
	
list_of_numbers:
	.quad 15, 13, 11, 17, 12, 14

	.section .text
_start:
	# Get address of first array element
	movq $list_of_numbers, %rdi

	# Set counter to loop
	movq list_length, %rcx

	# Set the default maximum / minimum depending on the flag.
	# If looking for the minimum, set to 255 (maximum value) and vice-versa (0 as minimum value if looking for the maximum).
	cmpq $1, flag_minimum_or_maximum

	# If the flag is below 1, it is therefore '0' (minimum value of range 0-255). => Set default minimum as the maximum value of the range.
	cmovbq default_maximum, %rax

	# Else if the flaf is 1 => Set the default maximum as the minimum value of the range.
	cmoveq default_minimum, %rax

	# If the flag is not 0 (minimum value) and not '1',
	# therefore it is wrongfully set and error exit code (1) will be set.
	ja exit_with_error_flag_not_set_correctly

	jmp get_current_element
	
get_current_element:	
	# Get current array element
	movq (%rdi), %rbx

	# Check the flag and apply the wished 'function' min(=0)/max(=1)/error(=else)
	cmpq $1, flag_minimum_or_maximum

	# If the flag is below 1, it is therefore '0' (minimum value of range 0-255). => get the minimum.
	jb get_the_minimum

	# Else if the flaf is 1 => get the maximum.
	je get_the_maximum
			
get_the_minimum:
	# Compare_elements
	cmpq %rbx, %rax
	# Keep the lower = only move if '%rax' was greater ('cmovGq')) than '%rbx' = current array number
	cmovgq %rbx, %rax
	jmp check_if_reached_array_end

get_the_maximum:
	# Compare_elements
	cmpq %rbx, %rax
	# Keep the bigger = only move if '%rax' was lower ('cmovLq') than '%rbx' = current array number
	cmovlq %rbx, %rax
	jmp check_if_reached_array_end

check_if_reached_array_end:	
	# Check if reached array end	
	loopq get_next_memory_location
	jmp end_of_program

get_next_memory_location:
	# Move the pointer to next array element.
	addq $8, %rdi
	jmp get_current_element

exit_with_error_flag_not_set_correctly:
	# Set the result that will be moved into '%rdi' to 1 = error
	movq $1, %rax
	
end_of_program:	
	# Set return code
	movq %rax, %rdi
	# Exit system call
	movq $60, %rax
	syscall
