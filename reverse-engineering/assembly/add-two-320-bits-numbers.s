	# This program will add two 320 bits (= 5 * 64 bits) register number and save the value within the registers combination :
	#   %r8:%r9:%r10:%r11:%r12
	# + %rax:%rbx:%rcx:%rdx:%rsi
	#___________________________
	# = %rax:%rbx:%rcx:%rdx:%rsi
	# As this value is 320 bits is too big to be returned, a debugguer is needed to check all 5 results value.
	# The exit return code '%rdi' represents whether an overflow occurs by checking whether the carry flag is set after the last addition.
	# The value returned is '1' if overflow (carry flag set) or '0' else.
	
	.globl _start
	.section .text
	
_start:
	# Set default exit return code value to '0'.
	movq $0, %rdi
	
	# Set all registers.
	# FIRST NUMBER REGISTERS (DEST)
	# All 4 most significant registers are set to 'maximal unsigned value - 1' (1...10)
	movq $0b1111111111111111111111111111111111111111111111111111111111111110, %rax
	movq $0b1111111111111111111111111111111111111111111111111111111111111110, %rbx
	movq $0b1111111111111111111111111111111111111111111111111111111111111110, %rcx
	movq $0b1111111111111111111111111111111111111111111111111111111111111110, %rdx
	# Last significant register is set to 'maximal unsigned value' (1...1)
	movq $0b1111111111111111111111111111111111111111111111111111111111111111, %rsi

	# SECOND NUMBER REGISTERS (SOURCE)
	# Most significant register -> (un)comment the lines depending on the wished behaviour :
	#	- If the most significant register is set to '0', no overflow (carry) will occurs.
	#	- Else if the most significant register is set to '1', an overflow (carry) will occurs.
	movq $0b0000000000000000000000000000000000000000000000000000000000000000, %r8
	#movq $0b0000000000000000000000000000000000000000000000000000000000000001, %r8
	# All 4 least significant registers are set to the value '1'
	movq $0b0000000000000000000000000000000000000000000000000000000000000001, %r9
	movq $0b0000000000000000000000000000000000000000000000000000000000000001, %r10
	movq $0b0000000000000000000000000000000000000000000000000000000000000001, %r11
	movq $0b0000000000000000000000000000000000000000000000000000000000000001, %r12

	# REMARK ABOUT ADDITION
	# All addition except the last one will result in '0 + a carry'.
	# The last addition will result in the maximal unsigned value (1...1).
	
	# Add the two least significant registers of each number (one least with the least of the other number).
	addq %r12, %rsi
	
	# Add with carry all pairs of 64 bits registers starting from the least significant ones.
	adcq %r11, %rdx
	adcq %r10, %rcx
	adcq %r9, %rbx
	adcq %r8, %rax

	# Check whether an overflow occurred (carry flag set) and go to the relevant code section.
	jc overflow_occured
	jnc end_of_program

overflow_occured:
	# Set the exit code to '1' if an overflow (carry) occurred.
	movq $1, %rdi
	
end_of_program:
	# Exit syscall
	movq $60, %rax
	syscall
