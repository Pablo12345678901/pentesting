	# This program will ask the user an input that represent the number of times that it has to loop.
	# It checks errors : will exit with an different error message if the case is that the number provided is '0' or if it is above 255.
	# Else, it will print a loop message at each loop with the loop number and a final confirmation message.
	.globl main

	.section .data

asking_user_input:
	.ascii "How much times would you like to loop (range 1-255) ?\n-> \0"

scan_format_input:
	.ascii "%d\0"
	
loop_message:
	.ascii "Loop number %d.\n\0"
	
exit_error_message_zero_provided:
	.ascii "ERROR : The number provided is '0' therefore no loop will be processed.\n\0"
	
exit_error_message_value_too_big_provided:
	.ascii "ERROR : The number provided '%d' is above 255. Please provided a number in the range 1-255.\n\0"

exit_normal_message:
	.ascii "%d loop were sucessfully processed.\n\0"
	
	.section .text

	.equ LOCAL_OFFSET_NUMBER, -8
	.equ LOCAL_OFFSET_LOOP_COUNTER_FOR_PRINTED_MESSAGE, -16
	.equ LOCAL_OFFSET_LOOP_COUNTER_FOR_LOOPQ, -24
	
main:
	# Making space for three variables
	enter $32, $0

	# Asking user input
	movq stdout, %rdi
	leaq asking_user_input, %rsi
	# Set %rax to '0' for a variadic function using non-floating-point arguments only.
	movq $0, %rax
	call fprintf

	# Scanning user input
	movq stdin, %rdi
	leaq scan_format_input, %rsi
	leaq LOCAL_OFFSET_NUMBER(%rbp), %rdx
	# Set %rax to '0' for a variadic function using non-floating-point arguments only.
	movq $0, %rax
	call fscanf
	
	# Check if loop wished is '0' 
	cmpq $0, LOCAL_OFFSET_NUMBER(%rbp)
	# If so exit with error code
	je error_exit_zero_provided
	# Else set the counter later used through %rcx.
	# This is done that way even if '%rcx' will not be used with such value as it is not possible to 'movq' with two addresses as in 'movq LOCAL_OFFSET_NUMBER(%rbp), LOCAL_OFFSET_LOOP_COUNTER_FOR_LOOPQ(%rbp)' (wrong - will cause an error message 'too many references were provided to movq instruction'.)
	movq LOCAL_OFFSET_NUMBER(%rbp), %rcx
	# And save it into a local variable
	movq %rcx, LOCAL_OFFSET_LOOP_COUNTER_FOR_LOOPQ(%rbp)
	
	# Check if the number provided is above 255 and exit with error if so.
	cmpq $255, LOCAL_OFFSET_NUMBER(%rbp)
	ja error_exit_value_too_big_provided
	
	# Set loop counter for printed messages
	movq $0, LOCAL_OFFSET_LOOP_COUNTER_FOR_PRINTED_MESSAGE(%rbp) 
	
loop_again:
	# Increase loop number for printed messages
	incq LOCAL_OFFSET_LOOP_COUNTER_FOR_PRINTED_MESSAGE(%rbp)

	# Print loop number
	movq stdout, %rdi
	leaq loop_message, %rsi
	movq LOCAL_OFFSET_LOOP_COUNTER_FOR_PRINTED_MESSAGE(%rbp), %rdx
 	# Set %rax to '0' for a variadic function using non-floating-point arguments only.
	movq $0, %rax
	call fprintf

	# Load current decreasing counter into %rcx
	movq LOCAL_OFFSET_LOOP_COUNTER_FOR_LOOPQ(%rbp), %rcx
	# Decrease the local counter because it is not done through 'loopq'
	decq LOCAL_OFFSET_LOOP_COUNTER_FOR_LOOPQ(%rbp)
	
	# Decrement '%rcx' and loop as long as it is not '0'
	loopq loop_again
	
	# After, when '%rcx' is '0', it ends program.
	jmp normal_exit

error_exit_zero_provided:
 	# Print error message
	movq stdout, %rdi
	leaq exit_error_message_zero_provided, %rsi
	# Set %rax to '0' for a variadic function using non-floating-point arguments only.
	movq $0, %rax
	call fprintf

	# Set exit return code to error = 1
	movq $1, %rax

	leave
	ret

error_exit_value_too_big_provided:
 	# Print error message
	movq stdout, %rdi
	leaq exit_error_message_value_too_big_provided, %rsi
	movq LOCAL_OFFSET_NUMBER(%rbp), %rdx
	# Set %rax to '0' for a variadic function using non-floating-point arguments only.
	movq $0, %rax
	call fprintf

	# Set exit return code to error = 2
	movq $2, %rax
	
	leave
	ret
	
normal_exit:
	# Print final message
	movq stdout, %rdi
	leaq exit_normal_message, %rsi
	movq LOCAL_OFFSET_LOOP_COUNTER_FOR_PRINTED_MESSAGE(%rbp), %rdx
	# Set %rax to '0' for a variadic function using non-floating-point arguments only.
	movq $0, %rax
	call fprintf
	
	# Set exit return code to '0' = ok
	xor %rax, %rax
	
	leave
	ret
	
