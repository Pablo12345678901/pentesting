	# This program is an enhancement of the file 'use-allocate-function-with-user-interraction.s'.
	# Just before its end, it asks the user whether to repeat with another allocation.
	# Due to the behaviour of 'allocate', if the new allocation is of the same size or below the previous one(s) performed, such new allocation will take the same address.
	# Else, a new address will be requested and allocated.
	# This program use the function 'allocate' from the file 'allocate.s' that reproduce 'malloc' - so it has to be linked with it.
	# It will ask the user how many bytes to allocate for a buffer.
	# Then it will allocate it + 1 byte (for the null char) and print the address of the new buffer.
	# Then it will ask with which char to fill it.
	# Then it will fill it and print the buffer content.
	.globl main
	.extern allocate, deallocate # Such function come from the object file obtained from 'allocate.s'.
	
	.section .rodata
	
message_ask_bytes_number:
	.ascii "\nPlease provide the number of bytes to allocate for the buffer (null char NOT included - the program will increase the buffer size and add it to its end).\n-> \0"

scan_format_requested_number_of_bytes:
	.ascii "%d\0"

message_print_allocation_address:
	.ascii "\nThe address of the new allocation of %d bytes is %d.\n\0"

message_ask_char_to_fill_allocation_with:
	.ascii "\nWith which char would you like to fill the allocation ? Please type one char and then enter.\n-> \0"
	
scan_format_requested_char_to_fill_allocation_with:
	.ascii "%c\0"
	
message_print_fill_allocation:
	.ascii "\nThe buffer of %d bytes will be filled with the char '%c'.\n\0"
	
message_print_allocation_content:
	.ascii "\nThe content of the allocation is :\n'%s'\n\0"

message_confirm_deallocation:
	.ascii "\nThe content located at the address %d was deallocated.\n\0"
	
message_ask_whether_to_continue:
	.ascii "\nWould you like to scan another string ? \nPress 'Y' to continue or anything else to end this program. \n-> \0"
	
scan_format_continue:
	.ascii "%c\0" # A leading space is written before the char to scan in order to avoid having the newline from precedent scanning as first char.
	
message_confirmation_exit:
	.ascii "\nYou choosed to end this program.\n\0"

	
	.section .text

	.equ LOCAL_OFFSET_ALLOCATION_ADDRESS, -8
	.equ LOCAL_OFFSET_NUMBER_OF_BYTES_REQUESTED, -16
	.equ LOCAL_OFFSET_CHAR_TO_FILL_ALLOCATION_WITH, -24
	.equ LOCAL_OFFSET_CONTINUE, -32
	
clean_stdin_buffer:
	# This function scans each char of the 'stdin' buffer until it finds a newline or EOF.
	# Scan current char
	movq stdin, %rdi # fgetc : (from its 'man' page) reads the next character from stream and returns it as an unsigned char cast to an int, or EOF on end of file or error.
	call fgetc
	# Compare it to a few values to know whether continue scanning
	cmpq $10, %rax # Compare to newline = 10
	je buffer_cleaned	
	cmpq $-1, %rax # Compare to EOF = -1
	je buffer_cleaned
	# Scan next char
	jmp clean_stdin_buffer

buffer_cleaned:	
	ret
	
main:
	# Make space for variable(s) :
	# - pointer on address allocated
	# - number of bytes requested
	# - char to fill buffer with
	# - the flag provided from the user to repeat the program ("Y") or exit (ANYTHING ELSE)
	enter $32, $0
	
	# Ask user how many bytes he want to allocate - null char included
	movq stdout, %rdi
	leaq message_ask_bytes_number, %rsi
	# No floating-point arguments with variadic function.
	movq $0, %rax
	call fprintf

	# Get from user the number of bytes of the allocation.
	movq stdin, %rdi
	leaq scan_format_requested_number_of_bytes, %rsi
	leaq LOCAL_OFFSET_NUMBER_OF_BYTES_REQUESTED(%rbp), %rdx
	# No floating-point arguments with variadic function.
	movq $0, %rax
	call fscanf

	# Clear stdin buffer
	call clean_stdin_buffer

	# Ask user the char to fill the allocation with
	movq stdout, %rdi
	leaq message_ask_char_to_fill_allocation_with, %rsi
	# No floating-point arguments with variadic function.
	movq $0, %rax
	call fprintf

	# Get from user the char to fill the allocation with
	# Get from user the number of bytes of the allocation.
	movq stdin, %rdi
	leaq scan_format_requested_char_to_fill_allocation_with, %rsi
	leaq LOCAL_OFFSET_CHAR_TO_FILL_ALLOCATION_WITH(%rbp), %rdx
	# No floating-point arguments with variadic function.
	movq $0, %rax
	call fscanf
	
	# Clear stdin buffer
	call clean_stdin_buffer
	
	# Increase requested size by 1 for the null char
	movq LOCAL_OFFSET_NUMBER_OF_BYTES_REQUESTED(%rbp), %rdi
	incq %rdi
	# Allocate the memory requested by user
	call allocate

	# Save address of new allocation on stack
	movq %rax, LOCAL_OFFSET_ALLOCATION_ADDRESS(%rbp)
	
	# Print allocation address
	movq stdout, %rdi
	leaq message_print_allocation_address, %rsi
	movq LOCAL_OFFSET_NUMBER_OF_BYTES_REQUESTED(%rbp), %rdx
	movq LOCAL_OFFSET_ALLOCATION_ADDRESS(%rbp), %rcx
	# No floating-point arguments with variadic function.
	movq $0, %rax
	call fprintf

	# Print message to user to announce allocation filling
	movq stdout, %rdi
	leaq message_print_fill_allocation, %rsi
	movq LOCAL_OFFSET_NUMBER_OF_BYTES_REQUESTED(%rbp), %rdx
	movq LOCAL_OFFSET_CHAR_TO_FILL_ALLOCATION_WITH(%rbp), %rcx
	call fprintf

	# Save the number of bytes requested within %rcx for loopq decreasing counter
	movq LOCAL_OFFSET_NUMBER_OF_BYTES_REQUESTED(%rbp), %rcx

	# Save the allocation address within '%rdi' for further filling with 'movs'
	movq LOCAL_OFFSET_ALLOCATION_ADDRESS(%rbp), %rdi
	# Load the address of the char with which fill to allocation to '%rsi' for further filling with 'movs'
	leaq LOCAL_OFFSET_CHAR_TO_FILL_ALLOCATION_WITH(%rbp), %rsi

loop_to_fill_allocation:
	# Copy the char at the address of '%rsi' to the address of '%rdi'
	movsb
	# As both '%rdi' and '%rsi' are incremented (by default if direction flag is unset) at the end of 'movs' instruction, ...
	# ... decrement '%rsi' to keep the address of the char to copy.
	decq %rsi
	loopq loop_to_fill_allocation
	
	# Set the null char within the address of last char - contained within %rdi after loops end.
	movq $0, (%rdi)
	
print_allocation_content:	
	# Print the content of the allocation
	movq stdout, %rdi
	leaq message_print_allocation_content, %rsi
	movq LOCAL_OFFSET_ALLOCATION_ADDRESS(%rbp), %rdx
	# No floating-point arguments with variadic function.
	movq $0, %rax
	call fprintf

deallocate_content:
	movq LOCAL_OFFSET_ALLOCATION_ADDRESS(%rbp), %rdi
	call deallocate

	# Print message to tell user that deallocation was performed.
	movq stdout, %rdi
	leaq message_confirm_deallocation, %rsi
	movq LOCAL_OFFSET_ALLOCATION_ADDRESS(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf
	
repeat_program_or_exit:
	# Ask user input - whether to continue or not
	movq stdout, %rdi
	leaq message_ask_whether_to_continue, %rsi
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Set the flag to a default non-continue value
	# This is mandatory as soon as the program re-start.
	movq $0, LOCAL_OFFSET_CONTINUE(%rbp)
	
	# Scan user answer
	movq stdin, %rdi
	leaq scan_format_continue, %rsi
	leaq LOCAL_OFFSET_CONTINUE(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fscanf

	# Empty stdin buffer
	call clean_stdin_buffer
	
	# Get address of the char and keep it within a register
	leaq LOCAL_OFFSET_CONTINUE(%rbp), %rbx
	# Get first char value = byte
	movb (%rbx), %r8b
	# If the value provided by the user is the 'continue-flag', repeat the program from the beginning.
	cmpb $'Y', %r8b
	# Jump conditionaly depending on user input
	je restart
	jne definitive_exit

restart:
	# Re-set stack as in initial state
	leave
	# Re-start program
	jmp main
	
definitive_exit:	
	# Else print exit message
	movq stdout, %rdi
	leaq message_confirmation_exit, %rsi
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Set clean exit return code for 'main'
	xor %rax, %rax
	
	leave
	ret
	
	# Set non-executable stack ("") that contains program data "@progbits"
	.section .note.GNU-stack, "", @progbits
