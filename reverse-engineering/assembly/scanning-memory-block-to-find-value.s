	.globl _start

	.section .data

# This value will be needed to compute the index of the searched (if any found) value.
.equ SIZE_OF_ONE_ELEMENT, 8 # 8 bytes for 1 quadword, as the 'dest' array contains quadwords.
	
array_size:
	.quad 5

value_searched:
	.quad 99
	
dest:
	# Array to be searched through for the above value.
	# Test datas - uncomment only one of the lines below
	#.quad 99, 23, 55,  1,  3	# Value at index 0
	#.quad  9, 99, 55,  1,  3	# Value at index 1
	#.quad  9, 23, 99,  1,  3	# Value at index 2
	#.quad  9, 23, 55, 99,  3	# Value at index 3
	.quad  9, 23, 55,  1, 99	# Value at index 4
	#.quad  9, 23, 55,  1,  3	# Value not present

	.section .text
	
_start:
	# Set destination registers to the address of the first array element.
	leaq dest, %rdi

	# Set the counter for repetition 'rep'
	movq array_size, %rcx

	# Set the searched value
	movq value_searched, %rax
	
	# Scan the array through the addresses contained within '%rdi' for the value 'value_searched' held within '%rax'
	repne scasq
	# After the scan, check whether the comparison resulted in equality and jump depending on it.
	je value_found
	jne value_not_found

value_not_found:
	# Set exit return code to '255' to show that the value was not found
	# This value was choosed to simplify the program as no such size of array will be defined here.
	movq $255, %rdi
	jmp finish
	
value_found:
	# Uncomment one of the two lines below in order to choose by which process the index of the value found should be returned.
	# This was done only for fun of training several implementation.
	#jmp return_index_through_computation_with_rcx
	jmp return_index_through_computation_with_rdi
	
return_index_through_computation_with_rcx:	
	# Get total number of indexes
	movq array_size, %rbx
	# Decrement it as first index is 0 and not 1 (so last index is 'size-1')
	decq %rbx
	# Substract to it the current number of index to be processed
	subq %rcx, %rbx
	# Set exit return code to the first index matching the searched value
	# REMINDER : first index start at '0'.
	movq %rbx, %rdi
	jmp finish
	
return_index_through_computation_with_rdi:
	# Load the address of first element
	leaq dest, %rsi
	# Substract it with the address of next element
	subq %rsi, %rdi
	# Move the difference within '%rax' for further division
	movq %rdi, %rax
	# Set %rdx to '0' before division to avoid garbage data within the dividend '%rdx:%rax'.
	xorq %rdx, %rdx
	# Set the divisor as a register containing the size of one element as it is not possible to divide by an immediate value (number).
	leaq SIZE_OF_ONE_ELEMENT, %rbx
	# Divide the byte difference between the two addresses by the size of one element
	divq %rbx
	# Decrement %rax as first index is '0' and last index is 'array_size - 1'
	decq %rax
	# Set exit return code to the index of the value found.
	movq %rax, %rdi
	jmp finish
	
finish:
	# Exit syscall
	movq $60, %rax
	syscall
	
