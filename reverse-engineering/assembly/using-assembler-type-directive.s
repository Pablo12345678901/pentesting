	# This program use the '.type' directive and is very simple.
	.globl main, print_hello_world, number_of_printed_message
	.type print_hello_world, @function
	.type number_of_printed_message, @object

	.section .data
message_hello_world:
	.ascii "Hello, world %d ! \n\0"
number_of_printed_message:
	.quad 8

	.section .text

	.equ LOCAL_OFFSET_LOOP_COUNTER, -8

print_hello_world:
	# Set the first argument provided to the function as of the variable used by the printed format.
	movq %rdi, %rdx
	
	movq stdout, %rdi
	leaq message_hello_world, %rsi
	
	# No floating-point values within variadic function arguments.
	movq $0, %rax
	call fprintf
	ret

main:
	# Making space for :
	# - loop decreasing counter
	enter $16, $0
	# Save the loop decreasing counter on the stack
	movq number_of_printed_message, %rcx
	movq %rcx, LOCAL_OFFSET_LOOP_COUNTER(%rbp)
	
loop_and_print:
	movq LOCAL_OFFSET_LOOP_COUNTER(%rbp), %rdi
	call print_hello_world
	# Decrease the counter each time that a message is printed
	decq LOCAL_OFFSET_LOOP_COUNTER(%rbp)
	# Loop while counter is not '0'.
	cmpq $0, LOCAL_OFFSET_LOOP_COUNTER(%rbp)
	jne loop_and_print
	
end:	
	# Set 'main' exit return code to '0'.
	xor %rax, %rax

	leave
	ret
