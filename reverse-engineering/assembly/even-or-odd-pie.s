	# This program asks the user a number, computes whether is even or odd and print a result message.
	# It is written to respect 'PIC' (position-independent code) rules and will be compiled to be a 'PIE' (position-independent executable) with the 'gcc' '-pie' option.

	.globl main
	
#-------------------------------------------------------------------
	
	.section .bss
	
number_to_check:	
	.zero 8

#-------------------------------------------------------------------
	
	.section .rodata

message_request_number:
	.ascii "\nPlease provide a number :\n-> \0"

scan_format_number:
	.ascii "%d\0"

message_result:
	.ascii "\nThe number %d is %s.\n\0"
even:
	.ascii "even\0"
odd:
	.ascii "odd\0"

#-------------------------------------------------------------------

	.section .text

clean_stdin_buffer:
	# This function scans each char of the 'stdin' buffer until it finds a newline or EOF.
	# Check stack alignment as other function is called from within.
	enter $0, $0
	
	# Scan current char
	# Set input to stdin
	movq stdin@GOTPCREL(%rip), %rdi # fgetc : (from its 'man' page) reads the next character from stream and returns it as an unsigned char cast to an int, or EOF on end of file or error.
	movq (%rdi), %rdi
	call fgetc
	# Compare it to a few values to know whether continue scanning
	cmpq $10, %rax # Compare to newline = 10
	je buffer_cleaned	
	cmpq $-1, %rax # Compare to EOF = -1
	je buffer_cleaned	
	jmp clean_stdin_buffer

buffer_cleaned:	
	leave
	ret
	
main:
	# Check stack alignment as other function is called from main.
	enter $0, $0

	# Request a number from the user by printing a message.
	# Set output to 'stdout'
	movq stdout@GOTPCREL(%rip), %rdi
	movq (%rdi), %rdi
	# Set message to print
	leaq message_request_number(%rip), %rsi
	# No floating-point arguments for variadic function.
	movq $0, %rax
	call fprintf@plt
	
	# Scan it from stdin.
	movq stdin@GOTPCREL(%rip), %rdi
	movq (%rdi), %rdi
	# Set scan format
	leaq scan_format_number(%rip), %rsi
	# Set address where to save the scanned number
	leaq number_to_check(%rip), %rdx
	# No floating-point arguments for variadic function.
	movq $0, %rax
	call fscanf@plt
	
	# Empty stdin buffer.
	call clean_stdin_buffer@plt
	
	# Get address of the number to check
	leaq number_to_check(%rip), %rdi
	
	# Copy this register content into the accumulator
	# Needed for the division that will divide '%rax'
	movq (%rdi), %rax

	# Set a clean state of the reminder of the division ('0')
	movq $0, %rdx
	
	# Create a register holding '2' - needed during the division.
	movq $2, %rbx
	
	# Divide '%rax' by '%rbx' (2) to check with the rest ('%rdx') if it is even or odd - does not work if trying to divide by direct number as '$2'
	divq %rbx

	# Set strings 'even' and 'odd' within separate registers.
	leaq even(%rip), %r8 # 'even' string 
	leaq odd(%rip), %r9 # 'odd' string

	# Compare the reminder with '0'
	cmp $0, %rdx
	# Set specific string used within printed result depending on the comparison
	# If not equal to '0', then it is odd so set 'odd' string within the '%rcx' register used below by the print format.
	cmovneq %r9, %rcx
	# If equal to '0', then it is even so set 'even' string within the '%rcx' register used below by the print format.
	cmoveq %r8, %rcx

	
	# Print result message
	# Set output to 'stdout'
	movq stdout@GOTPCREL(%rip), %rdi
	movq (%rdi), %rdi
	# Set message to print
	leaq message_result(%rip), %rsi
	# Set argument used within print format.
	movq number_to_check(%rip), %rdx # The number
	# The result odd/even was set above within '%rcx'.
	# No floating-point arguments for variadic function.
	movq $0, %rax
	call fprintf@plt

	# Set return code of 'main' to '0'.
	xor %rax, %rax

	leave
	ret
	
#-------------------------------------------------------------------

	# Set non-executable stack for more security.
	.section .note.GNU-stack, "", @progbits
