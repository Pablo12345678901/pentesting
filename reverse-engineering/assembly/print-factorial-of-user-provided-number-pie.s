	# This program asks the user a number, computes its factorial through a shared library created from the file 'factorial-function-definition-pic.s' containing the 'factorial' function and print a result message.
	# It is written to respect 'PIC' (position-independent code) rules and will be compiled to be a 'PIE' (position-independent executable) with the 'gcc' '-pie' option.

	.globl main
	
#-------------------------------------------------------------------
	
	.section .bss
	
number_provided:	
	.zero 8

#-------------------------------------------------------------------
	
	.section .rodata

message_request_number:
	.ascii "\nPlease provide a number :\n-> \0"

scan_format_number:
	.ascii "%d\0"

message_result:
	.ascii "\nThe factorial of number %d is %d.\n\0"

#-------------------------------------------------------------------

	.section .text

clean_stdin_buffer:
	# This function scans each char of the 'stdin' buffer until it finds a newline or EOF.
	# Check stack alignment as other function is called from within.
	enter $0, $0
	
	# Scan current char
	# Set input to stdin
	movq stdin@GOTPCREL(%rip), %rdi # fgetc : (from its 'man' page) reads the next character from stream and returns it as an unsigned char cast to an int, or EOF on end of file or error.
	movq (%rdi), %rdi
	call fgetc
	# Compare it to a few values to know whether continue scanning
	cmpq $10, %rax # Compare to newline = 10
	je buffer_cleaned	
	cmpq $-1, %rax # Compare to EOF = -1
	je buffer_cleaned	
	jmp clean_stdin_buffer

buffer_cleaned:	
	leave
	ret
	
main:
	# Check stack alignment as other function is called from main.
	enter $0, $0

	# Request a number from the user by printing a message.
	# Set output to 'stdout'
	movq stdout@GOTPCREL(%rip), %rdi
	movq (%rdi), %rdi
	# Set message to print
	leaq message_request_number(%rip), %rsi
	# No floating-point arguments for variadic function.
	movq $0, %rax
	call fprintf@plt
	
	# Scan it from stdin.
	movq stdin@GOTPCREL(%rip), %rdi
	movq (%rdi), %rdi
	# Set scan format
	leaq scan_format_number(%rip), %rsi
	# Set address where to save the scanned number
	leaq number_provided(%rip), %rdx
	# No floating-point arguments for variadic function.
	movq $0, %rax
	call fscanf@plt
	
	# Empty stdin buffer.
	call clean_stdin_buffer@plt

	# Compute factorial of provided number.
	# Get address of the number provided.
	leaq number_provided(%rip), %rdi
	# Get its value from its address
	movq (%rdi), %rdi
	call factorial@plt
	
	# Set the result from the 'factorial' function as one of the print format argument (the second one).
	movq %rax, %rcx

	# Print result message
	# Set output to 'stdout'
	movq stdout@GOTPCREL(%rip), %rdi
	movq (%rdi), %rdi
	# Set message to print
	leaq message_result(%rip), %rsi
	# Set argument used within print format.
	movq number_provided(%rip), %rdx # The number
	# The result of the 'factorial' function was set above within '%rcx'.
	# No floating-point arguments for variadic function.
	movq $0, %rax
	call fprintf@plt

	# Set return code of 'main' to '0'.
	xor %rax, %rax

	leave
	ret
	
#-------------------------------------------------------------------

	# Set non-executable stack for more security.
	.section .note.GNU-stack, "", @progbits
