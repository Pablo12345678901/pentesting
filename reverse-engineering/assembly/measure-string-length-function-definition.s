	# This program scan a string char by char until it finds the null char ('\0').
	# As soon as found, it compare the string length by deducing from the address of last char (+1) the address of initial char.
	# A little adjustment (-1) to the above result is needed as 'repne scasb' will increase (+1) the address at the end of each repetition.
	# Finally, the string length is returned as exit code of the program.
	.globl measure_string_length

	.section .text

measure_string_length:
	# 16 bytes alignment
	enter $16, $0
	
	# Keep the address of first char on the stack.
	movq %rdi, -8(%rbp)

	# Keep the value of '%rcx' to train the 'preservation' concept - EVEN IF - %rcx is not protected by convention and could therefore be overwritten.
	movq %rcx, -16(%rbp)

	# Set %rcx to a huge value signed '-1' = unsigned maximum value (only 1's in binary : 1...1)
	# %rcx is needed for the 'scas' instruction that will be repeated with the 'repne' while %rcx is above '0'.
	movq $-1, %rcx
	
	# Set the search value to null char with value 0 = '\0'
	movq $0, %rax
	
	# Scan until search value is not found.
	repne scasb

	# Substract current address (of null char found) with address of first char
	subq -8(%rbp), %rdi
	# Deduce 1 as 'scasb' always increase (+1) the address at the end of each repetition.
	decq %rdi
	# The %rdi value will be returned as program exit code.
	movq %rdi, %rax

	# Re-set %rdi and %rcx to initial value to train the 'preservation' concept - EVEN IF - they are not protected by convention and could therefore be overwritten.
	movq -8(%rbp), %rdi
	movq -16(%rbp), %rcx
	
	# Function end ('leave' answers to the above 'enter').
	leave	
	ret

