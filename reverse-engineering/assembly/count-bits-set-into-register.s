	# This program checks the number of bits set ('1') within a specified value.
	# It processes by checking the least significant bit - with a 'testb' instruction that used the $0b00000001 bitmask.
	# Depending on whether the last bit is set, it will rotate the register by 1 bit to the right (if the bit is not set) or increase the counter and then rotate.
	# It will repeat the operation 64 times for checking all individual bits of the 64 bits register %rax.
	# A few test values are available in order to test this program.
	
	.globl _start
	.section .text
_start:
	# Set the counter of bits set to '0'.
	movq $0, %rdi

	# Set the counter of the bits to be checked to 64.
	movq $64, %rcx
	
	# Set to '0' the register to avoid garbage value within the 64 bits register.
	movq $0, %rax
	
	# Set here the value from which the number of set bits ('1') have to be obtained.
	# Adapt the size of the operation and the register as wished.
	#movb $0b11111111, %al # 8 * 1
	movb $0b01101001, %al # 4 * 1 + 4 * 0
	#movq $0b1111111111111101111111111111111111011111111111111111111101111111, %rax # 61 * 1 + 3 * 0
	#movq $0b1111111111111111111111111111111111111111111111111111111111111111, %rax # 64 * 1

main_loop:	
	# Check whether the least significant bit is '1'.
	testb $0b00000001, %al

	# If not, rotate and repeat if needed
	jz rotate_and_repeat_if_needed

	# Else Increase counter only if the 'and' with the bitmask returned non-zero value ('1').
	incq %rdi

rotate_and_repeat_if_needed:
	# Rotate of 1 bit to the right the register
	# Uncomment one of two lines below depending on whether the initial value is needed at the end (uncomment 'rorq' line) or not (uncomment 'shrq' line)
	rorq $1, %rax
	#shrq $1, %rax
	
	# Decrease counter and repeat if needed
	loopq main_loop
	
end_of_program:
	# Exit syscall
	movq $60, %rax
	syscall
