	# This program gets the current time, and increase it of 3 seconds (of advance).
	# Then it will compare the current time with the advanced one and loop while not reaching it.
	# This simulates a 'sleep'.
	.globl _start

	.section .data

current_time:
	# Null ptr, the time will be stored here :
	.quad 0
	
	.section .text

_start:
	# 'time' syscall = 201
	movq $201, %rax
	# Load the pointer with address of current time within %rdi
	leaq current_time, %rdi
	syscall

	# Store the 'time' returned value into another register
	movq current_time, %rdx

	# Increase the seconds to compute future time.
	# This future time will be compared with current one and a loop will reproduce this comparison as long as needed.
	addq $5, %rdx

time_loop:
	# 'time' syscall = 201
	movq $201, %rax
	# Load address of the current_time variable within '%rdi'
	leaq current_time, %rdi
	syscall

	# Loop while the current time is below '%rdx' content (that is 5 seconds later than '%rdi')
	cmpq %rdx, current_time
	jb time_loop

finish:
	# Exit syscall
	movq $60, %rax
	# Set exit return code
	movq $0, %rdi
	syscall
