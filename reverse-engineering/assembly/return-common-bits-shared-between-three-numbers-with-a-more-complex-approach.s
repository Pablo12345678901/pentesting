	# 'AND' each number of an array with a bitmask initially set to '0...01' and that will be rotated.
	# Instead of 'AND'ing each number with the final result initially set to '1...1', the check is done bit by bit.
	# Each bit is checked one by one for all array numbers and then a rotation is processed to the bitmask in order to check next bit for all three numbers.
	# Then depending on the check, the final result is updated with a reverse bitmask (only 1's with one '0' for the current bit checked) IF and ONLY IF the bit was not set in the current number checked.
	# This program has lots of non-optimized steps because the intention was to train coding.
	# The final result will be returned as the exit return code of the program.
	.globl _start	

	.section .data

array_size:
	# Adapt here the array size if required (if wanted to test array of more than 3 numbers).
	.quad 3
	
array_of_numbers:
	# uncomment one line and comment the others to test program.
	#.byte 0, 1, 255	# Common bits : 0 0 0 0 0 0 0 0 =  0 
	#.byte 12, 24, 187	# Common bits : 0 0 0 0 1 0 0 0 =  8
	.byte 187, 24, 12	# Common bits : 0 0 0 0 1 0 0 0 =  8  
	#.byte 24, 187, 191	# Common bits : 0 0 0 1 1 0 0 0 = 24
	#.byte 33, 105, 181	# Common bits : 0 0 1 0 0 0 0 1 = 33
	
# Binary to decimal equivalence :
# 0 0 0 0 0 0 0 0	= 0 * 2^7 + 0 * 2^6 + 0 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 0 * 2^0 =   0
# 0 0 0 0 1 1 0 0	= 0 * 2^7 + 0 * 2^6 + 0 * 2^5 + 0 * 2^4 + 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0 =  12
# 0 0 0 1 1 0 0 0 	= 0 * 2^7 + 0 * 2^6 + 0 * 2^5 + 1 * 2^4 + 1 * 2^3 + 0 * 2^2 + 0 * 2^1 + 0 * 2^0 =  24
# 0 0 1 0 0 0 0 1 	= 0 * 2^7 + 0 * 2^6 + 1 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0 =  33
# 0 1 1 0 1 0 0 1 	= 0 * 2^7 + 1 * 2^6 + 1 * 2^5 + 0 * 2^4 + 1 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0 = 105
# 1 0 1 1 0 1 0 1 	= 1 * 2^7 + 0 * 2^6 + 1 * 2^5 + 1 * 2^4 + 0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 181
# 0 1 1 1 1 0 1 1	= 0 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = 187
# 0 1 1 1 1 1 1 1	= 0 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = 191

	.section .text

_start:
	# Registers used :
	# %rax	= current number value
	# %rbx	= bit processed counter
	# %rcx	= decreasing counter of elements to be processed
	# %rdi	= address of current number / exit return code (at the end)
	# %rdx	= current bitmask (that will be rotated after checking each bit)
	# %r8	= final result returned

	# Load the address of first array element.
	leaq array_of_numbers, %rdi
	# Load it again to re-set it later to first element address when the above register will be modified.
	leaq array_of_numbers, %rsi
	
	# Set array size
	movq array_size, %rcx

	# Set current bitmask (the bitmask will be rotated by one bit after each bit check.
	movb $0b00000001, %dl

	# Set default final result to only 1's (1...1)
	movb $0b11111111, %r8b
	
load_current_element:	
	# Get current element
	movb (%rdi), %al

compare_current_bit:
	testb %dl, %al
	jz unset_current_bit
	jnz get_next_address
	
unset_current_bit:
	# Reverse bitmask to set all bits except to one that was searched
	notb %dl
	# 'AND' the reversed bitmask with final result in order to unset the searched bit.
	andb %dl, %r8b
	# Reverse again bitmask to reset it to initial state at the start of this step.
	notb %dl
	
get_next_address:
	# Increase the current address by one byte
	incq %rdi
	loopq load_current_element

get_next_bit:
	# Re-set %rcx and %rdi to initial state
	movq array_size, %rcx
	movq %rsi, %rdi
	# Rotate the bitmask to the right by 1 bit 
	rorb $1, %dl
	incq %rbx
	cmpq $8, %rbx
	# If all bits of the byte (8/8) were processed, end program.
	je finish
	# Else re-load the first array element
	jne load_current_element
		
finish:		
	# Set the result as the exit return code
	movq %r8, %rdi
	movq $60, %rax
	syscall

