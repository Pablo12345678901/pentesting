# This program computes if a number is even or odd and will call a different function depending on it
#	factorial function if even - see the file 'factorial-function-definition.s'
#	exponent function at power 3 if odd - see the file 'exponent-function-definition.s'
#
	.globl customized_function_behaviour_depending_on_odd_or_even_number_provided

	.section .text

	# Registers modified through this function :
	# %rax		OK because will be obtained from other function AND because does not have to be preserved.
	# %rbx		NOT OK -> has to be preserved so see below...
	# %rdi 		OK because does not have to be preserved - it will be 'forwarded' to the other function.
	# %rdx		OK because does not have to be preserved.
	# %rsi		OK because does not have to be preserved.
	#
	# REMINDER : 
	# Preservation of specific registers
	# The content of registers :
	#     - %rbp
	#     - %rbx
	#     - %r12 to %r15
	# ... have to be PRESERVED.
	#
	# The below offset was set to hold a register value in order to re-set it just after usage and before calling any function.
	.equ LOCAL_OFFSET_RBX, -8
	
customized_function_behaviour_depending_on_odd_or_even_number_provided:
	# Alignment on 16 bytes multiple.
	enter $16, $0

	# Copy the number provided as first argument into the accumulator
	# Needed for the division that will divide '%rax'
	movq %rdi, %rax

	# Set a clean state of the reminder of the division ('0')
	movq $0, %rdx

	movq %rbx, LOCAL_OFFSET_RBX(%rbp)
	
	# Create a register holding '2' - needed during the division.
	movq $2, %rbx
	
	# Divide '%rax' by '%rbx' (2) to check with the rest ('%rdx') if it is even or odd - does not work if trying to divide by direct number as '$2'
	divq %rbx

	# Re-set the '%rbx' initial value
	movq LOCAL_OFFSET_RBX(%rbp), %rbx
	
	# Compare the reminder with '0'
	cmpq $0, %rdx
	# If even, call factorial function
	je call_factorial_function
	# Else (if odd), call exponent function with an exponent of 3
	jne call_exponent_function

call_factorial_function:
	call factorial
	leave
	ret

call_exponent_function:
	# Set exponent (second function argument) to '3'.
	movq $3, %rsi
	call exponent
	leave
	ret
