	# This program tries to reproduce 'malloc' and 'free' implementation.
	# It will first check whether the memory pointers ('memory_start' and 'memory_end', that represents the pointer to were a block starts and were it ends) were initialized.
	# Then, if not, it will initialize them to current 'program break'.
	# Then it will process to a loop until allocation was performed :
	# It will check whether both pointer are equal : whether all blocks were checked so far and if so, save the current program break to be returned and then move it of the total size (total size = requested + header size).
	# Else, it will check the current block composed of a header and the block content.
	# The header size if composed of two quadwords :
	# - first  : a flag that shows whether the block examined is in use ('1') or not ('0').
	# - second : the size of such block (= header + block content)
	# So, it will first check whether the block is available and if not, add its size to the current 'memory start' (start of the block) to obtain address of next block.
	# Else, it will check whether the block content size (second quadword of the header) is enough for the requested size (total size = requested + header).
	# If it is enough, it will allocate the block but setting the first quadword of the header to unavailable (=1) and return the address of the current memory_start + header size = pointer to block content.
	# Else, it will check the next block.
	# This program have to be linked with the 'C' program 'use-allocate-and-deallocate-functions.c' and then this later executed.
	# This program could be enhanced by aligning all addresses to a 16 bytes multiple as requested by standard C library functions with x86-64 architecture.
	.globl allocate, deallocate
	.type allocate, @function
	.type deallocate, @function

	# Allocate two quadword (8 bytes each) within uninitialized data section '.bss'.
	.section .bss
	
memory_start:
	.zero 8
memory_end:
	.zero 8
	
	.section .text

	# The header size if composed of two quadwords :
	# - first  : a flag that shows whether the block examined is in use ('1') or not ('0').
	# - second : the size of such block (= header + block content)
	.equ HEADER_SIZE, 16
	.equ OFFSET_HEADER_IN_USE, 0
	.equ OFFSET_HEADER_SIZE, 8
	
	# This constant is used to help code reading.
	.equ BREAK_SYSCALL, 12

	# Register usage :
	# %rcx = pointer to memory end saved as a copy
	# %rdx = size requested
	# %rsi = pointer to current memory (start) being examined
	# %r8  = pointer to new allocation (when returned to user : beyond the header)
		
allocate:
	# Save the amount requested (first argument of 'allocate') into %rdx
	movq %rdi, %rdx
	# Add the header size to this requested size as each block is added a header at the beginning.
	addq $HEADER_SIZE, %rdx
	
	# Compare the memory start with '0' to check whether the initialization was already not done
	cmpq $0, memory_start
	# If so, process to initialization
	je allocate_init
	# Else, skip the initialization
	jne allocate_continue

allocate_init:
	# Get the current program break
	movq $0, %rdi
	leaq BREAK_SYSCALL, %rax
	syscall

	# The current break will be both the start and end of our memory
	movq %rax, memory_start
	movq %rax, memory_end
	
	jmp allocate_continue
	
allocate_continue:
	# Load values of the pointer to the start and end of memory within registers.
	movq memory_start, %rsi
	movq memory_end, %rcx
	jmp allocate_loop
	
allocate_loop:
	# Check whether the end of memory was reached -> memory start = memory end
	cmpq %rsi, %rcx
	# If it is the case, move the program break
	je allocate_move_break

	# Else, check whether the next block is available from its 'flag' (OFFSET_HEADER_IN_USE(%rsi)) within the header
	cmpq $0, OFFSET_HEADER_IN_USE(%rsi)
	# If not, try next block.
	jne try_next_block

	# Else, compare the block size with what was requested
	cmpq %rdx, OFFSET_HEADER_SIZE(%rsi)
	# If the block size is below what is requested, try next block.
	jb try_next_block
	# Else the block available is sufficiently big for the request.
	# So mark it as unavailable.
	movq $1, OFFSET_HEADER_IN_USE(%rsi)
	# Move address beyond the header
	addq $HEADER_SIZE, %rsi
	# And return such address
	movq %rsi, %rax
	ret

allocate_move_break:
	# Old break is save in %r8 to be later returned to user
	movq %rcx, %r8

	# Calculate where the new break will be
	# = old break + size
	# Set %rdi to the old break.
	movq %rcx, %rdi
	# Add the size to it.
	addq %rdx, %rdi
	# Save this value
	movq %rdi, memory_end

	# Tell Linux where the new break is
	leaq BREAK_SYSCALL, %rax
	syscall

	# Address of new allocation is in %r8
	# Mark the block as unavailable
    	movq $1, OFFSET_HEADER_IN_USE(%r8)
	# Note its size
	movq %rdx, OFFSET_HEADER_SIZE(%r8)
	# Get the block address beyond the header by adding the header size to it.
	addq $HEADER_SIZE, %r8
	# Set such value as the returned one.
	movq %r8, %rax
	ret
	
try_next_block:
	# If the block examined before was not convenient (not available or not big enough)
	# Add its size to pointer within %rsi
	addq OFFSET_HEADER_SIZE(%rsi), %rsi
	# Repeat the allocation loop = check whether next block that became current one is available and big enough
	jmp allocate_loop
	
deallocate:
	# Freeing a block is simple - we just have to mark it as available
	movq $0, OFFSET_HEADER_IN_USE - HEADER_SIZE(%rdi)
	ret
