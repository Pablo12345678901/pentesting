#include <stdio.h>

/* Define function prototypes */
void * allocate(int) ;
void deallocate(void *) ;

/* This program uses (and has to be linked to the file) the assembly functions 'allocate' and 'deallocate' from the file 'allocate.s' that reproduce the behaviour of 'malloc' and 'free' from standard C library.
   It will perform memory allocations for several buffer, deallocate one of them and re-perform allocation.
   Printed message shows the address of such pointers demonstrating that deallocation enable re-allocating the same space if it it big enough for the requested allocation size.
 */
int main() {
  /* Set three pointer to the returned value from the 'allocate' function
     And print a message before and after each allocation - this helps for debugging.
  */
  fprintf(stdout, "\nAllocation of 'a1'...\n") ;  
  char *a1 = allocate(500) ;
  fprintf(stdout, "\nDONE : Allocation of 'a1'\n") ;

  fprintf(stdout, "\nAllocation of 'a2'...\n") ;  
  char *a2 = allocate(1000) ;
  fprintf(stdout, "\nDONE : Allocation of 'a2'\n") ;

  fprintf(stdout, "\nAllocation of 'a3'...\n") ;  
  char *a3 = allocate(100) ;
  fprintf(stdout, "\nDONE : Allocation of 'a3'\n") ;

  /* Print pointer values obtained */
  fprintf(stdout, "\nSUMMARIZE : Allocations V1 : a1 = %d, a2 = %d, a3 = %d\n", a1, a2, a3) ;

  /* Deallocate one of the pointers
     And print a message before and after - this helps for debugging.
   */
  fprintf(stdout, "\nDeallocation of 'a1'...\n") ;  
  deallocate(a1) ;
  fprintf(stdout, "\nDONE : Deallocation of 'a1' : free 500 bytes + header (16 bytes) = 516 bytes.\n") ;

  /* Perform three more allocations
     And print a message before and after each allocation - this helps for debugging.
     The first one is too big to be allocated to what was 'freed' by the 'deallocate' function.
     The second one is enough little to fit within the space left by 'a1'.
     But the third not, because :
     - 'a1' was big of : 500 bytes + header (16 bytes) = 516 bytes
     - 'a4' is 1000 bytes + header (16 bytes) so it is bigger than 516 bytes (a1).
     - 'a5' is 250 bytes + header (16 bytes) so it is 266 bytes -> 'a5' fits within the space left by 'a1'.
     - But then, only 516 - 266 = 250 bytes are left. Not enough for the 266 bytes of 'a6'.
  */
  fprintf(stdout, "\nAllocation of 'a4'...\n") ;  
  char *a4 = allocate(1000) ;
  fprintf(stdout, "\nDONE : Allocation of 'a4'\n") ;

  fprintf(stdout, "\nAllocation of 'a5'...\n") ;  
  char *a5 = allocate(250) ;
  fprintf(stdout, "\nDONE : Allocation of 'a5'\n") ;

  fprintf(stdout, "\nAllocation of 'a6'...\n") ;  
  char *a6 = allocate(250) ;
  fprintf(stdout, "\nDONE : Allocation of 'a6'\n") ;

  /* Print pointer values obtained */
  fprintf(stdout, "\nSUMMARIZE : Allocations V2 : a4 = %d, a5 = %d, a6 = %d\n", a4, a5, a6) ;

  /* Require input from user */
  fprintf(stdout, "\nPlease provide a string of maximum 249 chars for the a5 buffer.\n") ;
  /* Set maximum string size to avoid buffer overflow */
  fscanf(stdin, "%249s", a5) ;
  /* Print such string to stdout */
  fprintf(stdout, "\nThe string you provided is :\n%s\n", a5) ;
  
}
