	# This script will check at each index of the array if the searched value is the one on the current index.
	# If so, it breaks the loop and return '1' as exit code (=true).
	# Else, it returns '0' (=false).
	
	.globl _start

	.section .data

number_of_numbers:
	.quad 7
	
list_of_numbers:
	.quad 200, 20, 33, 80, 52, 10, 100

number_searched:
	.quad 200
	
	.section .text
_start:
	# Registers used :
	# %rax : current index content value - and at the end, replaced by the syscall number.
	# %rbx : number to check if it is part of array.
	# %rcx : current index AND loop counter
	# %rdi : current result and exit return code

	# Set the first index explored (last array index + 1)
	movq number_of_numbers, %rcx
	
	# IF array has no value, ends.
	cmp $0, %rcx
	je end_of_program

	# ELSE

	# Set default exit code to '0' = false = searched value not found in array
	movq $0, %rdi
	
	# Set searched value
	movq number_searched, %rbx

main_loop:
	# Get current value but start with an offset of '-8' to ensure that only index 0 to X (array max index) and not 1 to X+1 are explored as %rcx start at the number of elements which is also index max+1.
	movq list_of_numbers-8(, %rcx, 8), %rax

	# Compare current value with searched value.
	cmp %rbx, %rax

	je searched_value_found_set_exit_code_and_exit

	jne loop_control
	
searched_value_found_set_exit_code_and_exit:

	# Set return code to 1 = true = searched value found.
	movq $1, %rdi

	# Then exit
	jmp end_of_program

loop_control:	
	# Check if still index to check (%rcx > 0) and if so - compare indexed value with current maximum.
	loopq main_loop
	jmp end_of_program
	
end_of_program:
	movq $60, %rax
	syscall
