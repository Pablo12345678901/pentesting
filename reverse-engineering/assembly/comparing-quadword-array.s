	.globl _start

	.section .data

array_size:
	.quad 5
source:
	# Source array
	.quad 9, 23, 55, 1, 3
dest:
	# Destination array
	# Test datas - uncomment only one of the lines below
	.quad 9, 23, 55, 1, 3 # Same array
	#.quad 1, 23, 55, 1, 3 # First index (0) has a value lower
	#.quad 9, 22, 55, 1, 3 # Second index (1) has a value lower
	#.quad 9, 23, 54, 1, 3 # Third index (2) has a value lower
	#.quad 9, 23, 55, 1, 2 # Last index (4) has a value lower
	#.quad 9, 23, 55, 1, 4 # Last index (4) has a value bigger

	.section .text
	
_start:
	# Set source and destination registers to the address of first element of both arrays.
	movq $source, %rsi
	movq $dest, %rdi
	
	# Set the counter for repetition 'rep'
	movq array_size, %rcx

	# Compare both arrays and jump depending on equality
	repe cmpsq
	je arrays_equal
	jne arrays_not_equal

arrays_equal:
	# Set exit return code to '0'
	xorq %rdi, %rdi
	jmp finish
	
arrays_not_equal:	
	# Get total number of indexes
	movq array_size, %rbx
	# Decrement it as first index is 0 and not 1 (so last index is 'size-1')
	decq %rbx
	# Substract to it the current number of index to be processed
	subq %rcx, %rbx
	# Set exit return code to the first index not equal while comparing
	# REMINDER : first index start at '0'.
	movq %rbx, %rdi
	jmp finish
	
finish:
	# Exit syscall
	movq $60, %rax
	syscall
	
