# This program computes if a number is even or odd and returns the exit code :
#	0, if odd
#	1, if even
#
# WARNING : return value is 1 = even and 0 = odd, even if it is ODD !
#
# But this program does not use the division by '2' as usual.
# Indeed, it will :
#	Check the current result...
#		If it is above or equal to 2, it disminishes it by 2.
#		Else, it set a return value (for the exit status) :
#			1, if the current result (rest) is 0 -> meaning that the initial number can be expressed as 'NUMBER = X * 2 + 0' so it is 'even'.
#			0, if the current result (rest) is 1 -> meaning that the initial number can be expressed as 'NUMBER = X * 2 + 1' so it is 'odd'.

	.globl _start

	.section .data

number_to_check:
	# Set here the number to be checked if even (return code = 1) or odd (return code = 0).
	.byte 253

	.section .text
	
_start:
	# Get address of the number to check
	movq $number_to_check, %rdi
	
	# Copy this register into the accumulator
	# Needed for the division that will divide '%rax'
	movq (%rdi), %rax
	
	# Setting a loop counter equivalent to the number to check
	# That way, a maximum of itself loop can be performed, but that will never be the case that the counter get below NUMBER_TO_CHECK/2.
	addq %rax, %rcx

	# In case the precedent arithmetic operation results in '0', meaning that '%rax is equivalent to '0', fast exit by avoiding the loop.
	jz get_exit_status
	
main_loop:
	# Compare the number with '2' to know if it is still possible to disminish it by 2, or if not -> meaning the final result ('%rax' that is used as a kind of 'reminder') can be understood as :
	#	if      '%rax' = 1 -> that means the number is 'X * 2 + 1' = odd
	#	else if '%rax' = 0 -> that means the number is 'X * 2 + 0' = even
	#
	cmp $2, %rax
	# If the rest is above or equal to two, disminish it by 2.
	jae diminution_of_two

	# Else, get the get the exit status depending on '%rax' : 1 = even, 0 = odd.
	jl get_exit_status

diminution_of_two:
	# Disminish '%rax' by 2.
	subq $2, %rax
	# Get back to main loop.
	jmp main_loop
	
get_exit_status:	
	# Create the Values that can be returned by the program (0=false if odd, 1=true if evev)
	movq $1, %r8 # 1 = true = even
	movq $0, %r9 # 0 = false = odd

	# Compare the reminder with '0'
	cmp $0, %rax
	# Set return value by setting exit code.
	# WARNING : 1 = even and 0 = odd, even if it is ODD !
	# If not equal to '0', then it is odd so returning '0'=false with '%r9' register
	cmovneq %r9, %rdi
	# If equal to '0', then it is even so returning '1'=true with '%r9' register
	cmoveq %r8, %rdi

	# Syscall of exit with exit code equivalent to '%rdi'
	jmp end_of_program

end_of_program:	
	# System call to 'exit'
	movq $60, %rax
	syscall
