	# This program scan a string char by char until it finds the null char ('\0').
	# As soon as found, it compare the string length by deducing from the address of last char (+1) the address of initial char.
	# A little adjustment (-1) to the above result is needed as 'repne scasb' will increase (+1) the address at the end of each repetition.
	# Finally, the string length is returned as exit code of the program.
	.globl _start

	.section .data

my_string:
	# Test value for which the length will be returned as exit code of the program.
	# Uncomment ONLY one line and comment the others.
	.ascii "This is a specific string used to measure its(self) length.\0" # Length = 59 chars
	#.ascii "12\0" # Length = 2 chars (Short string for easy program debugging)
	#.ascii "123456789\0" # Length = 9 chars

	.section .text

_start:
	# Set %rcx to a huge value signed '-1' = unsigned maximum value (only 1's in binary : 1...1)
	# %rcx is needed for the 'scas' instruction that will be repeated with the 'repne' while %rcx is above '0'.
	movq $-1, %rcx

	# Keep the address of first char to see it through a debugger.
	leaq my_string, %rbx

	# Load address of first char
	leaq my_string, %rdi
	# Set the search value to null char with value 0 = '\0'
	movq $0, %rax
	
	# Scan until search value is not found.
	repne scasb

	# Substract current address (of null char found) with address of first char
	subq $my_string, %rdi
	# Deduce 1 as 'scasb' always increase (+1) the address at the end of each repetition.
	decq %rdi
	# The %rdi value will be returned as program exit code.
end:
	# Exit syscall
	movq $60, %rax
	syscall
