	# This program use the function 'allocate' from the file 'allocate.s' that reproduce 'malloc' - so it has to be linked with it.
	# It will ask the user how many bytes to allocate for a buffer.
	# Then it will allocate it + 1 byte (for the null char) and print the address of the new buffer.
	# Then it will ask with which char to fill it.
	# Then it will fill it and print the buffer content.
	.globl main
	.extern allocate, deallocate # Such function come from the object file obtained from 'allocate.s'.
	
	.section .rodata
	
message_ask_bytes_number:
	.ascii "\nPlease provide the number of bytes to allocate for the buffer (null char NOT included - the program will increase the buffer size and add it to its end).\n-> \0"

scan_format_requested_number_of_bytes:
	.ascii "%d\0"

message_print_allocation_address:
	.ascii "\nThe address of the new allocation of %d bytes is %d.\n\0"

message_ask_char_to_fill_allocation_with:
	.ascii "With which char would you like to fill the allocation ? Please type one char (except space/tab) and then enter.\n-> \0"
	
scan_format_requested_char_to_fill_allocation_with:
	.ascii "%c\0"
	
message_print_fill_allocation:
	.ascii "\nThe buffer of %d bytes will be filled with the char '%c'.\n\0"
	
message_print_allocation_content:
	.ascii "\nThe content of the allocation is :\n'%s'\n\0"

	.section .text

	.equ LOCAL_OFFSET_ALLOCATION_ADDRESS, -8
	.equ LOCAL_OFFSET_NUMBER_OF_BYTES_REQUESTED, -16
	.equ LOCAL_OFFSET_CHAR_TO_FILL_ALLOCATION_WITH, -24
	
clean_stdin_buffer:
	# This function scans each char of the 'stdin' buffer until it finds a newline or EOF.
	# Scan current char
	movq stdin, %rdi # fgetc : (from its 'man' page) reads the next character from stream and returns it as an unsigned char cast to an int, or EOF on end of file or error.
	call fgetc
	# Compare it to a few values to know whether continue scanning
	cmpq $10, %rax # Compare to newline = 10
	je buffer_cleaned	
	cmpq $-1, %rax # Compare to EOF = -1
	je buffer_cleaned
	# Scan next char
	jmp clean_stdin_buffer

buffer_cleaned:	
	ret
	
main:
	# Make space for variable(s) :
	# - pointer on address allocated
	# - number of bytes requested
	# - char to fill buffer with
	enter $32, $0
	
	# Ask user how many bytes he want to allocate - null char included
	movq stdout, %rdi
	leaq message_ask_bytes_number, %rsi
	# No floating-point arguments with variadic function.
	movq $0, %rax
	call fprintf

	# Get from user the number of bytes of the allocation.
	movq stdin, %rdi
	leaq scan_format_requested_number_of_bytes, %rsi
	leaq LOCAL_OFFSET_NUMBER_OF_BYTES_REQUESTED(%rbp), %rdx
	# No floating-point arguments with variadic function.
	movq $0, %rax
	call fscanf

	# Clear stdin buffer
	call clean_stdin_buffer

	# Ask user the char to fill the allocation with
	movq stdout, %rdi
	leaq message_ask_char_to_fill_allocation_with, %rsi
	# No floating-point arguments with variadic function.
	movq $0, %rax
	call fprintf

	# Get from user the char to fill the allocation with
	# Get from user the number of bytes of the allocation.
	movq stdin, %rdi
	leaq scan_format_requested_char_to_fill_allocation_with, %rsi
	leaq LOCAL_OFFSET_CHAR_TO_FILL_ALLOCATION_WITH(%rbp), %rdx
	# No floating-point arguments with variadic function.
	movq $0, %rax
	call fscanf
	
	# Clear stdin buffer
	call clean_stdin_buffer
	
	# Increase requested size by 1 for the null char
	movq LOCAL_OFFSET_NUMBER_OF_BYTES_REQUESTED(%rbp), %rdi
	incq %rdi
	# Allocate the memory requested by user
	call allocate

	# Save address of new allocation on stack
	movq %rax, LOCAL_OFFSET_ALLOCATION_ADDRESS(%rbp)
	
	# Print allocation address
	movq stdout, %rdi
	leaq message_print_allocation_address, %rsi
	movq LOCAL_OFFSET_NUMBER_OF_BYTES_REQUESTED(%rbp), %rdx
	movq LOCAL_OFFSET_ALLOCATION_ADDRESS(%rbp), %rcx
	# No floating-point arguments with variadic function.
	movq $0, %rax
	call fprintf

	# Print message to user to announce allocation filling
	movq stdout, %rdi
	leaq message_print_fill_allocation, %rsi
	movq LOCAL_OFFSET_NUMBER_OF_BYTES_REQUESTED(%rbp), %rdx
	movq LOCAL_OFFSET_CHAR_TO_FILL_ALLOCATION_WITH(%rbp), %rcx
	call fprintf

	# Save the number of bytes requested within %rcx for loopq decreasing counter
	movq LOCAL_OFFSET_NUMBER_OF_BYTES_REQUESTED(%rbp), %rcx

	# Save the allocation address within '%rdi' for further filling with 'movs'
	movq LOCAL_OFFSET_ALLOCATION_ADDRESS(%rbp), %rdi
	# Load the address of the char with which fill to allocation to '%rsi' for further filling with 'movs'
	leaq LOCAL_OFFSET_CHAR_TO_FILL_ALLOCATION_WITH(%rbp), %rsi

loop_to_fill_allocation:
	# Copy the char at the address of '%rsi' to the address of '%rdi'
	movsb
	# As both '%rdi' and '%rsi' are incremented (by default if direction flag is unset) at the end of 'movs' instruction, ...
	# ... decrement '%rsi' to keep the address of the char to copy.
	decq %rsi
	loopq loop_to_fill_allocation
	
	# Set the null char within the address of last char - contained within %rdi after loops end.
	movq $0, (%rdi)
	
print_allocation_content:	
	# Print the content of the allocation
	movq stdout, %rdi
	leaq message_print_allocation_content, %rsi
	movq LOCAL_OFFSET_ALLOCATION_ADDRESS(%rbp), %rdx
	# No floating-point arguments with variadic function.
	movq $0, %rax
	call fprintf

deallocate_content:
	movq LOCAL_OFFSET_ALLOCATION_ADDRESS(%rbp), %rdi
	call deallocate
	
end:	
	# Set 'main' return code to '0'.
	xor %rax, %rax
	
	leave
	ret
