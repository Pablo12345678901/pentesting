	# This program count the number of lowercase letter in a string of characters (without space/tab/return) of maximum 49 chars (+1 for the null char) provided by the user.
	# At the end, it will ask the user if he wants to continue - if yes, he provides 'Y' as answer.
	# The method to scan such answer is by scanning stdin for one char with scan format "%c\0".
	# Such scan is possible because the 'stdin' buffer was emptied before after each scan - else the newline from the first scan would be the char scanned by the second scan.
	# Empty the stdin buffer was coded as a function that use 'fgetc' to loop on the buffer content until a newline or 'EOF' is met.
	# Providing anything else will stop the program.
	# The difference between this program and the file 'lowercase-count-from-user-char-input-with-repeat-if-wished-enhanced.s' is that '.ascii' directives were replaced by '.string'.
	.globl main

	.section .data

ask_user_input:
	.string "Please provide a string of maximum length 49 chars - without space/tab.\n-> "

scan_format_string:
	# The maximum size will be 49 chars, that the final string will measure maximum 50 chars - 'null char' included
	.string "%49s"
	
result_message:
	.string "The total number of lowercase letter within the string provided is : %d \n"

message_ask_whether_to_continue:
	.string "Would you like to scan another string ? \nPress 'Y' to continue or anything else to end this program. \n-> "
	
scan_format_continue:
	.string "%c"
	
message_confirmation_exit:
	.string "You choosed to end this program.\n"
	
	.section .text

	# The string is 50 bytes long - but the space was rounded to 8 bytes up to 56 in order to facilitate further alignment to 16 bytes.
	.equ LOCAL_OFFSET_STRING, -56
	.equ LOCAL_OFFSET_COUNTER, -64
	.equ LOCAL_OFFSET_CONTINUE, -72

clean_stdin_buffer:
	# This function scans each char of the 'stdin' buffer until it finds a newline or EOF.
	# Scan current char
	movq stdin, %rdi # fgetc : (from its 'man' page) reads the next character from stream and returns it as an unsigned char cast to an int, or EOF on end of file or error.
	call fgetc
	# Compare it to a few values to know whether continue scanning
	cmpq $10, %rax # Compare to newline = 10
	je buffer_cleaned	
	cmpq $-1, %rax # Compare to EOF = -1
	je buffer_cleaned
	# Scan next char
	jmp clean_stdin_buffer

buffer_cleaned:	
	ret
	
main:
	# Making space for variables :
	# - one of them containing 50 chars (rounded up to 56 bytes)
	# - the counter of lowercase letters
	# - the continue 'flag' provided by the user
	enter $80, $0

	# Ask user input
	movq stdout, %rdi
	leaq ask_user_input, %rsi
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf
	
	# Scan user input
	movq stdin, %rdi
	leaq scan_format_string, %rsi
	leaq LOCAL_OFFSET_STRING(%rbp), %rdx 
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fscanf

	# Empty stdin buffer
	call clean_stdin_buffer
	
	# Get address of first char and keep it within a register
	leaq LOCAL_OFFSET_STRING(%rbp), %rbx
	
	# Set counter of lowercase letter.
	movq $0, LOCAL_OFFSET_COUNTER(%rbp)
	
main_loop:
	# Load the char value into another register to check its value when debugging.
	movb (%rbx), %r8b
	
	# Check if current char is the null char '\0' and exit program if so.
	cmpb $0, %r8b
	je end
	
	cmpb $'a', %r8b
	jb get_next_char_address
	
	cmpb $'z', %r8b
	ja get_next_char_address
	
	# Else increase counter of lowercase letter.
	incq LOCAL_OFFSET_COUNTER(%rbp)

get_next_char_address:
	# Increase = + 1 = get next byte address.
	incq %rbx
	jmp main_loop

end:
	# Print result message
	movq stdout, %rdi
	leaq result_message, %rsi
	movq LOCAL_OFFSET_COUNTER(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Ask user input - whether to continue or not
	movq stdout, %rdi
	leaq message_ask_whether_to_continue, %rsi
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Set the flag to a default non-continue value
	# This is mandatory as soon as the program re-start.
	movq $0, LOCAL_OFFSET_CONTINUE(%rbp)
	
	# Scan user answer
	movq stdin, %rdi
	leaq scan_format_continue, %rsi
	leaq LOCAL_OFFSET_CONTINUE(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fscanf

	# Empty stdin buffer
	call clean_stdin_buffer
	
	# Get address of the char and keep it within a register
	leaq LOCAL_OFFSET_CONTINUE(%rbp), %rbx
	# Get first char value = byte
	movb (%rbx), %r8b
	# If the value provided by the user is the 'continue-flag', repeat the program from the beginning.
	cmpb $'Y', %r8b
	# Jump conditionaly depending on user input
	je restart
	jne definitive_exit

restart:
	# Re-set stack as in initial state
	leave
	# Re-start program
	jmp main
	
definitive_exit:	
	# Else print exit message
	movq stdout, %rdi
	leaq message_confirmation_exit, %rsi
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Set clean exit return code for 'main'
	xor %rax, %rax
	
	leave
	ret

