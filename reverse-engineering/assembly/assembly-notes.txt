================================================================
QUESTIONS
________________________________________________________________

GDB
- What are the meaning of the GDB eflags ? -> Add the flags to the 'EFLAGS' notes below.
- Is it possible and how to show registers values in a specific format (unsigned/signed/hex/binary/...) ?

MEMORY
- What is 'program counter (PC) - relative addressing mode' -> Complete the notes below.

CHARS
- How to works with non-ascii chars, that is to say :
      -> How to detect whether a char is 8, 16, 32 or 64 bits - or else) ?
      -> How to add such chars within the '.section .data' ?
      -> How to loop on them - for example - to measure a string length ?

NUMBERS
- How to define and process to computation with numbers with decimals. -> Complete the notes below.
- How to print (write to STDOUT) as number as it is ? Example, writting the chars '1' (49) and then '0' (48) to STDOUT to write the decimal number '10'.

STACK
- What are 'closures' (or 'nested functions') - see 'enter' instruction second parameter.
- System V ABI : read (part of) documentation at :
  	 https://gitlab.com/x86-psABIs/x86-64-ABI
	 and complete the notes below.

C TYPES
- How to pass an int array to an assembly function. For example when converting the 'get-minimum-from-array.s' to a function called by a 'C' program ?
- How to pass other 'C' types (int, double, float, specific pointers to such types, non-ascii chars, ...).


================================================================
MISCELLANEOUS
________________________________________________________________

# IMPORTANT REMARK :
# This section was added as so and should be merge with others if possible later.

# This is a comment that begins with '#'

# 'nop' instruction
# 'nop' (= no operation) does nothing and has no operand.
# It helps :
#    - to space the code
#    - for code alignment

# Prefixes
# Some instructions can use prefixes before it to perform the same operation several times based OR NOT on a condition.
#
# rep  		    repeat
# repe		    repeat while equal
# repne		    repeat while not equal


================================================================
USEFUL COMMANDS FOR COMMAND-LINE
________________________________________________________________

# Useful commands to assembly the code of the current program and run it :
# Detail :
# as -> assembly instructions.
# ld -> link object file(s) to produce binary executable file.
# rm -rf -> remove files created during partial compilation as well as the binary.
# echo $? -> Shows the exit status.
________________________________________________________________

WARNING : For full debugging capacity with 'gdb' the program has to be compiled with the option '-g' provided to 'gcc' (same for 'as' BUT NOT FOR 'ld' - which will use the debugging symbols of all object files used) in order to obtain the debugging symbols.
________________________________________________________________

# Normal - with removal of the binary at the end.
PROGRAM="NAME" ; as "$PROGRAM".s -o "$PROGRAM".o && ld "$PROGRAM".o -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ; rm -rf "$PROGRAM".o "$PROGRAM" ;

# Debug (the binary and object files stay after the compilation and execution.)
PROGRAM="NAME" ; rm -rf "$PROGRAM".o "$PROGRAM" ; as -g "$PROGRAM".s -o "$PROGRAM".o && ld "$PROGRAM".o -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ;
________________________________________________________________

# Assembly and link several file
as FILENAME.s -o OBJECT-FILE.o
# And then link it with other files with :
ld OBJECT-FILE-1.o OBJECT-FILE-2.o -o EXECUTABLE

# One command to link two files - the last one being the main program.
FILE1="FILE1" ; PROGRAM="PROGRAM" ; as "$FILE1".s -o "$FILE1".o && as "$PROGRAM".s -o "$PROGRAM".o && ld "$FILE1".o "$PROGRAM".o -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ; rm -rf "$FILE1".o "$PROGRAM".o "$PROGRAM" ;
  
# Debug (the binary and object files stay after the compilation and execution.)
FILE1="FILE1" ; PROGRAM="PROGRAM" ; rm -rf "$FILE1".o "$PROGRAM".o "$PROGRAM" ; as -g "$FILE1".s -o "$FILE1".o && as -g "$PROGRAM".s -o "$PROGRAM".o && ld "$FILE1".o "$PROGRAM".o -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ;
________________________________________________________________

# Same for three files - the last one being the main program
FILE1="FILE1" ; FILE2="FILE2" ; PROGRAM="PROGRAM" ; as "$FILE1".s -o "$FILE1".o && as "$FILE2".s -o "$FILE2".o && as "$PROGRAM".s -o "$PROGRAM".o && ld "$FILE1".o "$FILE2".o "$PROGRAM".o -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ; rm -rf "$FILE1".o "$FILE2".o "$PROGRAM" ;

# Debug (the binary and object files stay after the compilation and execution.)
FILE1="FILE1" ; FILE2="FILE2" ; PROGRAM="PROGRAM" ; rm -rf "$FILE1".o "$FILE2".o "$PROGRAM" ; as -g "$FILE1".s -o "$FILE1".o && as -g "$FILE2".s -o "$FILE2".o && as -g "$PROGRAM".s -o "$PROGRAM".o && ld "$FILE1".o "$FILE2".o "$PROGRAM".o -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ; 
________________________________________________________________

# Link a function definition file (in assembly) with a program written in 'C' calling it (all files are set to variable, but without their extensions) :
# gcc could be provided with additional arguments.
FUNCTION_DEFINITION_FILE="FUNCTION_DEFINITION_FILE" ; PROGRAM="PROGRAM" ; gcc "$PROGRAM".c "$FUNCTION_DEFINITION_FILE".s -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ; rm -rf "$PROGRAM" ;

# Debug
FUNCTION_DEFINITION_FILE="FUNCTION_DEFINITION_FILE" ; PROGRAM="PROGRAM" ; rm -rf "$PROGRAM" ; gcc -g "$PROGRAM".c "$FUNCTION_DEFINITION_FILE".s -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ; 
________________________________________________________________

# Link three function definition files (in assembly) with a program written in 'C' calling it (all files are set to variable, but without their extensions) :
# gcc could be provided with additional arguments.
FUNCTION_DEFINITION_FILE_1="factorial-function-definition" ; FUNCTION_DEFINITION_FILE_2="exponent-function-definition" ; FUNCTION_DEFINITION_FILE_3="even-or-odd-call-different-functions-function-definition" ; PROGRAM="even-or-odd-call-different-functions-function-definition" ; gcc "$PROGRAM".c "$FUNCTION_DEFINITION_FILE_1".s "$FUNCTION_DEFINITION_FILE_2".s "$FUNCTION_DEFINITION_FILE_3".s -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ; rm -rf "$PROGRAM" ;

# Debug
FUNCTION_DEFINITION_FILE_1="factorial-function-definition" ; FUNCTION_DEFINITION_FILE_2="exponent-function-definition" ; FUNCTION_DEFINITION_FILE_3="even-or-odd-call-different-functions-function-definition" ; PROGRAM="even-or-odd-call-different-functions-function-definition" ; rm -rf "$PROGRAM" ; gcc -g "$PROGRAM".c "$FUNCTION_DEFINITION_FILE_1".s "$FUNCTION_DEFINITION_FILE_2".s "$FUNCTION_DEFINITION_FILE_3".s -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ;
________________________________________________________________

# Link the program with C 'standard library' ('-lc' = C standard library) functions - in a static way.
# For other library, replace '-lc' by '-l*****' with '****' being the name of the library used (of diminutive of the later).
# WARNING : in case that the static library is not found, check whether it is installed and if it is, add its directory path to with the option '-L DIRECTORY-PATH' (or --library-path=DIRECTORY-PATH)
PROGRAM="NAME" ; as "$PROGRAM".s -o "$PROGRAM".o && ld "$PROGRAM".o -static -lc -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ; rm -rf "$PROGRAM".o "$PROGRAM" ;x

# Debug
# WARNING : in case that the static library is not found, check whether it is installed and if it is, add its directory path to with the option '-L DIRECTORY-PATH' (or --library-path=DIRECTORY-PATH)
PROGRAM="NAME" ; rm -rf "$PROGRAM".o "$PROGRAM" ; as -g "$PROGRAM".s -o "$PROGRAM".o && ld "$PROGRAM".o -static -lc -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ;
________________________________________________________________

# Link a program having a 'main' entry point (instead of '_start') to the 'C runtime library' '_start' entry point
# IMPORTANT : The '-static' option asks the compiler to physically add code from static library and this adds about 500 kilobytes to the final code size.
PROGRAM="PROGRAM" ; gcc "$PROGRAM".s -static -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ; rm -rf "$PROGRAM" ;

# Debug
# IMPORTANT : The '-static' option asks the compiler to physically add code from static library and this adds about 500 kilobytes to the final code size.
PROGRAM="PROGRAM" ; rm -rf "$PROGRAM" ; gcc -g "$PROGRAM".s -static -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ;
________________________________________________________________

# Link a program having a 'main' entry point (instead of '_start') to the 'C runtime library' '_start' entry point - also link with a function definition file.
FUNCTION_FILE="FUNCTION_FILE" ; PROGRAM="PROGRAM" ; gcc "$PROGRAM".s "$FUNCTION_FILE".s -static -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ; rm -rf "$PROGRAM" ;

# Debug
FUNCTION_FILE="FUNCTION_FILE" ; PROGRAM="PROGRAM" ; rm -rf "$PROGRAM" ; gcc -g "$PROGRAM".s "$FUNCTION_FILE".s -static -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ;
________________________________________________________________



================================================================
BASIC CODE EXAMPLE
________________________________________________________________
	
# Anything starting with a dot is an instruction to the assembler.
# '.globl' tell the assembler that the symbol '_start' should not be discarded after the assembly process is over as it is the case by default.
.globl _start  # _start is a special symbol used as 'entry point' to the program.

# Another command to the assembler.
.section .text

# DEFINING THE VALUE OF THE _START SYMBOL
#
_start: 

    # PREPARATION OF THE SYSTEM CALL NUMBER FOR FURTHER CALL LATER.
    #
    # movq = move quadword -> quadword = 8 bytes (64 bits)	
    # Here, move the value 60 into the register named '%rax' -> the 64-bit-register.
    # $60 means that we treat 60 as a value not an address.
    # The number 60 is the system call number of the command to run.
    # the number 60 is the 'exit' system call.
    #
    movq $60, %rax # -> Moving a syscall number (here=60) to %rax does not make the call. It has to be lauched by 'syscall' command.
	
    # SET VALUE USED WITHIN SYSTEM CALL.
    #
    # Set the exit code to a number 0-255.
    # movq 1000, %rax -> This provokes 'Segmentation fault' due to non compliant access to memory. 
    # In the system call definition of 'exit', '%rdi' holds the exit status of the program. It is a kind of return value.
    # By default = 0 , if the below instruction was not existing.
    #
    movq $33, %rdi # Set exit code. Could be $0, ... $255.

    # Re-set good exit code.
    #
    movq $0, %rdi 

    # If there is a typo in an instrcuction, this message appears :
    # Error: no such instruction: `mo $0,%rdi'
    # As if uncomment the below line.
    # mo $0, %rdi # 'mo' instruction is not defined, what generate an error.
	
    # PEFORM SYSTEM CALL
    # This gives Linux Kernel the order of syscall.
    # For the syscall, the order of the register configuration ('%rax' before '%rdi' or the reverse) does not matter.
    # We could have written the movq to the '%rdi' register (destination) before the 'movq' to the '%rax' register.
    #
    syscall
    # If the syscall is not done, A 'Segmentation fault' error is generated.	


================================================================
REGISTERS
________________________________________________________________

%rax = the accumulator, because usually used for mathematic instructions.

     -> Historically, '%ax' was helding 16 bits
     %ax = accumulator
          %ah = most significant 8 bits of %ax
     	  %al = least significant

      -> Then when it was extended to 32 bits as '%eax'
      %eax = extended accumulator

      -> Then when it was extended to 64 bits as '%rax'
________________________________________________________________

Those registers can still be used :

%rax = 64 bits = the whole
%eax = 32 bits = the least significant 32 bits of %rax
%ax  = 16 bits = the least significant 16 bits of %rax (and of %eax)
%ah =   8 bits = the most significant 8 bits of %ax
%al =   8 bits = the least significant 8 bits of %ax (and of %ax, %eax, and %rax)

# Schema of bit arrangment depending on registers :

1111111111111111111111111111111111111111111111111111111111111111 = %rax = 64 bits

--------------------------------11111111111111111111111111111111 = %eax = 32 bits

------------------------------------------------1111111111111111 = %ax  = 16 bits

------------------------------------------------11111111-------- = %ah  =  8 bits

--------------------------------------------------------11111111 = %al  =  8 bits
________________________________________________________________

# x86_64 has 16 general purpose registers
# 	 8 from the 32-bit architecture
# Those 8 are divided into two classes :

# 4 Computational registers :
#
# - %rax, %rbx, %rcx and %rdx.
# Then can be used as general purpose register, meaning for computation as well as for their specific purpose (see below).
#
# All of those above registers can be divided into less bit containing register as done with '%rax' above.
#
# For example, '%rcx' can become :
  %rcx = 64 bits
  %ecx = 32 bits
  %cx  = 16 bits
  %ch  =  8 most significant bits
  %cl  =  8 least significant bits
#
# But those can also have specific purposes.
#
# Specific purposes :
  %rax = the accumulator, general-purpose register for computation.
  %rbx = the base register, often used for indexed addressing.
  %rcx = counter register, counter during repetitive code as loops.
  %rdx = data register,
       has some special meaning in :
       - certain arithmetic operations (multplication and division)
       - input/ouput coordination
       - coordination with '%rax' as with the 'divq' instruction where is held the rest of division.

# 4 Memory address registers
#
# - %rsi, %rdi, %rbp and %rsp.
#
# '%rsi' and '%rdi' can be used for computation as well as specific usage.
# But '%rbp' and '%rsp' has to be left for ONLY specific usage (to be pointers).
#
# Specific usage :
  %rsi = source index register - has special when working with longer spans of memory.
  %rdi = destination index register - often used in conjunction with '%rsi' for working with longer spans of memory.
  %rbp = base pointer
  %rsp = stack pointer -> points to the end of the stack memory location.
#
# For those register, there are a 16 bits and 32 bits version but not 8 bits (1 byte) available.
# For example :
  %rdi = 64 bits	
  %edi = 32 bits
  %di  = 16 bits
# But there are neither '%dh' nor '%dl' available.
#

# x86_64 has 8 more general purpose registers :
#
# It start at index 8 (the 9th register) to index 15 (the 16th register)
  %r8
  ...
  %r15
#
# Those registers have also 32, 16 and 8 bits version.
#
# Example with '%r11'
  %r11  = 64 bits (all)
  %r11d = 32 bits (least significant) -> 'd' as in 'double-word' (or long)
  %r11l = 16 bits (least significant) -> 'w' as in 'word'
  %r11b = 8 bits (least significant) -> 'b' as in 'byte'

# Special-purpose registers
  %rip = instruction pointer that points to the next memory location the CPU is going to process an instruction from
  %eflags = contains flags about result of precedent operation


================================================================
SIZES
________________________________________________________________

# In 'addq', 'movq'
# The 'q' refers to the size 'quadword'
# The standard size of a value in an architecture = 'word'
#
# Available sizes :
q = quadwords			= 64 bits
l = double-words (longs) 	= 32 bits
w = words 	 		= 16 bits
b = individual bytes 		= 8 bits

# Existing instructions with 'mov'
#	movb =  8 bit-chuncks (1 byte)
# 	movw = 16 bit-chuncks (2 bytes)
#	movl = 32 bit-chuncks (4 bytes)
# 	movq = 64 bit-chuncks (8 bytes)
#
# movq has two operands, kind of 'movq(source, destination)'
# The source can be :
# 	  - a register
#	  - a memory address
#	  - value (as here '60')
# Here, the destination is a register '%rax' ('%Rax' for 'Register')

# Example of customization :
# Moving a single byte (of value 5) into the %ah register
movb $5, %ah

# Deduce the size from the register(s) used
# The assembler can deduce what is the size of the instruction from the registers used.
# Therefore :
  movq $0, %rax
# Can be written as :
  mov $0, %rax
# The 'movq' can be written as 'mov' because the assembler can deduce the size 'quadword' from the register used as destination operand (%rax).
# WARNING :
# 	 - (...) But for code readability and easy comprehension, it is better to precise the size as much as possible.


================================================================
CONDITIONAL INSTRUCTIONS, COMPARISON BRANCHING AND LOOPING
________________________________________________________________

# Basic jump with 'jmp' to a specific instruction. 'jmp' is a kind of 'goto'.
  jmp NAME-OF-MEMORY-PLACE = jump to the instruction called 'NAME-OF-MEMORY-PLACE'

# There are 4 kind of jumps : short, near, far and indirect.
# 	- short jump :
#	  	Jump within 127 bytes of the current instruction (+/-127 bytes). It uses less space for the 'jump' instruction and is encoded in 'only' 2 bytes.
# 	- near jump :
#	        Jump somewhere within the current address space. Encoded relatively to the instruction pointer, using 32 bits
#		The jump is within maximum 2G compared to the current address of the instruction pointer.
#		This is the typical 'jmp'.
#
#	IMPORTANT REMARK : the assembler will decide whether to encode the jump a short/near automatically.
#
# 	- far jump :
#	        It is not used anymore.
#		Before :
		       Memory on x86 processors was grouped into 'segments' with each one having its own set of addresses.
		       Far jumps were used to access memory locations that were in different segments.
#		Now    :
		       Linux uses a 'flat memory model' in which every address for a process is in the same segment and each memory location the process has access to has a unique address for that process.
		       So far jumps are neither needed nor used anymore.
# 	- indirect jump :
#	  	Jump to an address that is not known until runtime.
#		That address is held within a memory location or a register.
#		'indirect jump' is coded as usual jump but there location to jump to has an asterisk '*' before it.
#		Example :
			.section .data
			#			
			target_pointer:
				.quad 0
			#
			.section .text
			#
			my_code:
				# Move the address of 'my_target' location into the memory location (size 'quad') of 'target_pointer'.
n				movq $my_target, target_pointer
				# Indirect jump that jump to the address held within 'target_pointer' memory location.
				jmp *target_pointer
				# The code below will be skipped by the jump
				# ...
			my_target:
				# The jump will arrive here
				# ...
#
# The above theory will apply to the 'call' instruction - except that there are no 'short' calls.

# Jumps based on result of precedent arithmetic operation and corresponding FLAGS
# See also the 'registers' section.
  jz MEMORY-PLACE = jump if zero flag is set (=1) (last arithmetic operation resulted in '0'
  jnz MEMORY-PLACE = jump if zero flag is NOT set (=0)
  jc MEMORY-PLACE = jump if carry flag is set (=1)
  jnc MEMORY-PLACE = jump if carry flag is NOT set (=0)

# Jump depending on comparison
#
# COMPARISONS
# Compare two numbers to check if there is one that is greater, lower or if they are equal.
  cmpb = for single byte
  cmpw = for word
  cmpl = for double-word
  cmpq = for quadword
#
# Example
cmpq ARG1, ARG2
#
# The jump is comparing SECOND argument to FIRST (it does not seems to be natural).
    je = jump if equal
    jne = jump if not equal
# Jumps to be used to compare UNSIGNED numbers :
    ja = jump if ARG2 is above ARG1
    jae = jump if above ARG2 or equal ARG1
    jb = jump if ARG2 below ARG1
    jbe = jump if ARG2 below or equal ARG1

# Others conditional instructions
#
# Conditions code : 'e', 'ne', 'a', 'ae', 'b', 'be' -> refer to above with 'je' (...). Only to compare 'UNSIGNED' numbers.
#
# There are other condition codes (used only to compare SIGNED numbers) as :
  'g' : greather than
  'ge' : greather or equal
  'l' : lower than
  'le' : lower or equal
#
# CMOV move only if the conditions is respected.
# syntax : cmov(CONDITIONS-CODE)(TYPE-OF-OPERATION) SOURCE-REGISTER-OR-MEMORY-LOCATION, DEST-ONLY-REGISTER-ACCEPTED
# The cmov (conditional move) instructions in x86_64 assembly have specific requirements for their operands.
#
# WARNING : 'cmov' instruction does not support immediate value (as numbers) in its arguments.
#
# The destination operand must be a register, and the source operand must be either a register or a memory location.
# As a consequence, immediate values (like $255 or $0) are not allowed as source operands for cmov instructions.
#
# Example
  cmovgeq %rax, %rbx
# Decomposition :
# 'c' - 'mov' - 'ge' - 'q'
# depending on precedent comparison 'c'
# will move 'mov'
# if precedent comparison resulted is ARG2 greater or equal ('ge') than ARG1.
# and operation type is 'quadword' = 'q'.
#
# List of (most of) all 'cmov' conditions :
#      - cmova / cmovnbe: Move if above (CF=0 and ZF=0)
#      - cmovae / cmovnb: Move if above or equal (CF=0)
#      - cmovb / cmovc: Move if below (CF=1)
#      - cmovbe / cmovna: Move if below or equal (CF=1 or ZF=1)
#      - cmove / cmovz: Move if equal (ZF=1)
#      - cmovg / cmovnle: Move if greater (ZF=0 and SF=OF)
#      - cmovge / cmovnl: Move if greater or equal (SF=OF)
#      - cmovl / cmovnge: Move if less (SF≠OF)
#      - cmovle / cmovng: Move if less or equal (ZF=1 or SF≠OF)
#      - cmovne / cmovnz: Move if not equal (ZF=0)
#      - cmovno: Move if not overflow (OF=0)
#      - cmovnp / cmovpo: Move if not parity (PF=0)
#      - cmovns: Move if not sign (SF=0)
#      - cmovo: Move if overflow (OF=1)
#      - cmovp / cmovpe: Move if parity (PF=1)
#      - cmovs: Move if sign (SF=1)


# 'loopq' will decrement (-1) '%rcx' and jump to the specified label if the result of decrement is not 0.
# Basic usage :
loopq LABEL-TO-JUMP-IF-RCX-IF-NOT-ZERO
# Variants
  loopeq LABEL-TO-JUMP-IF-EQUAL -> jumps if zero flag is set to '1' (see '%eflags').
  loopneq LABEL-TO-JUMP-IF-NOT-EQUAL -> if zero flag is not set to '1' (see '%eflags').


================================================================
MEMORY
________________________________________________________________

# WARNING :
# While memory references can be used as the source or the destination of many instructions, they cannot be both.
# One of those (source or destination) has to be a register or an immediate-mode value. 

# Add a memory section for data :
  .section .data

# Set values by precising size in memory (below : '.byte') and value ('4).
first_value:
	.byte 1
second_value:
	.word 3
third_value:
	.long 4
final_result:
	.quad 0
#
# Load values by calling the memory address
	movb first_value, %bl # '%rbx' 
	movw second_value, %cx # '%rcx'
	movl third_value, %edx # '%rdx'
#
# Store value in memory
  	movl %ecx, final_result

# More completed example of memory access
# 0. General
.globl _start

# 1. Set memory data
.section .data
NAME-OF-MEMORY-PLACE:
	.quad VALUE1, VALUE2, VALUE3
	# The type of the memory content can be .quad, .double, .word, byte.

# 2. Access memory data
.section .text
_start:
	movq $NAME-OF-MEMORY-PLACE, %rbx
	# The '$' means load immediate value, so here the address and not the content of the memory place.

	# Get the address value content with '(...)'
	movq (%rbx), NEW-REGISTER-FOR-VALUE1
	# Move the address of 8 bytes (for a .quad, it would be different for other type
	addq $8, %rbx

	# Load the value of the next memory space.
	movq (%rbx), NEW-REGISTER-FOR-VALUE2

# IMPORTANT remark about MOV
# for the 'mov(b/w/l/q)' instruction, only one, but not both operands of any instruction can be a memory location.
# So in order to use the addresses, they have to be loaded into registers.
#
# Example :
# As movq only support one address maximum in its arguments,
# movq ARG1, ARG2 => Either ARG1 or ARG2 can be a memory location but not both.
# So we can not manipulate data without at least one register.
# Writing 'movq ADDRESS_REF_1, ADDRESS_REF_2' is wrong.
# Example where '(first|second)_value' are memory location of kind 'first_value: \n\t.quad NUMBER'.
	movq first_value, %rdi
	addq second_value, %rdi

	# Exit system call
	movq $60, %rax
	syscall

# Array
simple_array:
	.quad 1, 2, 3
#
# Accessing the array by getting address of first element
# '$' refer to immediate value, which is the address to which point the pointer 'simple_array'
# '%rdi' is a register to hold the address
     movq $simple_array, %rdi
#
# Get the first element with '(ADDRESS)'
     movq (%rdi), %rax
#
# Move the pointer to next array element by adding X bytes to the pointer.
# IMP : The number of byte has to correspond to the type of the memory accessed (8 bytes here, for the '.quad' array 'simple_array').
addq $8, %rdi # would be 1 for '.byte', 2 for '.word', 4 for '.long' (=double-word)

# Different ways of accesing memory
  immediate mode with '$' in front of it
	  # example :
	  movq $60, %rax
	  # '60' is accessed as an immediate value that is, the value is contained into the instruction itself.
  register mode with '%' in front of it
  	   # example :
	   movq $60, %rax
	  # '%rax' is accessed as a register to find or store a value.
  direct memory mode when referring to a value by its address.
  	  # example :
	  simple_value:
		.quad 3
	  (...)
	        movq simple_value, %rax
	        # Here, 'simple_value' is the address of the .quad of value '3'. It redirects to this value.
  register indirect mode
  	   # example
	   simple_value:
		.quad 3
	  (...)
	        movq $simple_value, %rdi
		movq (%rdi), %rax
		# Here, '%rdi' contains the address of 'simple_value' (accessed with immediate mode '$') and we access to its value by register indirect mode.
		# 'register indirect mode' is used to access the content located at a memory address (here held in '%rdi').
#
# There are other modes existing.
#
# General addressing mode syntax
#
	VALUE(BASEREG, IDREG, MULTIPLIER)
# 'BASEREG' and 'IDREG' are registers -> default to '0'.
# 'MULTIPLIER' can be 1, 2, 4. 8 -> default to 1 byte. To adapt depending on the data accessed.
# The memory address is then calculated with the formula :
      address = VALUE + BASEREG + IDREG * MULTIPLIER
# 'BASEREG' is the start address.
# Then 'VALUE' is added to it.
# The second part of the equation (IDREG * MULTIPLIER) enables an offset of fixed sized per multiplier. Useful to access array indexes.
#
# Example of use :
# 	  general use :
	  # 'list_of_numbers' is a memory address defined within '.section .data', and containing '.quad' elements.
	  # Get current value but start with an offset of '-8' to ensure that only index 0 to X (array max index) and not 1 to X+1 are explored as %rcx start at the number of elements which is also index max+1.
	movq list_of_numbers-8(, %rcx, 8), %rax
#
# List of modes :

# 	  direct mode :
	  	 With 'VALUE' being the value to access.
		 Others values of BASEREG, IDREG and MULTPLIER set the default.

#	  register indirect mode :
	  	 With 'BASEREG' being the register to access.
		 Others values of VALUE, IDREG and MULTPLIER set the default.
		 
#	  indexed mode :
	  	  VALUE is the array.
		  BASEREG set to default = 0.
		  IDREG is the current index.
		  MULTPLIER is the size of memory accessed.

#	  base pointer mode (also called displacement mode) :
	       BASEREG is the base pointer
	       VALUE is an positive/negative offset from the pointer

#	   base pointer indexed mode :
	       ALL the 4 values are defined.
	       BASEREG is a register that points to a location.
	       VALUE is the offset.
	       IDREG and MULTIPLIER are combined to it to get the index address to access.

#	   program counter (PC) - relative addressing mode :
	  	  DEBUG TO FILL LATER

# Instruction 'lea(b|w|l|q)' = load effective address
# loads the address of first to second argument.
  leaq number_of_numb̂ers, %rbx
# is equivalent to :
  movq $number_of_number, %rbx
# NOTICE the '$' which mades the instruction not so easy to understand (when read by another programmer) as 'leaq'


# Memory blocks and string operations
#
# REMINDER :
# %rsi = source index register
# %rdi = destination index register
# The reason for such naming is that several instructions (as the 'movs(b|w|l|q)' instruction - and not 'mov(b|w|l|q)' : there is an additionnal 's' before the operation size) working with memory blocks use those two registers as 'source address' and 'destination address'.
#
# 'movs(b|w|l|q)' instruction - usually used as 'movsq'
# There are NO operands with such instruction.
# 'movs(b|w|l|q)' looks for an address into '%rsi' - copy the data located at such address to the address specified by '%rdi'
# After this operation is done, both address '%rsi' and '%rdi' are :
# 	- incremented by the size of operation (8 bytes if quadword) - if the direction flag is unset '0'.
#	- decremented by the size of operation (8 bytes if quadword) - if the direction flag is set '1'.
# This instruction can be prefixed by the 'rep' (= repeat) modifier in order to repeat the instruction multiple times counting down with the '%rcx' register (as in loopq).
#
#
# 'cmps(b|w|l|q)' instruction
# 'cmps' compares the content of two blocks of memory - the addresses of those two blocks have to be set within '%rsi' and '%rdi'.
# It will :
# 	1. Compares both contents.
#	2. Set the flags.
#	3. (In|de)crement both '%rsi' and '%rdi' depending on the direction flag 'DF'.
# This instruction can be prefixed by the 'repe' (=repeat while equal) modifier in order to repeat the instruction a number of '%rcx' times - AS LONG AS both contents are equal - counting down with the '%rcx' register (as in loopq).
# It is then possible to perform different behaviour depending on the result of the comparison with 'je' (last AND so ALL comparison were equal) and 'jne' (at least one comparison failed the equality).
# To know at which index (if comparing arrays) the failure happened by deducing 'TOTAL_SIZE - 1 - %rcx' (only in case of failure checked with 'jne') ('-1' is because first index start at '0' so last index is 'TOTAL_SIZE -1'.
# REMINDER :
# 	   The 'cmps' will compare SOURCE ('%rsi') to DEST ('%rdi') as if it was written :
#	       'cmp (%rdi), (%rsi)' = cmp ARG2, ARG1
# 	   So to check if the source ('%rsi' = ARG1) was below (unsigned) | lower (signed) than the destination ('%rdi' = ARG2), a 'jb' or 'jl' will be needed.
#
#
# scas(b|w|l|q) instruction
# 'scas' scans (=search) a specific value within a memory block.
# It uses :
#    - '%rdi' as the memory block current address to be checked
#    - '%rax' (or other size) as the value to be searched.
# It will :
#    1. Load the content located into the address held by '%rdi'.
#    2. Compare it with the content of '%rax'.
#    3. Based on the direction flag 'DF', it will (in|de)crement the address held within '%rdi'.
# It can be combined with the prefixes 'repne' (repeat while not equal) in order to repeat a number of '%rcx' times the operation as long as the value contained within '%rax' (or other size equivalent register) was not found.
# And then check whether the value was found by jumping as 'scas' uses a 'cmp' under the neath.
     je   MEMORY_LOCATION_IF_VALUE_FOUND
     jne  MEMORY_LOCATION_IF_VALUE_NOT_FOUND
# When the insturction terminates, it is possible to use either '%rcx' or '%rdi' to find the index (with %rcx or %rdi) AND location (with %rdi) of the value found.
#      - To know at which index (if scanning arrays) the value was found with '%rcx', deduce 'TOTAL_SIZE - 1 - %rcx' (only in case of value found checked with 'je') ('-1' is because first index start at '0' so last index is 'TOTAL_SIZE -1'.
#      - To know at which index the value was found with '%rdi' :
       	    1. Load first array index location 
	       leaq MEMORY_LOCATION_ARRAY, %rsi
	    2. Deduce the current one (the one of the next element held within the register '%rdi') from it
	       subq %rsi, %rdi
	    3. For further division, set '%rdx' to '0' and load '%rdi' into '%rax'
	       xor %rdx, %rdx
	       movq %rdi, %rax
	    4. Divide by the size of one element (in byte)
	       .equ SIZE_OF_ONE_ELEMENT, 8 # 8 for a quadword, 1 for a byte, ...
	       movq $SIZE_OF_ONE_ELEMENT, %rbx
	       divq %rbx
	    5. Reduce it by one as first index is '0' and last index is 'array_size - 1'
	       decq %rax
#      - To know the location of the value found, reduce '%rdi' by the size of one element (in byte(s)).
# It is possible to measure the length of a string with 'scas' instruction, scanning the string char by char until it find the '$0' (='\0') char.
# And then by computing the length from the final address - initial address -1 (-1 because the address is increased at each repetition of 'repne').
# This information can then be used to copy (with 'movs' instruction) or compare (with cmps' instruction) the string.
        my_string:
		.ascii "123456789\0" # Length = 9 chars
		
		.section .text
	_start:
		# Set %rcx to a huge value signed '-1' = unsigned maximum value (only 1's in binary : 1...1)
	  	# %rcx is needed for the 'scas' instruction that will be repeated with the 'repne' while %rcx is above '0'.
	  	movq $-1, %rcx

		# Load address of first char
		leaq my_string, %rdi
		# Set the search value to null char with value 0 = '\0'
		movq $0, %rax
	
		# Scan until search value is not found.
		repne scasb

		# Substract current address (of null char found) with address of first char
		subq $my_string, %rdi
		# Deduce 1 as 'scasb' always increase (+1) the address at the end of each repetition.
		decq %rdi
		# The %rdi value can then be returned as program exit code.
		#...
		

================================================================
DATA RECORDS (STRUCTURES)
________________________________________________________________

# Constants with '.equ'
  .equ CONSTANT_NAME, 5
# Refer to it after this by its name
# It is possible to perform simple computation (add, substract, multiply or divise) on a constant to produce another value.
 .equ ANOTHER_CONSTANT, CONSTANT_NAME + 8
# It helps to use dynamic value based on predefined (accessible or not) values. 
# IMPORTANT : They can be declared through any of the sections '.data' or '.text'.

# Global variables accessible from other file with '.globl'
  .globl GLOBAL_VARIABLE
# Assemble the code to get an object file '.o'
# And then link it with other files to produce a binary with 'ld'
# During the resolution of the linking, if GLOBAL_VARIABLE is called from another file, it will use the value shared by '.globl'.
# To access such value from other files, use '$' or 'leaq' to get their immediate mode value.
  movq $GLOBAL_VARIABLE, %rax
# OR
  leaq GLOBAL_VARIABLE, %rax
# WARNING : however, '.equ' symbols are not required to be 'global variables' as long as they are ONLY use through the same file that they are defined.

# Structures
# To produce structures, needs address to refer to it with an offset depending on what is targetted.
# Example :
  .equ WEIGHT_OFFSET, 0
  .equ HEIGHT_OFFSET, 8
# In this example The offset for the second element of the structure is 8 (quadword).
# But it could be anything multiple of 1, 2, 4, 8 depending on the size of the previous element.
# Then to refer to second element, we could use :
  movq HEIGHT_OFFSET(%rbx), %rax
# HEIGHT_OFFSET is the VALUE, '%rbx' is the BASEREG -> See memory section.
# This will move the content of what is 8 bytes after the '%rbx' adress within '%rax'.

# Difference between two addresses
# It can be obtained by substracting the address of two label (one at the beginning and one at the end of the data).
 .equ WEIGHT_OFFSET, 0
 .equ HEIGHT_OFFSET, 8
 .equ PERSON_RECORD_SIZE 16
people:
	# Array of persons.
	.quad 80, 170
	.quad 90, 200
	.quad 100, 160
end_people:
address_difference:
	.quad end_people - people
# The result is expressed in byte unit so if (as above) there is 3 quadwords with each one sizing 16 bytes, the difference in address will be '3 * 16 = 48 bytes.
#
# Measure number of data elements
# So on the same idea, we can compute how many datas (how many persons) there are by dividing this difference by the size of one record.
# Here, one person record only contains two quadword (WEIGHT_OFFSET and HEIGHT_OFFSET)
number_of_people:
	.quad (end_people - people) / PERSON_RECORD_SIZE

# Characters
#
# 'ASCII' characters are code into 1 bytes (0-255).
# 'ASCII' means : American Standard Code for Information Interchange
#
# Due to limitation, the 'Unicode' was developped. It is a standardized system for representing characters.
#
# 'ASCII' is compatible with 'UTF-8' which is the most common form of 'Unicode'.
# If only using basic English characters and punctuation, 'ASCII' and 'UTF-8' are identical.
#
# To process characters, one way is to work with 'byte' part of registers :
# %rax -> ah or al
# %rbx -> bh or bl
# ...
# And use corresponding instruction ending with 'b' as in 'movb'.
# OR
# To use the '.ascii' directive :
  .section .data
 my_string:
	.ascii "This is a string of characters.\0"
# The string has to be within double quotes and USUALLY end with null char '\0' = 0 in ASCII.
# The '\0' char at the end is usefull when looping of the string to know where it ends.
# Else, it has to be accessed as an array and therefore, we have to know the array length in order to know when to stop.
# The address of 'my_string' refers to the address of its first char.
# As in other languages, '\' means that it is a special char.
# To write '\', it is needed to be '\\'.
#
# Representing a string in byte :
  my_string:
	.byte 84,  104, 105, 115,  32, 105, 115,  32,  97, 32, 115 # 'T' 'h' 'i' 's' ' ' 'i' 's' ' ' 'a' ' ' 's'
	.byte 116, 114, 105, 110, 103,  32, 111, 102,  32, 99      # 't' 'r' 'i' 'n' 'g' ' ' 'o' 'f' ' ' 'c'
	.byte 104,  97, 114,  97,  99, 116, 101, 114, 115, 46      # 'h' 'a' 'r' 'a' 'c' 't' 'e' 'r' 's' 'UNKNOWN'
# Each numbers equivault to one char with :
#      - null char (0)
#      - space (32)
#      - digit starting at 48 ('0') and ending at 57 ('9')
#      - capital letters starting at 65 ('A') and ending at 90 ('Z')
#      - lowercase letters starting at 97 ('a') and ending at 122 ('z')
#
# It is also possible to refer to the char by using '$' to use the immediate mode value of it.
# Example :
  movb $'a', %al
# WARNING : without the '$' (immediate mode), 'a' will refer to the memory location at address 97.

# Endianness
# Endianness is the way of storing data bytes in memory.
# Example with a quadword of bits (64 bits) = 8 bytes
# In this example, each byte contains one more '1' than the precedent one.
  10000000 11000000 11100000 11110000 11111000 11111100 11111110 11111111 
# There are two ways of store such value in memory :
# 	little endian :
	       - Stored in reverse order : the least significant byte first (little end).
	       - That way, last byte (the eighth one) is placed first then the seventh, ... and the first byte (here : 10000000, the most significant one) is placed at the end.
#	big endian :
	       - Stored in natural order :  the most significant byte first (big end)
	       - That way, first byte (the first one) is placed first then the second, ... and the last byte (here : 11111111, the least significant one) is placed at the end.
	       - This is the predominating way in networking protocol, this is why 'big endian' is also know as 'network byte order'.
#
# The x86-64 instruction set architecture is 'little endian'.
#
# Accessing all individual byte of a quadword by rotation with 'ror' and 'rol'
# 	    respectively 'ror(b|w|l|q)' and 'rol(b|w|l|q)'
# In '%rax' register (or any other else), the two last byte are accessible with '%ah' and '%al' for the last one.
# To access the others, 'rol' and 'roh' instructions will 'r'otate the registers left (ro'l') and right (ro'r') respectively by the 'N' number of bit(s) (AND NOT BYTES !) provided.
# This number can be an immediate mode value, or a value held into a register.
  rorq $16, %rax
# This will rotate to the right the bits in the registers with a movement of 16 bits = 2 bytes.
# So each bit will be next located at the following position :
# IMPORTANT : in this example, the most significant bit is located on position 1 and the least significant on position 64.
#    new_position = previous_position + 16
     		  -> if new_position is under or equal to 64, it is the new position.
		  -> else, the new_position is new_position = previous_position + 16 - 64
#
# List of instruction helping with endianness and similar byte-orientated operations.
# To simplify, the last letter of the instruction depending on the size memory is not added '(b|w|l|q)'.
  xchg :
       Exchange the two value of its operands.
       That is to say, 'xchg(b|w|l|q) REG1, REG2' will place the value of REG1 into REG2 (as with 'mov') and place the value of REG2 into REG1.
  bswap :
  	This reverse the order of bytes in the destination.
  	'bswapw %ax' -> Will place '%ah' into '%al' and '%al' into '%ah'.
  ror :
      Rotate by X bit(s) the memory content in the right (->) direction.
  rol :
      Same as for 'ror' but in the left (<-) direction.
  shr :
      This shift a value right by the specified number of bits.
      This is similar to 'ror' but the bits on the right do not come back on the left. They are filled with '0's.
  shl :
      Similar to 'shr' but move to the left and the bits on the right are filled with '0's.

# Strings in data records
# There are several ways of including strings. Among them, two main :
# 	- By reserving a specific length and ending the string with the null char (so the maximum length should be 'SPECIFIC_LENGTH - 1' to include it).
	     	        # WARNING : with such solution, dynamic padding is required to fill the remaining space if the string is lower than the specific length-1 :
		        # Code example :
			#
			# Define offset each field of people array
			.equ NAME_OFFSET, 0 # 32 bits are reserved for the string representing the name.
			.equ WEIGTH_OFFSET, 32
			#[...]
			people:
			# Array of people
			# Name (string of max 31 char + 1 null char), weigth, shoe size, hair color (equivalence in number), height, age.
			# Those values corresponds to american weight, shoe size and heigth units.
			  	.ascii "Gilbert Keith Chester\0"
				.space NAME_OFFSET + 32 - (. - (people + 0 * PERSON_RECORD_SIZE))  # Pad to 32 bytes
				.quad 200, 10, 2, 74, 20
				.ascii "Jonathan Bartlett\0"
				.space NAME_OFFSET + 32 - (. - (people + 1 * PERSON_RECORD_SIZE))  
				.quad 280, 12, 2, 72, 44
			# Here, :
			# - '.space' will fill with '0' a number of times.
			# - NAME_OFFSET + 32 = the end of the string field
			# - '.' = the current position of the instruction
			# - The expression uses (people + n * PERSON_RECORD_SIZE) to determine the starting point of the current person's data. First person -> n = 0.
			# - It computes how many bytes have been written since the beginning of the current person data and disminish it from 32 to get a dynamic number of space to add.
			# - Then accessing it with : movb VALUE(BASEREG, INDREG, MULTIPLIER), %al = movb STRING_OFFSET(%rbx, %rcx, 1), %al
			# Here :
			# - STRING_OFFSET is the offset of the string within the structure.
			# - %rbx is the address of the current person structure
			# - %rcx held the index of the char to get.
			# - The multiplier was set to '1' (because it moves 1 byte at the time).
			# - But it can be a waste of memory because even if the string are much more little than the SPECIFIC_LENGTH choosed, the memory will be reserved anyway.
			# - And also, it impose a maximum length.
#			
# OR
#
#	- By using pointer to the strings (no waste of memory and no maximum length) :
	      	   	.section .data
			#
	      		gkc_name:	
	      			.ascii "Gilbert Keith Chester\0"
	      		# [ people_array ...]
	      		    	.quad gkc_name, 200, 10, 2, 74, 20 # One person record with 'gkc_name' being used in immediate mode to get the address (pointer).
			# WARNING : when within a '.quad' directive, there is no need to use a '$' to refer to an immediate mode to get the address - the name of the reference is enough.
			# [...]
			# - To access the string, it is needed to load the content of the pointer within a register with :
		      	   movq NAME_PTR_OFFSET(%rbx), %rdx
			# - And then access it with :
		      	    movb (%rdx, %rcx, 1), %al
			# - But this way is more complex to code, less efficient and less flexible than the fixed length memory reserved to strings.


================================================================
NUMBERS AND ARITHMETIC
________________________________________________________________

# Addition :
# This adds '%rax' to '%rdi' and store the result into '%rdi'
addq %rax, %rdi

# Substraction
subq %rax, %rdi
________________________________________________________________

# Incrementation (+=1)
# No source needed as the incrementation is +1
incq DESTINATION

# Decrementation (-=1)
# No source needed as the decrementation is -1
decq DESTINATION
________________________________________________________________

# WARNINGS FOR MULTIPLICATION AND DIVISION
#	- For multiplication and division, the destination is assumed to be '%rax', so only need to precise which is the source.
# 	- The source cannot be a number, it has to be a register or memory location.
#	- The source cannot be a reference to a .globl reference. It such value is needed, it has to be loaded into a register with 'movq $GLOBL_VAR, %r8' or 'leaq GLOBL_VAR, %r8' before to be used with 'mulq %r8'
#	- Beware of not using '%rdx' to held a specific value not linked to multiplication / division as this register may (will) be set during multiplication / division.

# Multiplication
# The final result will be held into '%rax'
# So no need for destination, only source
mulq SOURCE

# Division
# Similar to multiplication, final result will be held into '%rax'
# But the remainer is stored in the '%rdx' register which should be set to zero before the instruction occurs.
divq SOURCE
________________________________________________________________

# Number format
# The base has to be precised for binary, hexadecimal, octal but not for decimal number.
# To use a direct number as a value, it has to be called with immediate mode '$' -> movq $23, %rax 

# Decimal -> Write number as they are :
  $10 # This is the value '10' in decimal
# A trick to set the register '%rcx' (or any other) to the highest unsigned value is to use the signed negative value '-1' (1...1) :
  movq $-1, %rcx
  # This will set '%rcx' to only '1's (1...1). -> 'signed -1' = 'max unsigned value'

# Binary -> Write number with '0b'
  $0b10 # Refers to binary value of '10' = 2
# In memory, all bytes represent binary numbers from 0 up to 255.
# If the number is higher, there are chances that the function using the byte part of the register will only consider the 8 last (least significant) bits.

# Hexadecimal -> Write number with '0x'
  $0xA2 # Refers to hexadecimal number 162.
# Hexadecimal is base 16, with numbers ranged 0-16 : from 0 (=0) to 9 (=9) and letters from A (=10) to F (=15).
# The case does not matter : uppercase is the same as lowercase.
# In order to convert from hexadecimal to decimal, have to multiply the number from the right to the left by 16 power 'n+1' with 'n' being the index of the number (first index = 0 = number on the left).
# Example :
  Hexadecimal -> decimal
  20 = 2 * 16^1 + 0 * 16^0 = 2 * 16 + 0 * 1 = 32
  AC2 = A * 16^2 + C * 16^1 + 2 * 16^0 = 10 * 256 + 12 * 16 + 2 * 1 = 2560 + 192 + 2 = 2754
# Hexadecimal is 'friendly user' for managing memory because for each pair of 'hexadecimal' numbers/letters used, it represents one byte (8 bits).

# Octal -> Write number with '0'
# WARNING : with the GNU Assembler ('as'), starting a number with '0' switches its value to octal.
  $026 # Refers to 2 * 8^1 + 6 * 8^0 = 2 * 8 + 6 * 1 = 22 

# Signed intergers
# The 'two complement' mechanism is used for signed numbers.
# Two complement mechanism means :
#     Positive numbers counts up from 0.
#     Negative numbers counts back from 0.
# Example in binary
  0b00000000 = 0
  0b00000001 = 1 (0 + 1)
  0b00000010 = 2
  0b11111111 = -1 (0 - 1) -> if this value was considered as an unsigned decimal one, it would be equivalent to '255'.
  0b11111110 = -2
  0b11111101 = -3
# The first bit (called 'sign flag') shows if the value is positive (first bit = 0) or negative (first bit = 1).
# For a byte (8 bits), signed values goes from :
  positive = '0' to '127'
  negative = '-1' to '-128'
# There is always 1 more value in the negative range because the positive range contains '0'.
#
# Examples of binary equivalences of positive and negative numbers and how to compute them
	# POSITIVE VALUES
	movb $0b01111110, %al # %rax = A = 126
	# A = sign bit  + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 0 * 2^0
	# A = (+)         64      + 32      + 16      + 8       + 4       + 2       + 0
	# A = 126
	movb $0b00000001, %bl # %rbx = B = 1 
	# B = sign bit  + 0 * 2^6 + 0 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0
	# B = (+)         0       + 0       + 0       + 0       + 0       + 0       + 1
	# B = 1
	movb $0b00000010, %cl # %rcx = C = 2
	# C = sign bit  + 0 * 2^6 + 0 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0
	# C = (+)         0       + 0       + 0       + 0       + 0       + 2       + 0
	# C = 2

	# NEGATIVE VALUES
	movb $0b10000001, %dl # %rdx = D = -127
	# In get a negative number from a binary value, if the bit is set to '0', then the 'power 2' number has to be multiplied by '1', and then the total of the addition of all 'power 2' has to be increased by 1, and the final total multiplied by (-1).
	# D = sign bit  { ( + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 0 * 2^0 ) +1 } 
	# D = (-)       { (   64      + 32      + 16      + 8       + 4       + 2       + 0       ) +1 } 
	# D = -127
	movb $0b11111111, %r8b # %r8 = E = -1
	# E = sign bit  { ( + 0 * 2^6 + 0 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 0 * 2^0 ) +1 }
	# E = (-)       { (   0       + 0       + 0       + 0       + 0       + 0       + 0       ) +1 } 
	# E = -1
	movb $0b11111110, %r9b # %r9 = F = -2
	# F = sign bit  { ( + 0 * 2^6 + 0 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0 ) +1 } 
	# F = (-)       { (   0       + 0       + 0       + 0       + 0       + 0       + 1       ) +1 }
	# F = -2
#
#
# Overflow condition : when a value is 'wrap around' :
#  You add something to a positive number and go out of range -> the result is a negative number but it should be positive instead.
#  You substract something to a negative number and go out of range -> the result is a positive number but it should be negative instead.
# Example, adding 1 to 0b01111111 (127) will give 0b100000000 (-128) -> overflow !
#
# Complement arithmetic properties :
# - For addition and substraction, the CPU operations are the same, the only important thing to check is whether an overflow was produced or not.
# - To increase the size of a number (in bits / byte), it is only needed to extend the 'sign flag' (most significant bit) by adding the same number before the current one :
#      To get from '-1' in 8 bits (1 byte) = 0b11111111 to '-1' 64 bits (8 bytes), it is needed to fill the beginning of the number with the 'sign flag' which is '1'.
#      So it would be 64 - 8 = 56 bits of 1, and then the current number (8 bits) at the end -> 8 bits of 1.
#      1...(56 times 1)...1|11111111(8 times 1)
# - There is only one '0' value, written with as many bits '0' as needed.
#
# Switching from positive to negative is done by flipping all the bits and then adding one.
  initial number : 0b00000101 = 5
  flip all bits  : 0b11111010
  then add one   : 0b11111011 = -5
# This is done with the 'neg(b|w|l|q)' instruction.
  negq SOURCE-IS-SAME-AS-DESTINATION
# Example
 movq $5, %rax # -> move '5' to '%rax'
 negq %rax # -> change the bits within '%rax' to place the equivalent of '-5' in '%rax'.
# WARNING :
# 	  - the '%rax' registers contains the bits equivalent to '-5' only if the number is considered a signed number which has to be precised to the CPU while using other instructions.
#	  - The CPU has no idea of the kind of number signed/unsigned so the developper still has to keep this in mind when using the register.

# The %eflags register enable processing values as signed integers or decimal numbers.
# Flags :
# Reminder : the flag are set to '1' when activated.
  	CF = carry flag =     Result of the last arithmetic operation was a 'carry', that is the result was bigger and could not be held in the destination register.
      	ZF = zero flag =      Result of last ARITHMETIC operation was 0, set to '0' if it was different.
	OF = overflow flag =  Warns that if the intention was to use the number as a 'signed' one, there was an overflow so the sign is now wrong.
	SF = sign flag =      Tells that the most significant bit was set AFTER the instruction.
# Example on 1 byte operations :
# Adding 127 to 127.
  movb 0b01111111, %al # Putting '127' in the last 8 bits of '%rax' register.
  addb 0b01111111, %al # Adding 127 to itself and putting the result into the 8 last bits of '%rax'.
# The result will be 0b11111110. There would be an overflow ONLY if we were processing 'signed' numbers - with unsigned numbers, 127 + 127 would give 254 which is perfectly right.

# Jump after flags check
  jz MEMORY-PLACE =	jump if zero flag
  jnz MEMORY-PLACE = 	jump if no zero flag 
  jc MEMORY-PLACE = 	jump if carry flag 
  jnc MEMORY-PLACE = 	jump if no carry flag
  jo MEMORY-PLACE = 	jump if overflow
  jno MEMORY-PLACE =   	jump if no overflow
  js MEMORY-PLACE =	jump if signed flag set
  jns MEMORY-PLACE =   	jump if no signed flag
#
# Comparison with flags check
# The comparison is the same for signed/unsigned operation but not the jump.
  cmpq ARG2, ARG1
# Then
# Jump check for SIGNED number -> Those checks for the 'sign' and 'overflow' flags as well as 'carry' and 'zero' flags.
  jl MEMORY-PLACE =     jump if ARG1 is lower than ARG2.
  jle MEMORY-PLACE =	jump if ARG1 is lower or equal to ARG2.
  jg MEMORY-PLACE =	jump if ARG1 is greater than ARG2.
  jge MEMORY-PLACE =	jump if ARG1 is greater or equal to ARG2.
# Jump check for UNSIGNED number -> Those checks for the 'carry' and 'zero' flags.
  ja MEMORY-PLACE =	jump if ARG1 is above ARG2.
  jae MEMORY-PLACE =	jump if ARG1 is above or equal to ARG2.
  jb MEMORY-PLACE =	jump if ARG1 is below ARG2.
  jbe MEMORY-PLACE =	jump if ARG1 is below or equal to ARG2.
# Jump check for SIGNED AND UNSIGNED numbers :
  je MEMORY-PLACE =     jump if ARG1 is equal to ARG2.
  jne MEMORY-PLACE =     jump if ARG1 is not equal to ARG2.

# adc(b|w|l|q) = add with carry to consider number bigger than the usual 64 bits register - that is to say, composed of several 64 bits registers.

# Operation with numbers bigger than 64 bits
# To manage operation that can produce numbers greater than the size of a 64 bits registers, it is needed to manage X (X = number of) 64 bits registers.
# For example, to add two numbers of 320 bits (5 * 64 bits) , it is needed to separate them into 64 bits registers, and add them, that is to say :
#     1. Add - with the usual 'addq' - the least significant 64 bits register of the first number to the least significant 64 bits register of the second number.
#     2. Store the result into a 64 bits register - this will be the least significant 64 bits register of the result.
#     3. Add - with 'adcq' (add with consideration of the potential carry of precedent operation) all remaining registers (one by one, starting from the least to the most significant) and keep the results into registers - those are the result registers.
#     4. At the end, check for the overflow flag to see if the result was bigger than the size of 320 bits. 

# Addition and number size
#
# With an addition, the result number can be at the maximum one bit greater than the two number added (if they are the same size) :
       999 (3 bits)
   +   999 (3 bits)
___________________
      1998 (4 bits)
# And this is why we can manage it with a 'carry' flag that indicate whether or not a '1' should be added in front of the result.
# But for multiplication it is not the same...
#
# Multiplication and number size 
#
# With a multiplication, the size can double
        999 (3 bits)
 *	999 (3 bits)
 __________
       8991
      89910
 +   899100
 __________
     998001 (6 bits)
# Therefore, CPU store the result of a multiplication of one 64 bits to another into TWO registers.

# 'mulq' : Multplication -> '%rax' and '%rdx' registers
# - (...) Therefore, CPU store the result of a multiplication of one 64 bits to another into TWO registers.
# 	     %rax = the least significant part of the result IF multiplication provoke an overflow - ELSE - the register result 
#	     %rdx = the most significant part of the result ONLY IF overflow
#  - In documentation, this is written as '%rdx:%rax' - but it is not code syntax, ONLY for documentation !
# WARNINGS ABOUT MULTIPLICATION
# 'Carry' and 'overflow' flags will be set if a multiplication (un)signed result is bigger than a 64 bits register.
#
# 'divq' : Division -> '%rax' and '%rdx' registers
# 	 - The division is the opposite as the multiplication.
# 	 - The dividend (number divided) is held within '%rdx:%rax' -> See WARNING below !
# 	 - The divisor (number it is divided by) is specified as an operand to the instruction
# The result is then held into those two same registers :
#     %rax : quotient = main result
#     %rdx : remainder
#
# WARNINGS ABOUT DIVISION
#     - '%rdx' has to be set to '0' before the division as it is part of the 'dividend' -> If not set to '0', it would introduce garbage information within the dividend ('%rdx:%rax').
#     - if the starting number that will be divided is greater than 64 bits, the result could potentially also be greater than 64 bits.
#     	        -> If it is the case, 'div' instruction is considered illegal and 'termination' will happend.
#     - No division by '0' is possible.
#     	   	-> If it is the case, 'div' instruction is considered illegal and 'termination' will happend.

# imul(b|w|l|q) and idiv(b|w|l|q) = signed multiplication and division
# Those are signed equivalences to 'mulq' and 'divq' (the latter are unsigned operations).
# 'imul' and 'idiv' operates with two operands as with the 'addq SOURCE, DEST'
# 	 imulq SOURCE, DEST
# 	 idivq SOURCE, DEST
# WARNING : If the result is bigger than the DEST(INATION) size, only it will be truncated to only the least significant part of it - but the flags will be set.




# Numbers with decimals
#
# WILL BE TREATED LATER (SEE APPENDIX F).
#


================================================================
BITWISE OPERATIONS
________________________________________________________________

# Operations to check/set individual bits
#
# Those instructions are also called 'logic function' because they take one or two bits individually are perform some standard operation on them.xs
#
# Those instructions are useful to see :
# 	- If a signed value is positive/negative by checking the most significant bit (if set to '0' = positive / if set to '1' = negative)
# 	- If a value is odd : if the number is unsigned and the least significant bit is set ('1'), then the number is odd.
#	- Custom flags represented by on/off bits set ('1') or not ('0').
#
# All the below instructions - except the 'not' - set flags (among them, the most interesting is the 'zero' flag).
#
#
# 'and(b|w|l|q) SOURCE, DEST' instruction
# Compare two registers of same size and set the bits of the DEST(INATION) only if both bits (SOURCE and DEST) are set ('1').
# Example :
 	  movb $0b01100010, %al	# least significant byte of %rax
	  movb $0b11110100, %bl # least significant byte of %rbx 
	  andb %al, %bl	    	# Result will be kept within '%bl' (see below for detail).
# Detail :
  	 0 1 1 0 0 0 1 0 # %al
AND  	 1 1 1 1 0 1 0 0 # %bl
________________________
	 0 1 1 0 0 0 0 0 # %bl
#
# 'and' instruction is useful to filter a value through a 'bitmask' - to check whether or not specific bits are set within it. This will be showed within the result of the 'and' instruction'.
# A 'bitmask' is a value that is used to specify which bits are of interest.
# It is also know as a 'mask' because it will 'silent' (set to '0') all non-interesting bits.
# If you want to check the least significant bit, it is possible with an 'and' instruction and a bitmask of '1' :
     movb $0b10100101, %al # Garbage value to 'filter' with a bitmask.
     movb $0b00000001, %bl # Bitmask of '1' = only the least significant bit is set.
     andb %al, %bl     	   # Now '%bl' will be '1' only if the least significant bit of '%al' was '1' and '0' else. -> It was filtered through the bitmask with an 'and' instruction.
# We can then know whether the bit was set by checking the 'zero' flag (from the %eflags register) of last operation.
#     zero flag is set ('1) if the last operation resulted in '0'.
# And adapt the next step depending on it with 'jz' and 'jnz' jumps.
      jz NEXT_INSTRUCTION_IF_BITMASK_FAILED    # 'FAILED' in the sence that the specific bit of the bitmask - was not - within the checked value.
      jnz NEXT_INSTRUCTION_IF_BITMASK_WORKED   # 'WORKED' in the sence that the specific bit of the bitmask - was     - within the checked value.
#
# 'testb' = enhancemend of 'andb' instruction
# The 'testb' instruction works as an 'andb' instruction but discard the result and keep the flags set = memory efficient
# Example of use (short - simplified) :
  	  testb $0b00000001, %bl
	  jz BIT_WAS_NOT_SET # Jump to a specific memory address only if the hidden 'and' instruction with the bitmask resulted in a zero result -> Therefore using 'jz' (jump if zero result). 
  	  jnz BIT_WAS_SET    # Jump to a specific memory address only if the hidden 'and' instruction with the bitmask resulted in a non-zero result -> Therefore using 'jnz' (jump if non-zero result). 
#
#
# 'or(b|w|l|q) SOURCE, DEST' instruction
# Roughly the same process but will set the bits of the destination register if at least of one the two registers bit is set ('1').
# Detail :
  	 0 1 1 0 0 0 1 0
OR  	 1 1 1 1 0 1 0 0
________________________
	 1 1 1 1 0 1 1 0
#
#
# 'nor(b|w|l|q) SOURCE, DEST' instruction
# It is the 'or' negated so all 0's will become 1's and all 1's will become 0's.
# It is like an 'or' (see above) followed by a 'not' (see below).
# Detail :
  	     0 1 1 0 0 0 1 0
NOR  	     1 1 1 1 0 1 0 0
________________________
OR RESULT    1 1 1 1 0 1 1 0
NOR RESULT   0 0 0 0 1 0 0 1
#
#	 
# 'xor(b|w|l|q) SOURCE, DEST' instruction
# Set the destination bits if only one of both register bits is set.
# Detail :
#       0 1 1 0 0 0 1 0
# XOR   1 1 1 1 0 1 0 0
#______________________
#       1 0 0 1 0 1 1 0
# The most efficient way to load a register with the value of zero is to XOR it with itself.
# This is faster because the instruction can be encoded with a smaller number of bytes.
# Example :
  	  # To load '0' into %rax,
  	  # instead of :
	  # movq $0, %rax
	  # You should write :
	  xorq %rax, %rax
	  # WARNING : but this does set flags (as the 'zero' flag).
#
#
# 'not(b|w|l|q) DEST' instruction
# Revert all bits -> all '1's become '0's, and all '0's become '1's.
# Detail :
# NOT   0 1 1 0 0 0 1 0
#______________________
#       1 0 0 1 1 1 0 1
#
#
# The 'or' could also be written as '|'.
# The '|' symbol tells the assembler to perform 'or' operation WHILE assembling.
# WARNING : This is ONLY possible with the use of constant values.
# Example :
  	  # Set constants to bitmask
  	  .equ KNOWS_PROGRAMMING, 0b1 # bitmask = 1
	  .equ KNOWS_CHEMISTRY, 0b10 # bitmask = 2
	  .equ KNOWS_PHYSICS, 0b100 # bitmask = 4
	  # ...
	  # Set '%rax' to a combined bitmask by 'or'ing two flags with '$(...|...)'.
	  movq $(KNOWS_PROGRAMMING | KNOWS_PHYSICS), %rax
	  # Check whether a value (here : %rax) has a specific bit (flag) set and jump depending on it.
	  # The check is done with 'and' AND jump conditionally depending on the 'zero' flag.
	  andq $KNOWS_PROGRAMMING, %rax
	  jnz MEMORY_LOCATION_TO_JUMP_IF_FLAG_SET

# Operations to 'SET' individual bits
#
# This is useful when setting a register containing specific bits representing several flags.
#
# Set a flag (=bit) to '0' with an 'and' instruction and a value where :
#     - all non-interesting bits are set to '1'	     - which will not influence the result :	0 and 1 = 0 / 1 and 1 = 1 -> returns the same value as the initial one.
#     - the interesting bit is set to '0'    	     - which will influence the result :     	0 and 0 = 0 / 0 and 1 = 0 -> returns 0 in all cases.
#
# Set a flag (=bit) to '1' with an 'or' instruction and a value where :
#     - all non-interesting bits are set to '0'	     - which will not influence the result :	0 or 0 = 0 / 1 or 0 = 1 -> returns the same value as the initial one.
#     - the interesting bit is set to '1'    	     - which will influence the result :     	0 or 1 = 1 / 1 or 1 = 1 -> returns 1 in all cases.
#

# Scanning for bits
#
# Those instruction will taken an operand and search for a bit set ('1').
# In order to use the same instruction to search for a bit unset ('0'), a 'not' instruction is needed to reverse all bits, followed by the usual instruction to search a bit set ('1').
#
#
# 'lzcnt(b|w|l|q)' instruction to count the number of leading zero(s).
# 'lzcnt(b|w|l|q) SOURCE DEST'
# 'lzcnt' counts for the number of zero starting from the most significant bit of 'SOURCE' to the least significant bit and stop counting when reaching the first '1'.
# It will held the result within 'DEST' operand.
# Example :
# 	  '%rbx' contains 23, which in binary is '0...0 | 0 0 0 1 0 1 1 1' (7 bytes of '0's, and last byte of '00010111')
	  movq $23, %rbx
	  lzcntq %rbx, %rcx
	  # '%rcx' will contain (7 * 8 + 3 = 59) 59 as there are 59 '0's before reaching the first '1' bit.
#
#
# 'bsf(b|w|l|q)' instruction searches a value for the first nonzero bit ('1') starting with the least significant bit as bit (at index =) '0'.
# 'bsf(b|w|l|q) SOURCE, DEST'
# 'bsf' means 'bit scan forward' because it starts from the least and goes to the most significant bit of SOURCE.
# 'DEST' operand will held the index of the first '1' bit found.
# REMINDER : the first index is '0' (least significant bit) and the last index is 'bit-size - 1' as the first index is '0' and not '1'.
# If no bit are set (= all bits are '0's), then the DEST operand is undefined and the 'zero' flag will be set.
# Example :
# 	  '%rdx' contains 200, which in binary is '0...0 | 1 1 0 0 1 0 0 0' (7 bytes of '0's,  and last byte of '11001000')
	  movq $200, %rdx
	  bsfq %rdx, %rax
	  # '%rax' will contain the number (=index) 3 (and not '4' at first index is index '0').
	  # and the zero flag 'ZF' will be '0' (unset).
# Other example .
# 	 '%rdx' contains '0', which in binary is '0...0' (8 bytes of '0's).
	 movq $0, %rdx
	 bsfq %rdx, %rax
	 # '%rax' will be undefined as no '1' bit was found within %rdx.
	 # and the zero flag 'ZF' will be '1' (set).
#
#
# 'bsr(b|w|l|q)' instruction
# 'bsr(b|w|l|q) SOURCE, DEST' is similar to 'bsf(b|w|l|q) (see above) but starts from the last index (example for quadword, it would be index 63) and goes from the most to the least significant bit.
# 'bsr' stands for 'bit scan reverse'.
#
#
# REMINDER :
# 	   - Bits are counted from the least significant to the most significant, starting with the least significant bit being at index '0'.
#	   - When writting a binary number (example 97 = 0 1 1 0 0 0 0 1), the first index '0' would be the rightmost bit here (0...01) = 1.


================================================================
EFLAGS
________________________________________________________________

# List of flags in alphabetic order :
# REMINDER : the flag are set ('1') if activated, or unset else ('0').
#      - AF    auxiliary carry flag    ???
#      - CF    carry flag      	       Result of the last arithmetic operation was a 'carry', that is the result was bigger and could not be held in the destination register.
#      - DF    direction flag	       If unset, addresses contained within '%rsi' and '%rdi' registers will incremented by the size of operations when using instruction as 'movs(b|w|l|q)'. Else if set, addresses will be decremented.
#      - IF    ???	 	       ???
#      - OF    overflow flag	       Warns that if the intention was to use the number as a 'signed' one, there was an overflow so the sign is now wrong.
#      - PF    parity flag	       ???
#      - SF    sign flag      	       Tells that the most significant bit was set AFTER the instruction.
#      - ZF    zero flag	       Result of last ARITHMETIC operation was 0, set to '0' if it was different.

# Managing status flags
#
# The below instructions have no operand (neither SOURCE nor DEST).
#
# 'clc' : clears the carry flag 'CF'.
#
# 'setc' : set the carry flag 'CF'.
#
# 'cld' : clears the direction flag 'DF'.
#
# 'setd' : set the direction flag 'DF'.
#
# 'lahf' : loads the common flags (see below) FROM the '%eflags' register INTO the '%ah' register. 
#
# 'sahf' : store the common flags (see below) FROM the '%ah' register INTO the '%eflags' register. Bits 1, 3 and 5 are ignored in the 'sahf' instruction.

# Bit pattern for the flags
#     0. carry flag (CF)
#     1. always '1'
#     2. parity flag (PF)
#     3. always '0'
#     4. auxiliary carry flag (AF)
#     5. always '0'
#     6. zero flag (ZF)
#     7. sign flag (SF)
#
# Bits 1, 3 and 5 are ignored in the 'sahf' instruction - that stores from '%ah' into '%eflags' the common flags.
#
# So to summarize it is %eflags =
  0/1  1  0/1  0  0/1  0  0/1  0/1

================================================================
KERNEL AND SYSTEM CALLS
________________________________________________________________

# Processes
#
# There are two kind of processes :
# 	- user-mode tasks : (normal) processes runned by individual users as script in assembly.
#	- kernel-mode tasks : runned by the operating system kernel to accomplish system level activity.
# Those processes have different level of access within the CPU.

# Kernel tasks
#
# The kernel provides :
# 	 - low-level abstraction of the hardware interface so changes in hardware only require changes to the drivers, not to the application code.
#	 - high-level abstraction of filesystems and networks (and other similar things)
#	 - mechanism for processes to communicate with each other
#	 - sharing mechanism so that processes can all use system resources without causing injury to each other
#	 - permission enforcement to prevent processes doing what they should not (erasing data, hijacking OS)
#	 - restricted sandbox (environment) where programs are not likely to cause problems outside from it
#	 - restricted sandbox : it also helps program to manage themselves by not worring about other processes - each process act like if there were owning the whole computer while they are running.

# System calls - steps processed when making a system call.
#
# 1. Each program operates as if it was the only thing running on the machine.
# 2. When it needs something outside of itself (access to a file, network, more memory, device, etc...), it makes a 'system call'.
# 3. A system call hold the program and then switch control to the operating system kernel.
# 4. The kernel checks what is requested to ensure that the request is valid (access rights for what is requested)
# 5. If successful, the kernel retrives or perform the requested task.
# 6. The kernel forward the control to the original process.

# Syntax of syscall on x86_64 architecture
  	 syscall
	 # This perform a system call.
	 # The syscall number has to be set with '%rax'.
 # If other parameters are requested to perform the syscall, they should be within the registers :
 # (This a convention that was choosed to reduce the number of instruction to be executed by the kernel)
    %rax: syscall number
    %rdi: first argument
    %rsi: second argument
    %rdx: third argument
    %r10: fourth argument
    %r8: fifth argument
    %r9: sixth argument

# Example :
# ...
  # Exit with code
  # '%rax' : Syscall number 60 = exit :
  movq $60, %rax
  # '%rdi' : Setting the first argument of exit syscall to 33.
  movq $33, %rdi
  # SYSCALL : calling exit ('%rax') with code of 33 ('%rdi').
  syscall

# syscalls usually returns (except 'exit' syscall and other specific ones
# The 'syscall' instruction itself set registers.
#     - '%rcx' : this stores where the next instructions will be when kernel returns.
#     - '%r11' : the copied content of the '%eflags'
#     - %rax' : value returned to the program (as for a 'C' function).
# In case of error, USUALLY, a negative number is returned.
# Check a returned value to know whether the syscall was well performed.
# WARNING :
# Before performing a syscall, the content of the three above registers should be saved because they will/could be overwritten.

# Specific syscalls
# To find more information about syscalls :
#    - 'man 2 syscalls' -> information about syscalls in 'C'.
#    - 'man 2 SYSCALL_NAME' -> information about syscalls in 'C'.
#    - 'info syscall' -> libc information about how to process syscall.
# It is more efficient not to use syscalls directly - except for short program without outside dependencies.
# It is better to use system library as it will handle lots of strange or exceptional conditions which would be tough (and long) to code - in addition to perform syscalls.
#
#
# 'exit' = 60
# Exit the program with a specific return code.
# One parameter :
# - %rdi = exit return code
#
#
# 'time' = 201
# Returns the number of seconds since 'epoch' = 01.01.1970
# One parameter :
# - %rdi = register to hold the pointer to the address of the epoch.
# It sucessfully performed, '%rax' will contain the address when 'time' returns = same as '%rdi'.
# It is possible to 'sleep' the program by :
#    - saving current time (obtained with 'time') into a variable that is neither '%rax' not '%rdi' - for example, '%rdx'
#    - increase it as much as sleeping time wished
#    - compare current time with the increased saved one and loop back to the same section as much as the current time value is below the increased time.
#
#
# 'write' = 1
# Parameters :
# - %rdi = file descriptor (number)
# - %rsi = Pointer to the data to write. The data should be ASCII codes.
# - %rdx = Data length - without inclusion of null char if any.
#   	 -> The length has to be precised as data information is in binary - therefore the null char is a char as another and could need to be written as well. In order to enable the kernel writting ANY data, a length is used to precise where to stop instead of a specific (null) char.
# In Unix (as Linux), everything is a file.
# Each 'opened' file is given a number by the operating system to be referred to : 'file descriptor'.
# 'file descriptor' is usually a smallish value.
# When a process is started, three file descriptors are available :
#      - 0 : STDIN : standard input
#      - 1 : STDOUT : standard output
#      - 2 : STDERR : standard error
# The system enable to modify where redirect file descriptors 0-2 but the standard is STDIN, STDOUT and STDERR.
# Example :
	.globl _start
	.section .data
my_string:
	.ascii "Hello, world in ASSEMBLY !!!\n"
my_string_end:
	# Set the length of the data to be written as the difference between data start and data end.
	.equ my_string_length, my_string_end - my_string
	.section .text
_start:
	# Nothing important to be placed here.
	# The two 'syscall's were splitted into two sections to simplify code understanding.
write_data_to_stdout:
	# 'write' syscall (=1)
	movq $1, %rax
	# Set 'file descriptor' to STDOUT (=1)
	movq $1, %rdi
	# Load address of string
	leaq my_string, %rsi
	# Set the length of the string to be written
	leaq my_string_length, %rdx
	syscall
end:
	# Syscall exit
	xor %rdi, %rdi
	movq $60, %rax
	syscall


# Other system calls are detailed in other specific sections (for example in 'DYNAMIC MEMORY ALLOCATION' for 'mmap' and 'munmap').

================================================================
LIST OF SYSCALLS AVAILABLE ON LINUX x86_64
________________________________________________________________

# Sorted by syscall number

=========================================================================================
| Syscall Number | Syscall Name      | Description                                      |
|----------------|-------------------|--------------------------------------------------|
| 0              | read              | Read from a file descriptor                      |
| 1              | write             | Write to a file descriptor                       |
| 2              | open              | Open a file                                      |
| 3              | close             | Close a file descriptor                          |
| 4              | stat              | Get file status                                  |
| 5              | fstat             | Get file status                                  |
| 6              | lstat             | Get file status                                  |
| 7              | poll              | Synchronous I/O multiplexing                     |
| 8              | lseek             | Reposition read/write file offset                |
| 9              | mmap              | Map files or devices into memory                 |
| 10             | mprotect          | Set protection on a region of memory             |
| 11             | munmap            | Unmap files or devices from memory               |
| 12             | brk               | Change data segment size                         |
| 13             | rt_sigaction      | Examine and change a signal action               |
| 14             | rt_sigprocmask    | Examine and change blocked signals               |
| 16             | ioctl             | Control device                                   |
| 17             | pread64           | Read from a file descriptor at a given offset    |
| 18             | pwrite64          | Write to a file descriptor at a given offset     |
| 19             | readv             | Read from multiple buffers                       |
| 20             | writev            | Write to multiple buffers                        |
| 21             | access            | Check user's permissions for a file              |
| 22             | pipe              | Create pipe                                      |
| 23             | select            | Synchronous I/O multiplexing                     |
| 24             | sched_yield       | Yield the processor                              |
| 25             | mremap            | Remap a virtual memory address                   |
| 26             | msync             | Synchronize a file with a memory map             |
| 27             | mincore           | Determine whether pages are resident in memory   |
| 28             | madvise           | Advise about use of memory                       |
| 29             | shmget            | Get a System V shared memory segment identifier  |
| 30             | shmat             | Attach a shared memory segment                   |
| 31             | shmctl            | System V shared memory control operations        |
| 32             | dup               | Duplicate a file descriptor                      |
| 33             | dup2              | Duplicate a file descriptor                      |
| 34             | pause             | Wait for a signal                                |
| 35             | nanosleep         | High-resolution sleep                            |
| 39             | getpid            | Get process ID                                   |
| 40             | sendfile          | Transfer data between file descriptors           |
| 41             | socket            | Create an endpoint for communication             |
| 42             | connect           | Connect a socket                                 |
| 43             | accept            | Accept a connection on a socket                  |
| 44             | sendto            | Send a message on a socket                       |
| 45             | recvfrom          | Receive a message from a socket                  |
| 46             | sendmsg           | Send a message                                   |
| 47             | recvmsg           | Receive a message                                |
| 48             | shutdown          | Shut down part of a full-duplex connection       |
| 49             | bind              | Bind a name to a socket                          |
| 50             | listen            | Listen for connections on a socket               |
| 51             | getsockname       | Get socket name                                  |
| 52             | getpeername       | Get name of connected peer                       |
| 53             | socketpair        | Create a pair of connected sockets               |
| 54             | setsockopt        | Set options on sockets                           |
| 55             | getsockopt        | Get options on sockets                           |
| 57             | fork              | Create a child process                           |
| 59             | execve            | Execute a program                                |
| 60             | exit              | Terminate the calling process                    |
| 61             | wait4             | Wait for process to change state                 |
| 62             | kill              | Send a signal to a process                       |
| 63             | uname             | Get name and information about current kernel    |
| 64             | semget            | Get a System V semaphore set identifier          |
| 65             | semop             | System V semaphore operations                    |
| 66             | semctl            | System V semaphore control operations            |
| 67             | shmdt             | Detach a shared memory segment                   |
| 68             | msgget            | Get a System V message queue identifier          |
| 69             | msgsnd            | Send a message to a System V message queue       |
| 70             | msgrcv            | Receive a message from a System V message queue  |
| 71             | msgctl            | System V message control operations              |
| 72             | fcntl             | Manipulate file descriptor                       |
| 73             | flock             | Apply or remove an advisory lock on an open file |
| 75             | fdatasync         | Synchronize a file's in-core state with storage  |
| 77             | ftruncate         | Truncate a file to a specified length            |
| 78             | getdents          | Get directory entries                            |
| 79             | getcwd            | Get current working directory                    |
| 80             | chdir             | Change working directory                         |
| 81             | fchdir            | Change working directory                         |
| 82             | rename            | Rename a file                                    |
| 83             | mkdir             | Create a directory                               |
| 84             | rmdir             | Remove a directory                               |
| 85             | creat             | Create a file                                    |
| 86             | link              | Create a hard link                               |
| 87             | unlink            | Delete a name and possibly the file it refers to |
| 88             | symlink           | Make a new name for a file                       |
| 89             | readlink          | Read value of a symbolic link                    |
| 90             | chmod             | Change permissions of a file                     |
| 91             | fchmod            | Change permissions of a file                     |
| 92             | chown             | Change owner and group of a file                 |
| 93             | fchown            | Change owner and group of a file                 |
| 94             | lchown            | Change owner and group of a file                 |
| 96             | umask             | Set file mode creation mask                      |
| 97             | gettimeofday      | Get time                                         |
| 98             | getrlimit         | Get resource limits                              |
| 99             | getrusage         | Get resource usage                               |
| 100            | sysinfo           | Get system information                           |
| 101            | ptrace            | Process trace                                    |
| 102            | getuid            | Get user ID                                      |
| 104            | getgid            | Get group ID                                     |
| 104            | setitimer         | Set value of an interval timer                   |
| 105            | setuid            | Set user ID                                      |
| 106            | setgid            | Set group ID                                     |
| 107            | geteuid           | Get effective user ID                            |
| 107            | getitimer         | Get value of an interval timer                   |
| 108            | getegid           | Get effective group ID                           |
| 109            | setpgid           | Set process group ID                             |
| 110            | getppid           | Get parent process ID                            |
| 110            | reboot            | Reboot the system                                |
| 111            | getpgrp           | Get process group ID                             |
| 112            | setsid            | Create a session and set the process group ID    |
| 113            | setreuid          | Set real and effective user IDs                  |
| 114            | setregid          | Set real and effective group IDs                 |
| 114            | waitid            | Wait for process to change state                 |
| 115            | getgroups         | Get list of supplementary group IDs              |
| 116            | setgroups         | Set list of supplementary group IDs              |
| 117            | setresuid         | Set real, effective and saved user ID            |
| 118            | getresuid         | Get real, effective and saved user ID            |
| 118            | fsync             | Synchronize a file's in-core state with storage  |
| 119            | setresgid         | Set real, effective and saved group ID           |
| 120            | getresgid         | Get real, effective and saved group ID           |
| 121            | getpgid           | Get process group ID                             |
| 122            | setfsuid          | Set user ID used for file system checks          |
| 123            | setfsgid          | Set group ID used for file system checks         |
| 124            | getsid            | Get session ID                                   |
| 127            | rt_sigpending     | Examine pending signals                          |
| 128            | rt_sigtimedwait   | Synchronously wait for a signal                  |
| 129            | rt_sigqueueinfo   | Queue a signal and data                          |
| 130            | rt_sigsuspend     | Wait for a signal                                |
| 132            | sigaltstack       | Set and/or get signal stack context              |
| 133            | mknod             | Create a special or ordinary file                |
| 135            | personality       | Set the process execution domain                 |
| 137            | vfork             | Create a child process and block parent          |
| 138            | fstatfs           | Get file system statistics                       |
| 140            | getpriority       | Get program scheduling priority                  |
| 141            | setpriority       | Set program scheduling priority                  |
| 142            | sched_setparam    | Set scheduling parameters                        |
| 143            | sched_getparam    | Get scheduling parameters                        |
| 144            | sched_setscheduler | Set scheduling policy                            |
| 145            | sched_getscheduler | Get scheduling policy                            |
| 146            | sched_get_priority_max | Get maximum scheduling priority              |
| 147            | sched_get_priority_min | Get minimum scheduling priority              |
| 148            | sched_rr_get_interval | Get the SCHED_RR interval for the named process |
| 149            | mlock             | Lock memory                                      |
| 150            | munlock           | Unlock memory                                    |
| 151            | mlockall          | Lock all memory                                  |
| 152            | munlockall        | Unlock all memory                                |
| 154            | modify_ldt        | Modify the local descriptor table                |
| 155            | pivot_root        | Change the root filesystem                       |
| 157            | prctl             | Operations on a process                          |
| 158            | arch_prctl        | Set architecture-specific thread state           |
| 160            | setrlimit         | Set resource limits                              |
| 164            | settimeofday      | Set time                                         |
| 165            | mount             | Mount a filesystem                               |
| 169            | reboot            | Reboot the system                                |
| 170            | sethostname       | Set the hostname                                 |
| 171            | setdomainname     | Set the NIS domain name                          |
| 172            | iopl              | Change I/O privilege level                       |
| 173            | ioperm            | Set port input/output permissions                |
| 179            | quotactl          | Quota control                                    |
| 186            | gettid            | Get thread ID                                    |
| 187            | readahead         | Perform file readahead                           |
| 188            | setxattr          | Set extended attributes                          |
| 190            | fsetxattr         | Set extended attributes                          |
| 193            | fgetxattr         | Get extended attributes                          |
| 196            | flistxattr        | List extended attributes                         |
| 197            | removexattr       | Remove extended attributes                       |
| 199            | fremovexattr      | Remove extended attributes                       |
| 200            | tkill             | Send a signal to a thread                        |
| 201            | time              | Get time in seconds                              |
| 202            | futex             | Fast user-space locking                          |
| 203            | sched_setaffinity | Set a process's CPU affinity mask                |
| 204            | sched_getaffinity | Get a process's CPU affinity mask                |
| 205            | set_thread_area   | Set a thread-local storage (TLS) descriptor      |
| 216            | remap_file_pages  | Create a nonlinear file mapping                  |
| 217            | getdents64        | Get directory entries                            |
| 218            | set_tid_address   | Set pointer to thread ID                         |
| 218            | setns             | Reassociate thread with a namespace              |
| 219            | restart_syscall   | Restart a system call after interruption by a stop signal |
| 220            | semtimedop        | System V semaphore operations                    |
| 231            | exit_group        | Exit all threads in a process                    |
| 232            | epoll_wait        | Wait for events on an epoll file descriptor      |
| 237            | mbind             | Set memory policy for a memory range             |
| 238            | set_mempolicy     | Set memory policy for a process                  |
| 246            | kexec_load        | Load a new kernel for later execution            |
| 249            | request_key       | Request a key from the kernel's key management facility |
| 250            | keyctl            | Perform a key management function                |
| 251            | ioprio_set        | Set I/O scheduling class and priority            |
| 252            | ioprio_get        | Get I/O scheduling class and priority            |
| 253            | inotify_init      | Initialize an inotify instance                   |
| 254            | inotify_add_watch | Add a watch to an initialized inotify instance   |
| 255            | inotify_rm_watch  | Remove an existing watch from an inotify instance|
| 256            | migrate_pages     | Move all pages in a process to another node      |
| 257            | openat            | Open a file relative to a directory file descriptor |
| 258            | mkdirat           | Create a directory relative to a directory file descriptor |
| 259            | mknodat           | Create a file relative to a directory file descriptor |
| 260            | fchownat          | Change owner and group of a file relative to a directory file descriptor |
| 261            | futimesat         | Change file timestamps relative to a directory file descriptor |
| 262            | newfstatat        | Get file status relative to a directory file descriptor |
| 263            | unlinkat          | Delete a name and possibly the file it refers to, relative to a directory file descriptor |
| 264            | renameat          | Rename a file relative to a directory file descriptor |
| 265            | linkat            | Create a hard link relative to a directory file descriptor |
| 266            | symlinkat         | Create a symbolic link relative to a directory file descriptor |
| 267            | readlinkat        | Read value of a symbolic link relative to a directory file descriptor |
| 268            | fchmodat          | Change permissions of a file relative to a directory file descriptor |
| 269            | faccessat         | Check user's permissions for a file relative to a directory file descriptor |
| 270
| ...		There are lots more system calls available...
=========================================================================================

# Sorted by names :

=========================================================================================
| Syscall Name      | Syscall Number | Description                                      |
|-------------------|----------------|--------------------------------------------------|
| accept            | 43             | Accept a connection on a socket                  |
| accept4           | 288            | Accept a connection on a socket                  |
| access            | 21             | Check user's permissions for a file              |
| arch_prctl        | 158            | Set architecture-specific thread state           |
| bind              | 49             | Bind a name to a socket                          |
| bpf               | 321            | Perform operations on BPF programs               |
| brk               | 12             | Change data segment size                         |
| chdir             | 79             | Change working directory                         |
| chmod             | 90             | Change permissions of a file                     |
| chown             | 92             | Change owner and group of a file                 |
| clock_adjtime     | 304            | Adjust the system clock                          |
| close             | 3              | Close a file descriptor                          |
| close_range       | 436            | Close a range of file descriptors                |
| connect           | 42             | Connect a socket                                 |
| copy_file_range   | 326            | Copy a range of data from one file to another    |
| creat             | 85             | Create a file                                    |
| dup               | 32             | Duplicate a file descriptor                      |
| dup2              | 33             | Duplicate a file descriptor                      |
| dup3              | 292            | Duplicate a file descriptor                      |
| epoll_create1     | 291            | Create an epoll file descriptor                  |
| epoll_pwait       | 281            | Wait for events on an epoll file descriptor      |
| epoll_pwait2      | 441            | Wait for events on an epoll file descriptor      |
| epoll_wait        | 232            | Wait for events on an epoll file descriptor      |
| eventfd           | 284            | Create a file descriptor for event notification  |
| eventfd2          | 290            | Create a file descriptor for event notification  |
| execve            | 59             | Execute a program                                |
| execveat          | 322            | Execute a program                                |
| exit              | 60             | Terminate the calling process                    |
| exit_group        | 231            | Exit all threads in a process                    |
| faccessat         | 269            | Check user's permissions for a file relative to a directory file descriptor |
| faccessat2        | 439            | Check user's permissions for a file              |
| fallocate         | 285            | Manipulate file space                            |
| fanotify_init     | 300            | Initialize fanotify group                        |
| fanotify_mark     | 301            | Add, remove, or modify an fanotify mark          |
| fchdir            | 80             | Change working directory                         |
| fchmod            | 91             | Change permissions of a file                     |
| fchmodat          | 268            | Change permissions of a file relative to a directory file descriptor |
| fchown            | 93             | Change owner and group of a file                 |
| fchownat          | 260            | Change owner and group of a file relative to a directory file descriptor |
| fcntl             | 72             | Manipulate file descriptor                       |
| fdatasync         | 75             | Synchronize a file's in-core state with storage  |
| fgetxattr         | 193            | Get extended attributes                          |
| finit_module      | 313            | Load a kernel module                             |
| flistxattr        | 196            | List extended attributes                         |
| flock             | 73             | Apply or remove an advisory lock on an open file |
| fork              | 57             | Create a child process                           |
| fremovexattr      | 199            | Remove extended attributes                       |
| fsetxattr         | 190            | Set extended attributes                          |
| fstat             | 5              | Get file status                                  |
| fstatfs           | 138            | Get file system statistics                       |
| fsync             | 118            | Synchronize a file's in-core state with storage  |
| ftruncate         | 77             | Truncate a file to a specified length            |
| futex             | 202            | Fast user-space locking                          |
| futimesat         | 261            | Change file timestamps relative to a directory file descriptor |
| getcpu            | 309            | Determine CPU and NUMA node                      |
| getcwd            | 78             | Get current working directory                    |
| getdents          | 78             | Get directory entries                            |
| getdents64        | 217            | Get directory entries                            |
| getegid           | 108            | Get effective group ID                           |
| geteuid           | 107            | Get effective user ID                            |
| getgid            | 104            | Get group ID                                     |
| getgroups         | 115            | Get list of supplementary group IDs              |
| getitimer         | 107            | Get value of an interval timer                   |
| getpeername       | 52             | Get name of connected peer                       |
| getpgid           | 121            | Get process group ID                             |
| getpgrp           | 111            | Get process group ID                             |
| getpid            | 39             | Get process ID                                   |
| getppid           | 110            | Get parent process ID                            |
| getpriority       | 140            | Get program scheduling priority                  |
| getrandom         | 318            | Obtain random bytes                              |
| getresgid         | 120            | Get real, effective and saved group ID           |
| getresuid         | 118            | Get real, effective and saved user ID            |
| getrlimit         | 97             | Get resource limits                              |
| getrusage         | 98             | Get resource usage                               |
| getsid            | 124            | Get session ID                                   |
| getsockname       | 51             | Get socket name                                  |
| getsockopt        | 55             | Get options on sockets                           |
| gettid            | 186            | Get thread ID                                    |
| gettimeofday      | 96             | Get time                                         |
| getuid            | 102            | Get user ID                                      |
| inotify_add_watch | 254            | Add a watch to an initialized inotify instance   |
| inotify_init      | 253            | Initialize an inotify instance                   |
| inotify_init1     | 294            | Initialize an inotify instance                   |
| inotify_rm_watch  | 255            | Remove an existing watch from an inotify instance|
| ioctl             | 16             | Control device                                   |
| ioperm            | 173            | Set port input/output permissions                |
| iopl              | 172            | Change I/O privilege level                       |
| ioprio_get        | 252            | Get I/O scheduling class and priority            |
| ioprio_set        | 251            | Set I/O scheduling class and priority            |
| kcmp              | 312            | Compare two processes                            |
| kexec_file_load   | 320            | Load a new kernel for later execution            |
| kexec_load        | 246            | Load a new kernel for later execution            |
| keyctl            | 250            | Perform a key management function                |
| kill              | 62             | Send a signal to a process                       |
| lchown            | 94             | Change owner and group of a file                 |
| link              | 86             | Create a hard link                               |
| linkat            | 265            | Create a hard link relative to a directory file descriptor |
| listen            | 50             | Listen for connections on a socket               |
| lseek             | 8              | Reposition read/write file offset                |
| lstat             | 6              | Get file status                                  |
| madvise           | 28             | Advise about use of memory                       |
| mbind             | 237            | Set memory policy for a memory range             |
| memfd_create      | 319            | Create an anonymous file                         |
| migrate_pages     | 256            | Move all pages in a process to another node      |
| mincore           | 27             | Determine whether pages are resident in memory   |
| mkdir             | 83             | Create a directory                               |
| mkdirat           | 258            | Create a directory relative to a directory file descriptor |
| mknod             | 133            | Create a special or ordinary file                |
| mknodat           | 259            | Create a file relative to a directory file descriptor |
| mlock             | 149            | Lock memory                                      |
| mlock2            | 325            | Lock memory                                      |
| mlockall          | 151            | Lock all memory                                  |
| mmap              | 9              | Map files or devices into memory                 |
| modify_ldt        | 154            | Modify the local descriptor table                |
| mount             | 165            | Mount a filesystem                               |
| move_mount        | 429            | Move a mount point                               |
| move_pages        | 279            | Move pages of a process to another node          |
| mprotect          | 10             | Set protection on a region of memory             |
| mremap            | 25             | Remap a virtual memory address                   |
| msgctl            | 71             | System V message control operations              |
| msgget            | 68             | Get a System V message queue identifier          |
| msgrcv            | 70             | Receive a message from a System V message queue  |
| msgsnd            | 69             | Send a message to a System V message queue       |
| msync             | 26             | Synchronize a file with a memory map             |
| munlock           | 150            | Unlock memory                                    |
| munlockall        | 152            | Unlock all memory                                |
| munmap            | 11             | Unmap files or devices from memory               |
| name_to_handle_at | 303            | Obtain handle for a pathname                     |
| nanosleep         | 35             | High-resolution sleep                            |
| newfstatat        | 262            | Get file status relative to a directory file descriptor |
| open              | 2              | Open a file                                      |
| open_by_handle_at | 304            | Open file via a handle                           |
| openat            | 257            | Open a file relative to a directory file descriptor |
| pause             | 34             | Wait for a signal                                |
| perf_event_open   | 298            | Open a performance monitoring event              |
| personality       | 135            | Set the process execution domain                 |
| pipe              | 22             | Create pipe                                      |
| pipe2             | 293            | Create a pipe                                    |
| pivot_root        | 155            | Change the root filesystem                       |
| pkey_alloc        | 330            | Allocate a protection key                        |
| pkey_free         | 331            | Free a protection key                            |
| pkey_mprotect     | 329            | Set protection on a region of memory             |
| poll              | 7              | Synchronous I/O multiplexing                     |
| ppoll             | 271            | Synchronous I/O multiplexing                     |
| prctl             | 157            | Operations on a process                          |
| pread64           | 17             | Read from a file descriptor at a given offset    |
| preadv            | 295            | Read from multiple buffers                       |
| preadv2           | 327            | Read from multiple buffers                       |
| prlimit64         | 302            | Get/set resource limits                          |
| process_madvise   | 440            | Advise about use of memory                       |
| process_vm_readv  | 310            | Read from another process's address space        |
| process_vm_writev | 311            | Write to another process's address space         |
| pselect6          | 270            | Synchronous I/O multiplexing                     |
| ptrace            | 101            | Process trace                                    |
| pwrite64          | 18             | Write to a file descriptor at a given offset     |
| pwritev           | 296            | Write to multiple buffers                        |
| pwritev2          | 328            | Write to multiple buffers                        |
| quotactl          | 179            | Quota control                                    |
| read              | 0              | Read from a file descriptor                      |
| readahead         | 187            | Perform file readahead                           |
| readlink          | 89             | Read value of a symbolic link                    |
| readlinkat        | 267            | Read value of a symbolic link relative to a directory file descriptor |
| readv             | 19             | Read from multiple buffers                       |
| reboot            | 169            | Reboot the system                                |
| recvfrom          | 45             | Receive a message from a socket                  |
| recvmmsg          | 299            | Receive multiple messages                        |
| recvmsg           | 47             | Receive a message                                |
| remap_file_pages  | 216            | Create a nonlinear file mapping                  |
| removexattr       | 197            | Remove extended attributes                       |
| rename            | 82             | Rename a file                                    |
| renameat          | 264            | Rename a file relative to a directory file descriptor |
| renameat2         | 316            | Rename a file                                    |
| request_key       | 249            | Request a key from the kernel's key management facility |
| restart_syscall   | 219            | Restart a system call after interruption by a stop signal |
| rmdir             | 84             | Remove a directory                               |
| rt_sigaction      | 13             | Examine and change a signal action               |
| rt_sigpending     | 127            | Examine pending signals                          |
| rt_sigprocmask    | 14             | Examine and change blocked signals               |
| rt_sigqueueinfo   | 129            | Queue a signal and data                          |
| rt_sigsuspend     | 130            | Wait for a signal                                |
| rt_sigtimedwait   | 128            | Synchronously wait for a signal                  |
| rt_tgsigqueueinfo | 297            | Queue a signal and data                          |
| sched_getaffinity | 204            | Get a process's CPU affinity mask                |
| sched_getattr     | 315            | Get scheduling parameters                        |
| sched_getparam    | 143            | Get scheduling parameters                        |
| sched_get_priority_max | 146        | Get maximum scheduling priority                  |
| sched_get_priority_min | 147        | Get minimum scheduling priority                  |
| sched_getscheduler | 145            | Get scheduling policy                            |
| sched_rr_get_interval | 148         | Get the SCHED_RR interval for the named process  |
| sched_setaffinity | 203            | Set a process's CPU affinity mask                |
| sched_setattr     | 314            | Set scheduling parameters                        |
| sched_setparam    | 142            | Set scheduling parameters                        |
| sched_setscheduler | 144            | Set scheduling policy                            |
| sched_yield       | 24             | Yield the processor                              |
| seccomp           | 317            | Operate on secure computing state                |
| select            | 23             | Synchronous I/O multiplexing                     |
| semctl            | 66             | System V semaphore control operations            |
| semget            | 64             | Get a System V semaphore set identifier          |
| semop             | 65             | System V semaphore operations                    |
| semtimedop        | 220            | System V semaphore operations                    |
| sendfile          | 40             | Transfer data between file descriptors           |
| sendmmsg          | 307            | Send multiple messages                           |
| sendmsg           | 46             | Send a message                                   |
| sendto            | 44             | Send a message on a socket                       |
| set_mempolicy     | 238            | Set memory policy for a process                  |
| set_robust_list   | 273            | Set list of robust futexes                       |
| set_thread_area   | 205            | Set a thread-local storage (TLS) descriptor      |
| set_tid_address   | 218            | Set pointer to thread ID                         |
| setdomainname     | 171            | Set the NIS domain name                          |
| setfsgid          | 123            | Set group ID used for file system checks         |
| setfsuid          | 122            | Set user ID used for file system checks          |
| setgid            | 106            | Set group ID                                     |
| setgroups         | 116            | Set list of supplementary group IDs              |
| sethostname       | 170            | Set the hostname                                 |
| setitimer         | 104            | Set value of an interval timer                   |
| setns             | 308            | Reassociate thread with a namespace              |
| setpgid           | 109            | Set process group ID                             |
| setpriority       | 141            | Set program scheduling priority                  |
| setregid          | 114            | Set real and effective group IDs                 |
| setresgid         | 119            | Set real, effective and saved group ID           |
| setresuid         | 117            | Set real, effective and saved user ID            |
| setreuid          | 113            | Set real and effective user IDs                  |
| setrlimit         | 160            | Set resource limits                              |
| setsid            | 112            | Create a session and set the process group ID    |
| setsockopt        | 54             | Set options on sockets                           |
| settimeofday      | 164            | Set time                                         |
| setuid            | 105            | Set user ID                                      |
| setxattr          | 188            | Set extended attributes                          |
| shmat             | 30             | Attach a shared memory segment                   |
| shmctl            | 31             | System V shared memory control operations        |
| shmdt             | 67             | Detach a shared memory segment                   |
| shmget            | 29             | Get a System V shared memory segment identifier  |
| shutdown          | 48             | Shut down part of a full-duplex connection       |
| sigaltstack       | 132            | Set and/or get signal stack context              |
| signalfd          | 282            | Create
=========================================================================================
================================================================
STACK AND FUNCTION CALLS
________________________________________________________________

# How works the stack 
#
# The stack is used to hold values which will eventually be discarded.
# The stack is composed of tasks in a LIFO (Last In First Out) order, that is to say from the newest to the oldest.
# The oldest tasks may need some intermediary results and each time they needs it, they will create a new task on the stack.
# This new task will get the computer attention while the old task will not continue until the result from the new task is provided.
# When a new task is finished, the result is provided to the precedent (old) task just before it.
# And this process is repeated until the initial task could obtain all intermediary results to be finished.


# Computer stack
#
# The computer stack is an area of memory that will ocntain temporary items.
# The OS preallocates spaces for the stack and puts a pointer to this memory in the stack pointer :
#     - %rsp : register of the 'stack pointer' that points to the end of the memory region containing the stack.
# WARNING : the stack pointer does not point to the beginning (as usual) of a memory location but instead, to the END.
#
# The computer stack helps to separate (split) program into distinct parts.
# Each part is then strictly separated from others because all intermediary results are held into the stack before changing from a part to another.
# That way, no registers overwritting will happened - as for example when a part of a program modify a specific register used by another part whithout that the latter knows it.
# Therefore, it avoids disruption of garbage values into registers produced by another part of the program.
# In order to avoid issues, values from registers can be pushed to the stack before switching to another part and then recovered when returning.
# IMPORTANT :
# 	- each part of a program (and therefore the developper of it) has to be responsible for re-setting the stack to the initial state - the one the stack was at the beginning of this specific part.
#	- That is to say that each pushed value has to be popped within the part of the program.
#	- There are other ways to re-set the stack to the initial state (as with pointers and computation on them).
# IMPORTANT : When managing the stack, all steps done have to be done in the reverse order and with reverse consequences in order to re-set it to its initial state.

# 'loose coupling'
# Re-setting the stack to its initial state is called 'loose coupling'.
# It helps developping as - if well done, no one has to care about all parts of programs as they will re-set back the stack to the initial state.
# Therefore, no program disruption (with garbage values in registers) will be seen.
# Also, it makes it easier to modify specific part of the program as they all become independent from each other.

# 'push' instruction
# 'push(b|w|l|q) source'
# Adds things to the stack :
#    1. Decrement %rsp to point to the next location on the stack (as stack is in decreasing memory order).
#    2. Copy the value to the location specified by %rsp.

# 'pop' instruction
# 'pop(b|w|l|q) source'
# Recover things from the stack - the reverse of 'push' instruction :
# 	  1. Get the value from the location pointed by %rsp.
#	  2. Increment %rsp to point to the previous location on the stack (as stack is in decreasing memory order).

# Reserving space on the stack
#
# It is done by :
#    - decreasing the stack pointer '%rsp' of a specific number of bytes at the beginning.
#    - increase '%rsp' for about the same specific number of bytes at the end.
# Example :
  # Reservation of 16 bytes on the stack.
  subq $16, %rsp
  # Using the stack
  # ...
  # Re-setting the stack to its initial state.
  addq $16, %rsp

# Stack VS '.section .data'
#
# It is better to use the stack if the data that will be used will only be useful during the specific section of code - not after it.
# That way, the data is temporary and will be memory efficient.
# So if the data have to be used outside the specific section of code, it will be better to set it through the '.section .data'.
# WARNING : on x86-64 systems, the stack is limited to 2 megabytes - which usually is not an issue as this value is pretty big.

# Functions
#
# 'loose coupling' is done through 'functions' (also called 'procedures' or 'routines').
#
# Functions have :
# 	- name : a label that refer to the starting address (function entry point) of the function's code.
#	- input parameters : also called 'arguments'.
#	- return value(s) :
#	  	 -> The value that is returned to the code that called the function.
#		 -> Usually (as in many languages), the function has only one returned value.
#		 -> However, it is possible to simulate several values by providing pointers as input parameters.
#		 -> Each of those pointers is a memory location where other results will be stored for output.
#		 -> On the same way, the returned value could be a pointer to a memory location were several values are held.
#	- side effects :
#	       	 -> Something that is altered which is not specified in the input or output parameters.
#		 -> Those are generally avoided as much as possible - but this is not always possible.
#		 -> An example of a wished side effect is logging (the logs).
#		 -> Logging an error is neither done through an input or an output parameters so sending data to the log file is a side effect.

# Conventions for function calls
#
# WARNING : there are lots of conventions.
#
# The convention for function calls is knows as 'application binary interface' = ABI
# Having an interface helps to use programs written by others, as well as functions - even from different languages - as long as they respect the ABI convention.
# Linux uses the ABI called 'System V ABI'.
#
#
# Preservation of specific registers
# The content of registers :
#     - %rbp
#     - %rbx
#     - %r12 to %r15
# ... have to be PRESERVED.
# So if it is wished to used those, the initial content should be saved and re-set by the end of the program section.
# This preservation could be done through the stack or saving into other registers.
# WARNING : Other registers are not protected by the preservation (convention) so they could be OVERWRITTEN through any function.
#
#
# Input parameters
# WARNING : this is not the same convention as for the syscall parameters.
# IMPORTANT : the below parameters does not have to be preserved so they could be modified within any function.
# Arguments should be in the following order :
#    1. %rdi
#    2. %rsi
#    3. %rdx
#    4. %rcx
#    5. %r8
#    6. %r9
# If there are more than 6 parameters, the next ones get pushed onto the stack as quadwords (MANDATORY) using 'pushq' (pushQ = quadword mandatory).
# IMPORTANT : the last parameter gets pushed onto the stack first because the stack is in reverse order so when popping, it has to be popped last (so pushed first onto the stack).
# Example : In this example, the value of the parameter is the same as the order of the parameter so first argument gets value '1', second '2', ... until the tenth (10') parameter.
  movq $1, %rdi
  movq $2, %rsi
  movq $3, %rdx
  movq $4, %rcx
  movq $5, %r8
  movq $6, %r9
  # The 'push' on the stack starts by the last argument (tenth).
  # And the 'push' is repeated in reverse order of argument (from the last to the first) until argument 7.
  pushq $10
  pushq $9
  pushq $8
  pushq $7
  # And then, the function can be 'call'ed with the 'call' instruction. 
  call my_function_name
# The use of this 'input parameter' function convention helps to reduce the number of instruction executed so increase the efficiency of the program.
#
#
# Returned value(s)
# The first returned value is held within the '%rax' register.
# If a second value has to be returned, it is held within the '%rdx' register
# It is unusual to return more than one value - however - it is not impossible.
# Usually, if more than one value has to be returned, it is done by putting those within memory location provided by an input parameter pointer or an output parameter pointer.
#
#
# Saving data on the stack
# 'stack frame' :
# 	 - the section of the stack belonging to a given function invocation.
#	 - It is all the local temporary storage needed by the function as well as metadata needed by the system to make the function invocation.
# The 'bottom' of a stack frame is represented by highest memory location.
# The 'top' is represented by lowest memory location.
# If the stack grows, it will be provided lower and lower memory location.
# This is because the stack pointer points to the end of the memory location and is decreased at each 'push'.
#
# '%rsp' and '%rbp'
# As '%rsp' will be modified throughout the stack use (and the program), the reference to the stack frame is held within '%rbp'.
# Therefore, all local values to a stack frame will be referenced as offsets to '%rbp' (the current location of the stack frame).
# '%rbp' is fixed for the duration of the function.
# '%rsp' will be modified throughout the duration of the function - as well as if the function perform other function call.
# IMPORTANT :
# 	- The first thing that has to be done when starting a function is to save the value of '%rbp' onto the stack as '%rbp' has to be preserved (see above convention).
#	      -> That way, the precedent stack frame location will be preserved.
#	- The second thing is to save the value of '%rsp' to '%rbp' - that way, '%rbp' points to the location where is the current stack frame.
# Then, space has to be provided to the current stack frame by reducing '%rsp' about a specific bytes number.
# All variables of the current stack frame can be referred as an offset of '%rbp' (fixed during the stack frame)
# That way, any function called by the current stack frame will not overwritten local variables.
#
#
# The 'System V ABI' on Linux require that the stack is aligned to a multiple of 16 bytes (stack = 16x, x=[0, 1, 2, ..., infinite[)
# Therefore, '%rsp' (and '%rbp') should always be a multiple of 16 bytes.
# IMPORTANT :
# 	-> Some functions will crash if the alignment to a multiple of 16 bytes is not respected.
#	   -> This is not mandatory (but should be a great recommendation) as long as the function I create do not call other functions.
# 	-> So the 'enter' instruction should always use a multiple of 16 bytes as first parameter.
# 	-> If a function that uses extra parameters pushed on the stack is called, the stack should be aligned BEFORE calling it as required by pushing extra bytes, word, double word (long) or quadwords as required. Very little functions take extra parameters : This is rarely the case but still could happened.
# WARNING : For more complex cases :
# 	    - sending data that is neither an integer nor a pointer
#	    - using function that have more than six inputs parameters.
#	    -> It is highly recommended to check the official documentation to know how to process at :
#	       https://gitlab.com/x86-psABIs/x86-64-ABI
#
#
# Functions help to structure a program to be more flexible with each piece being independent one from another.
# All interfaces are well specified by the 'ABI' standardized convention and this enable any program to call functions even from different languages.


# Other important function instructions
#
#
# 'call' instruction
  call function_name
# 'call' will call a specific function and move to the memory location of its label.
# It equivaults to push the address of next instruction (known as 'return address') on the stack and then jump to the function.
# That way, when the function is finished, it knows where to continue = next instruction to execute.
# It could be written as :
  pushq $NEXT_INSTRUCTION_ADDRESS
  jmp MY_FUNCTION
NEXT_INSTRUCTION_ADDRESS:
	# Next instruction here
	# ...
#
#
# 'ret' instruction
# The 'ret' instruction is what will get (from the stack) the address of the next instruction (known as "RETURN" address) and move to it.
# It should be combined with the 'call' instruction above.
# It is mandatory at the end of any function.
#
#
# 'enter' instruction
# Syntax :
# enter $NUMBER_OF_BYTES, $0
# The 'enter' instruction takes two parameters :
#     - the first one is the number of bytes to be reserved for the current stack frame.
#     	    IMPORTANT : due to 'System V ABI', the number should be a multiple of 16 bytes.
#     - the second one will always (or usually always) set to '$0'.
#      	    It is a programming language feature called 'closures' (or 'nested functions') which is rarely implemented using this feature of 'enter'.
# The 'enter' instruction was created to reproduce the below block code.
# Example of every functions start :
  # Save the previous stack frame location onto the stack.
  pushq %rbp
  # Copy the stack pointer to the base pointer for a fixed reference point.
  movq %rsp, %rbp
  # Reserve as much memory as needed on the stack
  subq $NUMER_OF_BYTES, %rsp
# IMPORTANT : the 'enter' instruction is much more SLOWER than the set of instruction it replaces BUT it provides a code easily understandable (can easily check that a stack frame is 'enter'ed and then 'leave'd (left) at the end.
#
#
# 'leave' instruction
# The 'leave' instruction was created to reproduce the below block code.
# Example of every functions end :
# (This reverse the function start - that is to say - it re-set '%rsp' and '%rbp' to their initial state)
  # Restore the stack pointer
  movq %rbp, %rsp
  # Restore the base pointer
  popq %rbp
# IMPORTANT : not as the 'enter' instruction, 'leave' is much more FASTER than the set of instruction it replaces.
#
# IMPORTANT :
# 	- If a function is sufficiently simple not to use 'enter' and 'leave', ...
#	- And that all computation can be done through registers, ...
#	- And no overwritting of registers required to be preserved is performed, ...
#	-> Then there is no reason to use 'enter' and 'leave' within the code of a stack frame.
#
# IMPORTANT : As 'enter' is SLOWER than the set of instructions it replaces, and that 'leave' is FASTER, lots of compilers will set up a stack frame manually BUT then use 'leave' to tear it down.

# Example of function definition and call :
# (In this example, a function is defined within a file and called from another. But this could be merged within only one file for basic programs).
# DEFINITION
  	# Setting the function to be a global variable - that way, it can be called from another file.
  	.globl MY_FUNCTION_NAME
	# IMPORTANT : the type of the function has to be precised.
	.type MY_FUNCTION_NAME, @function
	#
	.section .text
MY_FUNCTION_NAME:
	# %rdi holds the first parameter - if any.
	# %rsi holds the second parameter if any.
	# ...
	#
	# ENTER
	# Aligning the stack to a 16 bytes multiple.
	enter $NUMBER_OF_BYTES, $0
	# Put (and not push) any local variable use through the function to the stack.
	# Here, the value of '%rsi' (register of 64 bits = 8 bytes) will be placed within the stack at the position starting at an offset of -8 from %rbp (fixed along the function).
	movq %rsi, -8(%rbp)
	#
	# Function code ..
	# The function could call other labels here (of the same/different file).	
	#
	# LEAVE
	# 'leave' answers to the above 'enter' instruction.
	leave
	# The function will return to the next instruction address and the result will be held within '%rax'.
	ret
	#
	#
# CALL FROM ANOTHER FILE
	# This program has to be linked with the above function definition file.
	.globl _start
	#
	.section .text
_start:
	# Set function parameters (%rdi, %rsi)...
	movq $NUMBER, %rdi
	movq $OTHER_NUMBER, %rsi
	# Call function -> result will be held within '%rax'.
	call MY_FUNCTION_NAME
	#
	#

# Calling the function from another language
#
# Because of the ABI, the function can be called from another language, for example 'C'.
/* The 'C' object file created from this file has to be linked with the object file containing the definition of the function 'my_function' with the command :

   gcc THIS_FILE.c FUNCTION_DEFINITION.s -o THIS_FILE
   
   There could be additional parameters to add to 'gcc'.
 */
int my_function(int, int) ; /* function prototype */

int main() {
  return my_function(4, 3) ; /* function call */
  
}
# And then for the linking and execution (all files are set to variable, but without their extensions) :
      FUNCTION_DEFINITION_FILE="" ; PROGRAM=""; gcc "$PROGRAM".c "$FUNCTION_DEFINITION_FILE".s -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ; rm -rf "$PROGRAM" ;

# Using '.equ' to define stack frame fixed offsets
#
# This helps to keep track on the offset of all variables used.
# For example, when the number of them increase, it is tough to remember if the offset was '-64(%rbp)' or '-56(%rbp)'
# WARNING : the '.equ' symbols must NOT be defined as '.globl' as they are useful ONLY within the current function.

================================================================
CALLING FUNCTIONS FROM LIBRARIES
________________________________________________________________

# On Linux, there are two kinds of libraries :
#    - static
#    - shared

# Static libraries
#
# The static libraries contain code that will be copied/pasted to any program using it.
#
# Extension
#
# The extension usually is '.a' as 'archive', 'archive' of functions.
# Library files for static libraries are named 'libX.a' with 'X' being replaced by the library name.
# For example, for the 'C standard library', the file would be 'libc.a'.
#
# Use library functions
#
# As usual, the parameter(s) has to be set through : 1 = %rdi, 2 = %rsi, ... -> As for any function.
#
# Linking
#
# The program can be assembled as it is with :
      as PROGRAM.s -o PROGRAM.o
# But then it has to be linked STATICALLY to the used library.
# If not done, it will print an error message :
#    -> "undefined reference to 'FUNCTION-NAME'."
#
# Example :
      ld PROGRAM.o -static -lc -o PROGRAM
# Here, the program is statically linked ('-static') with the standard C library ('-lc').
# Arguments :
# - '-static' : tell the linker that the wish is to physically incorporate the library functions into the program.
# - '-lc' : tell the linker to link with the (standard) C library. '-lc' expands to 'libc.a' ('l' to 'lib').
#   	    The linker would look for 'libc.so' is we did use 'shared' library instead of 'static'.
#
# Whole example :
p# Link the program with C 'standard library' ('-lc' = C standard library) functions - in a static way.
# For other library, replace '-lc' by '-l*****' with '****' being the name of the library used (of diminutive of the later).
# WARNING : in case that the static library is not found, check whether it is installed and if it is, add its directory path to with the option '-L DIRECTORY-PATH' (or --library-path=DIRECTORY-PATH)
PROGRAM="NAME" ; as "$PROGRAM".s -o "$PROGRAM".o && ld "$PROGRAM".o -static -lc -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ; rm -rf "$PROGRAM".o "$PROGRAM" ;x

# Using the Standard C Library entry point
#
# Some 'C' functions require that certain setup functions have been run.
# WARNING : if such setup is not in place, functions needing it will make the program crash...
#
# Therefore, when linking a program to other libraries, it is common NOT TO DEFINE the '_start' in the program.
# Instead, 'main' is defined - and '_start' will get linked in from a separate library ...
# (called the 'C runtime library')
# that will perform al necessary 'C' library initialization.
#
# So, the changes with 'usual basic' programs will be that :
#     0. If needed, stack can be used within 'main' through the instructions 'enter' and 'leave' but this is not mandatory.
#     1. '.globl main' is written instead of '.globl _start'
#     2. 'main' symbol will be defined instead of '_start'
#     3. 'ret' is written at the end of 'main' as the 'main function is called from the standard C library (and therefore have to return).
#     3b. As 'main' is a function, anything that has to be returned has to be put within the '%rax' register.
#     4. No 'exit' syscall is required to finish the program. The standard C library will ensure the exit and will provide to it the value within the '%rax' register. 
#
# The program entry point will be 'main' and not anymore '_start' - '_start' will be the entry point of the 'C runtime library'.
# The process to do the linking between the program (on my part) and the 'C runtime library' is complex (and distribution specific) ...
# and it is better (and much more easier) to use a compiler directly.
# IMPORTANT :
#     - with 'gcc', the standard library is linked by default so no need to use '-lc')
#     - to add any other library, the '-lLIBNAME' option can be used
# One line command :
      PROGRAM="PROGRAM" ; gcc "$PROGRAM".s -static -o "$PROGRAM" && ./"$PROGRAM" ; echo $? ; rm -rf "$PROGRAM" ;
# IMPORTANT :
# 	- The '-static' option asks the compiler to physically add code from static library and this adds about 500 kilobytes to the final code size.
#	- Even if the final code size will be increased, IF the assembly program calls external C libraries, it is ALWAYS better to write assembly code using the 'main' entry point as it is tough to know which functions require the initialization code from the 'C runtime library'.

# Working with files
#
# The 'standard C library' has lots of functions making much more easy to write/read input/output of any kind.
#     For example, printing a number is tough because of the conversion between the number and its 'ascii' representation.
# To do so, the library needs a data structure (called 'FILE').
#
# Opening a file returns an 'opaque pointer' that represents the file.
# 'opaque pointer' means that the importance of what is pointed does not matter. What matters is the keep track of this pointer and to use it to refer to / work with the specific file.
# This pointer has then to be used / passed to other functions in order to work with the file.
# Its content is totally defined through the 'standard C library'.


# 'fopen' function
# 'fopen' open a file.
# 2 parameters :
#   %rdi : pointer to a string null terminated ('\0') which contains the filename relative to the current working directory.
#   %rsi : pointer to a string null terminated ('\0') representing the 'mode' in which the file should be opened.
    	   It can be :
	   - "r" (=read)
	   - "w" (=write)
	   - "a" (=append)
	   - "r+" for both reading and writting.
# Returned value in %rax : a pointer to a 'FILE' struct or the number '0' (=null pointer) if failures occur.
#
#
# 'fprintf' function
# 'fprintf' will write to a file.
# minimum 2 parameters :
# %rdi : pointer to a 'FILE' struct
# %rsi : pointer to a string formatted.
       	 Example : "My name is %s and I am %d years old."
       	 For each of the variable having to be replaced within the string formatted, an additional parameter is added just after.
	 In the above string example, the value of :
	    - '%s' (string) will be held within third argument '%rdx' as a pointer to a null terminated string
	    - '%d' will be held within the forth argument '%rcx' (as a number)
	 In fprintf needs more than the usual 6 function arguments, they have to be pushed on the stack and popped after the function - this is my responsibility.
# WARNING :
#     - As 'fprintf' is a variadic function, IF NO floating-point values are provided within the arguments, THEN '%rax' should be set to '0' BEFORE calling the function.
#     - When printing a char with '%c', its value has to be provided with 'mov' and not with 'lea' as for string '%s'. Then the 'fprintf' function will convert such value to the char it represents.
#
#
# 'fclose' function
# 'fclose' close the file after that no more use will be necessary.
# 1 parameter :
# %rdi : pointer to the 'FILE' struct
# 'fclose' ensures that all pending data to be written to the file is fully written out to disk.
# WARNING :
#    If a file stay opened without calling 'fclose', data could be lost when executing the program as some data could still need to be written when the program is finished
#    Therefore, such data is 'lost'.
# Returned value %rax : '0' if everything when well or a non-zero value else.

# Variadic functions
#
#     On functions taking a varying number of arguments (as long as wished) ...
#     IF NO floating-point values are provided within the arguments ...
#     THEN '%rax' should be set to '0' ...
#     BEFORE calling the function.

# stdin, stdout and stderr
#
# The 'C' library automatically creates pointers that contains the address (pointer to pointer) of 'FILE' structs called 'stdin', 'stdout' and 'stderr'.
# Therefore, they can be used as in :
# ('%rdi' is the first argument of all functions)
  movq stdout, %rdi
# IMPORTANT :
# 	- This is possible as long as the assembly file entry point is 'main' instead of '_start' and then linked with the 'standard C library'.
# 	- Those files must neither be opened or closed - the library does it.
#	- 'stdin', 'stdout' and 'stderr' are not the pointer to the 'FILE' struct. Instead, they contains the address where such pointer is. Therefore, 'stdout' is referred directly because we use its content and not its address (as with '$stdout'- which would be a wrong use of 'stdout')

# Reading data from a file
#
# 'fscanf' function.
# To read a file
# The argument of 'fscanf' are similar to 'fprintf'
# %rdi : pointer to 'FILE' struct
# %rsi : format string
# ...  : variable used into the format string
# IMPORTANT :
#     - As 'fscanf' reads the values, integers are passed as pointer (to value) AND NOT AS direct values.
#     - The variables used into the format string are pointer to where to hold such values.
#     	    IMPORTANT : scanning a char (%c) is similar to scanning a string (%s) as it will be considered as a pointer to byte(s) (1 for a char %c). 
# Example :
  	# First parameter
	movq stdin, %rdi
	# Second parameter represented by a string - therefore 'loading effective address' (='lea')
	leaq scan_format, %rsi
	# Save the address of where the inputs should be saved.
	# Those are pointer to pointer, this is why 'lea' instruction is used instead of 'mov'
	leaq LOCAL_OFFSET_NUMBER(%rbp), %rdx
	leaq LOCAL_OFFSET_EXPONENT(%rbp), %rcx
	# Set '%rax' to '0' as no floating-point number are used within those variadic function arguments.
	movq $0, %rax
	call fscanf
# IMPORTANT :
# When scanning stdin, it is important to notice that the buffer could still contain newlines from precedent 'string' scan as such scan does not send 'space' chars (newline, space, tab) as weell as with what was left after the first string - this case is special as it will be shown only if precedent scan was of 'scan format' '.ascii "%s\0"'.
# Therefore, the stdin buffer should be emptied with the below function BEFORE the scan.
# If not done, the scan could be disturbed by what was not scanned from precedent scans...
  clean_stdin_buffer:
	# This function scans each char of the 'stdin' buffer until it finds a newline or EOF.
	# Scan current char
	movq stdin, %rdi # fgetc : (from its 'man' page) reads the next character from stream and returns it as an unsigned char cast to an int, or EOF on end of file or error.
	call fgetc
	# Compare it to a few values to know whether continue scanning
	cmpq $10, %rax # Compare to newline = 10
	je buffer_cleaned	
	cmpq $-1, %rax # Compare to EOF = -1
	je buffer_cleaned
	# Scan next char
	jmp clean_stdin_buffer
  buffer_cleaned:	
	ret
# To call such function :
  call clean_stdin_buffer
#
#
# 'fgetc' function
# 'fgetc' read one char from a file an returns it in %rax
# one parameter :
# %rdi : pointer to 'FILE' struct
# It can be useful to empty buffers as in the below example with 'stdin'.
# IMPORTANT : for other buffer, the comparison with the null char would be necessary but not for 'stdin'.
  clean_stdin_buffer:
	# This function scans each char of the 'stdin' buffer until it finds a newline or EOF.
	# Scan current char
	movq stdin, %rdi # fgetc : (from its 'man' page) reads the next character from stream and returns it as an unsigned char cast to an int, or EOF on end of file or error.
	call fgetc
	# Compare it to a few values to know whether continue scanning
	cmpq $10, %rax # Compare to newline = 10
	je buffer_cleaned	
	cmpq $-1, %rax # Compare to EOF = -1
	je buffer_cleaned
	# Scan next char
	jmp clean_stdin_buffer
  buffer_cleaned:	
	ret
# Call the function emptying stdin buffer
  call clean_stdin_buffer


# 'C' types and their sizes
#
# Those sizes refer to a Linux 64-bit platform
#
#	char		8 bits signed integer		called a char because it is the same type used to store individual 'ASCII' characters
#	short		16 bits signed integer
#	int		32 bits signed integer
#	long		64 bit signed integer
#	long long	64 bits signed integer		This type exists because on 32-bit platform, it is also 64 bits.
#
# In order to set the above types to unsigned values, they have to be preceeded by the 'unsigned' qualifier.
#
# If a type ends with '*' -> It is a pointer.
#
#	struct		size depends on content		Lots of rules define how to store 'struct' type in memory - it is tough to summarize them here.


================================================================
ASSEMBLY DIRECTIVES
________________________________________________________________

# Reserve space for data 64, 32, 16 or 8 bits (= 8, 4, 2 or 1 byte(s))
#
# 64 bits
  .quad VALUE	  64 bits
  .8byte VALUE    64 bits
#
# 32 bits
  .long	VALUE    32 bits
  .int	VALUE    32 bits
  .4byte VALUE   32 bits
#
# 16 bits
  .word	VALUE    16 bits
  .hword VALUE   16 bits	'.hword' means 'half-word' but even so, it is the same size as a '.word'. Therefore, it is recommended NOT TO USE it in order to facilitate the code reading.
  .short VALUE   16 bits
  .value VALUE   16 bits
  .2byte VALUE   16 bits
#
# 8 bits 
  .byte	VALUE     8 bits
#
#
# Same for custom sizes
#
  .skip	NUMBER (, CONTENT)	'.skip' can take one OR two arguments. The second one is optional.
  				First argument  : The number of byte(s) to reserve.
				Second argument : The value to put in these reserved locations. By default, it will be '0'.
#			
  .space NUMBER			'.space' is as '.skip' but will fill the reeserved locations with spaces. Therefore, it takes only one argument that is the number of byte(s) to reserve.
#  
  .zero	NUMBER			'.zero' is as '.skip' but will fill the reeserved locations with '0'. Therefore, it takes only one argument that is the number of byte(s) to reserve.
#

# Characters
#
  .ascii "...(\0)"	'ascii' code characters.
  			They have to be within double quotes.
			Usually, such characters chain has to be ended by the null char '\0' in order to help function understanding where they finish.
# 
  .string "..."		'.string' is as '.ascii' but will automatically append a null char '\0' at the end.
  .asciz  "..."		'.asciz' is as '.ascii' but with the zero char ('\0') at the end (.asci'z' for zero)

# Code and data alignment
#
# Data alignment is about the start address of values in memory.
# The data has to be 'aligned' meaning that each value address has to be a multiple of a particular number - in order to use full speed from the :
# - physical organisation of memory
# - data buses
# - the CPU architecture
# - physical constraints of the processor
# For some instructions, if the data is not aligned (for example to a 16 bytes multiple), those will fail and trigger a fault or exception.
#
# In most computers, the speed issue are based on the word size of the computer.
# For a x86-64 Linux system, the word is 64 bits (8 bytes) long.
# But as some instructions use 16 bytes (128 bits) words and therefore such alignment of the 'stack' to a 16 bytes multiple is always (a good recommandation or) required.
#
# The GNU assembler provides alignment functions to manage such alignment.
# Each of those will force the alignment of the next address :
#
  .balign MULTIPLE		Next address will be aligned to the multiple of byte provided.
#
  .p2align POWER-OF-TWO		Next address will be aligned to the multiple of 2^POWER-OF-TWO provided.
  	   			Example : .p2align 3 # Means that next address will be aligned to a multiple of 2^3 bytes = 8 bytes.		
#
  .align NUMBER			This is NOT RECOMMENDED to be used.
  				For some configurations, it works like '.balign' (normal case), but for others, it works like '.p2align'.
				Therefore, to avoid such ambiguity, it is better not to use such directive.
# IMPORTANT :
# - When in a '.text' section, the alignment directives above will pad with 'nop' instruction.
#   -> The assembler has a few 'nop' instruction of different sizes and will chose the one that will best fill the gap.
#   -> Heavily used sections of code and 'jmp' targets will both benefit of being aligned.
# - When in other section, alignment will pad with the value '0'.


# Sections directives
#
  .section .text		This is for the code of the program.
  .text	   			As '.section .text' was used so much, a '.text' directive was created. It is equivalent to '.section .text'.
#
  .section .data		This is for the data of the program section.
  .data				As '.section .data' was used so much, a '.data' directive was created. It is equivalent to '.section .data'.
#
  .section .rodata		Same as the '.data' except that such data is READ-ONLY = cannot be modified.
				This is loaded into memory when the application is loaded.
				Attempts to write to this memory will result in the program aborting.
				# Example :
				  	.section .rodata
				my_read_only_data:
					.quad 7
				# The data contained at the address of 'my_read_only_data' is read-only and cannot be modified.
#
  .section .bss			This contains uninitialized data.
  	   			Rather to specify values within this section, the size of such (unknown at the advance) values will be specified.
				Such space can be reserved with the '.zero' or '.skip' directives.
				The operating system initialize the '.bss' section to all zeroes ('0').
				This saves space in the executable as it has not to be saved within it, especially if there is a lot of data within this section.
			 	# Example :
				  	.section .bss
				my_non_initialized_data:
					.zero 1000
				# Data will be available, beginning at the address of 'my_non_initialized_data' and will be initialized to zeroes '0'.
#
  .section .note.GNU-stack	This is a special section in 'ELF' (Executable and Linkable Format) files used to indicate whether OR NOT a program needs an executable stack.
  	   			It informs the linker and operating system about the stack's required permissions.
  	   			By default, if this section is missing, the stack is assumed to need executable permissions, which can be a security risk.
				IMPORTANT :
				- The recommandation is to add this section at the end of each assembly code file - however it is not mandatory for most assemblers.
				- Security Best Practices: Include it in all assembly files (as well as those that are linked with if any) as a good security practice, even if not explicitly required.
				- In most case, avoid non-executable stack is a good security practice. However, sometimes it is required to have it executable.
				Such section has three parameters:
				- Section Name: .note.GNU-stack
    				- Flags: Usually empty (""), indicating a non-executable stack
    				- Type: @progbits is the most recommended and usual case, specifying that the section contains data.
				  	Other types are available :
					- @progbits: Contains program data
					- @nobits: Occupies no space in the file (like .bss)
					- @note: Contains note information
					- @init_array: Contains constructors
					- @fini_array: Contains destructors
					- @preinit_array: Contains pre-constructors
					- @group: Defines a section group
					- @symtab: Contains a symbol table
					- @strtab: Contains a string table
					- @rela: Contains relocations with explicit addends
					- @rel: Contains relocations without explicit addends
					- @dynsym: Contains a dynamic symbol table
					- @gnu_versym: Contains version symbols
					- @gnu_verneed: Contains version requirements
				# Example of non-executable stack = common case :
				  .section .note.GNU-stack, "", @progbits
				# empty ("") : indicating a non-executable stack
				# @progbits : specifying that the section contains data
				#
				# Example of executable stack = special case
				  .section .note.GNU-stack,"x",@progbits
				# "x" for 'ex'ecutable
#
# Other sections are available but those ones are 'somewhat' internal to the system and are not useful to modify or mess with.


# Local and global values
#
  .globl SYMBOL			'.globl' stays for 'global symbol'.
  	   			A global symbol is relevant outside of the file it is defined.
				A global symbol is visible by all files.
				IMPORTANT : The recommandation is to place such directive before any code section to enhance code readability - however it is not mandatory for most assemblers.
#
  .global SYMBOL		'.global' is the same as '.globl'. It is only more specific about what it is : "glob'a'l" instead of "globl".
#
  .lcomm SYMBOL, SIZE_IN_BYTES	'lcomm' means 'local common' symbol. A local symbol will be visible ONLY (by default) through the use of the same file where it is defined.
  		 		'.lcomm' symbol is local by default BUT can be set as global if marked with the '.globl' directive.
				'.lcomm' takes two parameters :
  				First argument  : The name of the symbol.
				Second argument : The amount of space required.
				# Example :
				.lcomm my_variable_name, 8
				# This will reserve in memory a space of 8 bytes of which the beginning will be at the name (address) 'my_variable_name'.
#
  .comm	SYMBOL			'.comm' stays for 'common symbol'.
				'.comm' is like '.lcomm' but the linker will merge any symbol with an identical name to point to the same location.
				So even if such symbol is defined within several files, it will be common to all of them.
#
  .extern SYMBOL		The GNU assembler treats all undefined values as 'external'.
  				External means that it assumes that the linker will have another file defining and exporting such value with a '.globl' directive.
				The '.extern' directive does nothing on the GNU assembler - except that it allows to document which symbol will be used from other source.
				IMPORTANT : The recommandation is to place such directive before any code section to enhance code readability - however it is not mandatory for most assemblers.
				WARNING : On some Linux system, if compiling without 'gcc', such directive is sometimes '.external' instead of '.extern'.
#
# IMPORTANT :
# The GNU assembler treats all undefined values/symbols as 'external'. It assumes that the linker will be provided with another file defining and exporting them with the '.globl' directive.

# Including other code
#
  .include "FILENAME"		'.include' will INCLUDE the filename (put within double quotes) into the source code, as if is was copied/pasted.
  	   			It is useful to share several symbol names and values between files with a list of '.equ' directives.
				Usually, such included file does not contain any code or data at all.
				IMPORTANT :
				-> None of the symbol defined within such included file should contain '.globl' or code.
				-> A '.globl' directive will cause issue when files are linked, as multiple assembly sources would be including the same externally facing definitions.
#
  .incbin "BINARY_FILENAME"	Same as '.include' but for a binary file.
  	  			This is useful to embedded an image into the final object file.
				# Example :
				  	  .section .data
				my_image:
					.incbin "my_image.png"
				# The image 'my_image.png' will be embedded within the final object file and can be reached at the address of 'my_image' symbol.

# Annotate code
#
# Annotate is useful for debugging mainly.
#
  .type SYMBOL, TYPE	'.type' tells the linker what kind of '.globl' symbol it is.
  			Therefore, all SYMBOLs used with such directive have to be also marked as '.globl'.
			There are two parameters :
			First  : The symbol name marked as '.globl'.
			Second : The type that can be either '@function' for a function or '@object' for data.
			# Example :
			# Mark as global both the variable (data) and the function.
			.globl my_variable, my_function
			# Tells the debugger what such symbol is.
			.type my_variable, @object 
			.type my_function, @function
			# Defining the symbols
			  	   .section .data
			my_variable:
				.quad 0
				   .section .text
			my_function:
				# Function code ...
				ret
#
  .cfi_...		Within functions, a set of directives known as 'CFI' (=control flow integrity) directives describe to debuggers (and other tools) the intended flow of the program.
 			They start with '.cfi_'.
			Such directives are used by debuggers to provide more information about the state of the program at any given point.
			They are also used by security tools to verify the content of the code.
			Usually, such directives are inserted by compilers for adding context to assist debuggers and profilers.
			They are rather too complicated to be managed by programmers BUT there are a lot within the assembly language code generated by 'gcc'.


================================================================
DYNAMIC MEMORY ALLOCATION
________________________________________________________________

# Virtual memory
#
# All the remarks below are relative to Linux processes.
#
# Processes and memory
#
# In order to protect programs from other programs thay may have bugs or go rogue, each process is provided with memory addresses and appears to be alone in memory (for him).
# Memory is arranged into physical blocks called 'pages'.
# When a process runs, the OS provide the program a number of memory pages and marks what address they will live at for the process.
# All memory addresses provided that way are virtual because they do not represent the real physical memory addresses.
# All memory (virtual) addresses that a process knows are called 'address space'.
# The kernel maps the virtual addresses to the physical ones onto the physical RAM or to disk space (=swap space).
# A virtual address just after another does not has to be next to the physical one - a lot of space can separate them - but the process does not know it.


# Pages on swap spaces
#
# The OS can map some of the pages provided to a process into 'swap space' and then marks those as 'nonexistent'.
# When a process tries to access such pages within the 'swap space', it triggers an error in the OS.
# Then the OS understands that those pages were in swap space, suspends the program while it moves the memory from disk (swap space) into physical RAM.
# Once done, such memory pages are re-mapped to the process's 'address space' and the program is re-started at the instruction that caused the error before - and will now suceed.


# Memory layout of a Linux Process
#
# From higher addresses to lower addresses :
# - UNMAPPED MEMORY and kernel shared memory (inaccessible)
# - The stack
# - UNMAPPED MEMORY
# - Dynamically loaded libraries
# - UNMAPPED MEMORY
# - The heap	- section of memory that can be continually grown throughout the lifetime of a program.
# - UNMAPPED MEMORY
# - Uninitialized data area ('.section .bss')
# - Global program data ('.section .data')
# - Read-only data ('.section .rodata')
# - The program itself ('.section .text')
# - Reserved kernel memory (inaccessible)
# IMPORTANT :
# 	- 'UNMAPPED MEMORY' areas contain a huge number of memory addresses - those does not point to any physical address.
#	- The kernel use those to randomize the address space a little bit in order to make it harder for hackers to know IN ADVANCE where everything is.
#	- If a program tries to access to 'UNMAPPED MEMORY' or the 'reserved kernel memory', it will crash.
#	     -> For 'UNMAPPED MEMORY', it is due to address pointing to nowhere real (no physical memory location).
#	     -> For the 'reserved kernel memory', it is due to trying to access memory off-limits.
#
# Even if x86-64 could provide a huge space with 64 bits addresses, it is actually limited to 47 bits (still huge).
# That represents 128 terabytes of data - much more than the real physical addresses available.
# By default, Linux only gives to a process the minimal amount needed for the code, data, stack and some extra room for operating system-related items.
# Any additional memory must be requested to be mapped in to the process.


# Allocate additional memory
#
# A program can ask the OS for more memory if required.
# Then the OS will check that there are sufficient memory ressources available within RAM and swap space.
# If there are enough of those, the OS will add additional valid addresses to the address space.
#
# The 'program break' is the point at which memory addresses are no longer valid.
# It can be moved by requesting more memory from the OS.
#
# Memory management is a huge area of interest for computer programmers and computer language designers.
# It is tough to design a system that is both easy for programmers to use and fast for language and library designers to implement.
# In the 'standard C library', two core functions manage memory : 'malloc' and 'free'.
#
# 'malloc' function
# 'malloc' means 'memory allocate' and requests the OS for more memory.
# If there is enough memory available within the process requesting it, 'malloc' will return it.
# Else, it will ask the 'OS' for more memory and if there is enough available, the OS will move the program break.
# In real case, 'malloc' have to allocate more than just the space requested. It has to prepend the space by a header containing
# - the flag of the block availability (example : 0 = available, 1 = unavailable)
# - the size of the block (size requested + header size)
# One parameter :
# %rdi = the amount of memory needed
# 'malloc' returns the address of memory requested within %rax.
#
#
# 'free' function
# 'free' is used to return the memory allocated with 'malloc' when finished with it.
# It does not actually return it to the 'OS' but instead, marks it as 'free' so that a future 'malloc' can use it (again).
# One parameter :
# %rdi = the address of memory requested by 'malloc' to be freed.
# 'free' does not return anything.
#
#
# IMPORTANT RULES FOR 'malloc' and 'free'
# 1. Always free any memory allocated with 'malloc'.
#    	    -> Else it will cause a 'memory leak' : memory requested is not freed and cannot be re-used.
#	    -> All memory gets disposed (freed) when a program exits.
#	    -> So, in exceptional cases, no need to 'free' a memory allocated by 'malloc' if the plan if the keep such memory until the end of the program - but this is not recommended.
# 2. Never use a pointer after having called 'free' on it.
#    	    -> If using such pointer, two issues could occur :
#	       - access to an invalid memory region
#	       ... AND/OR
#	       - overwrite data that gets allocated at a later time.
# 3. Never call 'free' on a pointer that was not allocated with 'malloc'.
# 4. Never call 'free' more than once on a pointer.
#
#
# A 'buffer' is a temporary, usually fixed-length storage location.

# Buffer overflow and stack overflow
#
# In the below code example, the scan format was a string which means anything provided until reaching a space or tab.
# The scan_format "%499s\0" precise the maximum length of the buffer were the string will be held that is :
# - 499 characters maximum (else than space/tab)
# - a null char
# For a total of 500 chars.
#
# 'fscanf' is provided an address were to save the input corresponding to the 'scan_format'
# However, it is not provided the size of the input. It has to be precised within the scan_format, here "%499s\0".
# It the maximum size of the input was not provided, a user could provide more chars than requested, even if it goes beyond the buffer end.
# This is known as a 'buffer overflow'.
# In the case than the buffer was allocated on the stack, it would be a 'stack overflow'.
#
# Such issue cause problems because a function (here 'fscanf') overwrite memory that does not belong to it.
# In the best case, this cause a 'fault'. In a worse one, it corrupts data and it will be MAYBE discovered later.
# But in the worst one, such overflow could be exploit as a security breach. For example, the attacker could modify a return address to cause the program execute their code.
#
# Code example :
	.section .data
#...
scan_format:
	# A string of maximum 499 chars + null char = 500
	.ascii "%499s\0"
#...
	.section .text
main:
...
	# Read data from stdin and write it to the buffer
	movq stdin, %rdi
	leaq scan_format, %rsi
	# Save what is written at the buffer address
	movq LOCAL_OFFSET_BUFFER(%rbp), %rdx
	# No floating-point argument with variadic function.
	movq $0, %rax
	call fscanf


# 'brk' system call (12)
# 'brk' means break and require the OS to move the 'program break' to a specific address OR to return the current break.
  movq $12, %rax # Set the system call number.
# One parameters :
# %rdi = address wished for the 'program break' or '0'
# Returned value within %rax : the pointer to the new address of the 'program break' (if such pointer was provided within %rdi) or the current 'program break' if '0' was provided.


# 'mmap' system call (9)
# 'mmap' means 'memory map'.
# 'mmap' is used to requested large blocks of memory from the OS.
# 'mmap' and 'brk' should not be used for the same usage :
# - 'mmap' request allocation in 'page-size' increments - that is a multiple of 4096 bytes (=1 page, on Linux x86-64) - which is much higher than usual requested allocation from 'brk'.
# - 'mmap' allow to request other size than 'page-size' increments but the final allocation will be rounded up to 'page-size' increments so it is better to ask such size (multiple of 4096 bytes) directly.
# - 'brk' asks for specific memory locations VS The address returned by 'mmap' is determined by the Linux kernel itself.
# - Linux allows to request an address (optional) but can override this later.
# 'mmap is extremely flexible and can ask for memory AS WELL AS to treat a file as if it was just memory.
# In the case that 'mmap' works with a file, the 'OS' will cause a region of memory to act as a the file itself. It can then read/write such file through this region.
# Set mmap syscall number :
  movq $9, %rax
# Parameters :
# %rdi = pointer to requested target address.
       -> If a specific address is provided, Linux can override it.
       -> To be left to '0' (null ptr) to let Linux choose the address.
# %rsi = Length of allocation in bytes
       -> Recommendation : Set it to a multiple of 4096 bytes as Linux will in all case round it up to such multiple.
# %rdx = Protection flags
       -> 0x01 = read-only
       -> 0x03 = read + write
       -> Other options are available => See 'man mmap'.
       -> The flags can be combined.
# %r10 = General flags
       -> There are a lot of flags available. => See 'man mmap'.
       -> For most purpose, set the flag 'MAP_PRIVATE' = 0x02
       -> It the allocation is not based on a file, set the flag 'MAP_ANONYMOUS' = 0x20
       	     'MAP_ANONYMOUS' tells Linux to ignore the file descriptor and just allocate more memory.
       -> Combining 'MAP_PRIVATE' and 'MAP_ANONYMOUS' would give = 0x22
       -> The flags can be combined.
# %r8  = File descriptor
       -> If mapping a file into memory, set to the file descriptor returned from 'fopen'.
       -> Else, set it to '-1' and set the flag 'MAP_ANONYMOUS' within the general flags (%r10).
# %r9  = Offset
p       -> Only if mapping a file into memory and if using an offset to tell Linux where the file start.
       -> Set to '0' if starting at the beginning of the file OR not mapping a file.
# Returned value within %rax : pointer to address of the requested allocation OR '-1' in case of failure.
#
# Example :
  movq $9, %rax		# Set system call number to mmap (=9)
  movq $0, %rdi 	# Let Linux choose the address of the allocation.
  movq $8192, %rsi 	# Request a length of two pages (2 pages * 4096 bytes = 8192 bytes)
  movq $0x03, %rdx 	# Set protection flags (=file open mode) to 'read + write'.
  movq $0x22, %r10 	# Set the general flags to 'MAP_ANONYMOUS' (=no file used) and 'MAP_PRIVATE'
  movq $-1, %r8 	# No file descriptor is provided as no file will be mapped.
  movq $0, %r9		# No offset is required as no file will be mapped.
  syscall
# The result will be in %rax.


# 'munmap' system call (11)
# 'munmap' means memory unmap.
# It is used to unmap to memory allocation obtained through 'mmap' system call.
# Two parameters :
# %rdi = pointer to memory address to unmap
# %rsi = size of allocation to unmap


================================================================
NEXT SECTION TO BE WRITTEN...
________________________________________________________________

