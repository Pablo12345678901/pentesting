================================================================
QUESTIONS
________________________________________________________________

-


================================================================
MISCELLANEOUS
________________________________________________________________

# This is a comment that begins with '#'

# Useful command to assembly the code of the current program and run it :

  PROGRAM="NAME" ; as "$PROGRAM".s -o "$PROGRAM".o && ld "$PROGRAM".o -o "$PROGRAM" && rm -rf "$PROGRAM".o && ./"$PROGRAM" ; echo $? ; rm -rf "$PROGRAM" ; 

# Detail :
# as -> assembly instructions.
# ld -> link to produce binary executable file.
# rm -rf -> remove files created during partial compilation.
# echo $? -> checks everything went well.


================================================================
BASIC CODE
________________________________________________________________
	
# Anything starting with a dot is an instruction to the assembler.
# '.globl' tell the assembler that the symbol '_start' should not be discarded after the assembly process is over as it is the case by default.
.globl _start  # _start is a special symbol used as 'entry point' to the program.

# Another command to the assembler.
.section .text

# DEFINING THE VALUE OF THE _START SYMBOL
#
_start: 

    # PREPARATION OF THE SYSTEM CALL NUMBER FOR FURTHER CALL LATER.
    #
    # movq = move quadword -> quadword = 8 bytes (64 bits)	
    # Here, move the value 60 into the register named '%rax' -> the 64-bit-register.
    # $60 means that we treat 60 as a value not an address.
    # The number 60 is the system call number of the command to run.
    # the number 60 is the 'exit' system call.
    #
    movq $60, %rax # -> Moving a syscall number (here=60) to %rax does not make the call. It has to be lauched by 'syscall' command.
	
    # SET VALUE USED WITHIN SYSTEM CALL.
    #
    # Set the exit code to a number 0-255.
    # movq 1000, %rax -> This provokes 'Segmentation fault' due to non compliant access to memory. 
    # In the system call definition of 'exit', '%rdi' holds the exit status of the program. It is a kind of return value.
    # By default = 0 , if the below instruction was not existing.
    #
    movq $33, %rdi # Set exit code. Could be $0, ... $255.

    # Re-set good exit code.
    #
    movq $0, %rdi 

    # If there is a typo in an instrcuction, this message appears :
    # Error: no such instruction: `mo $0,%rdi'
    # As if uncomment the below line.
    # mo $0, %rdi # 'mo' instruction is not defined, what generate an error.
	
    # PEFORM SYSTEM CALL
    # This gives Linux Kernel the order of syscall.
    # For the syscall, the order of the register configuration ('%rax' before '%rdi' or the reverse) does not matter.
    # We could have written the movq to the '%rdi' register (destination) before the 'movq' to the '%rax' register.
    #
    syscall
    # If the syscall is not done, A 'Segmentation fault' error is generated.	


================================================================
ARITHMETIC
________________________________________________________________

# Addition :
# This adds '%rax' to '%rdi' and store the result into '%rdi'
addq %rax, %rdi

# Substraction
subq %rax, %rdi
________________________________________________________________

# Incrementation (+=1)
# No source needed as the incrementation is +1
incq DESTINATION

# Decrementation (-=1)
# No source needed as the decrementation is -1
decq DESTINATION
________________________________________________________________

# WARNINGS FOR MULTIPLICATION AND DIVISION
#	- For multiplication and division, the destination is assumed to be '%rax', so only need to precise which is the source.
# 	- The source cannot be a number, it has to be a register or memory location.

# Multiplication
# The final result will be held into '%rax'
# So no need for destination, only source
mulq SOURCE

# Division
# Similar to multiplication, final result will be held into '%rax'
# But the remainer is stored in the '%rdx' register which should be set to zero before the instruction occurs.
divq SOURCE


================================================================
REGISTERS
________________________________________________________________

%rax = the accumulator, because usually used for mathematic instructions.

     -> Historically, '%ax' was helding 16 bits
     %ax = accumulator
          %ah = most significant 8 bits of %ax
     	  %al = least significant

      -> Then when it was extended to 32 bits as '%eax'
      %eax = extended accumulator

      -> Then when it was extended to 64 bits as '%rax'
________________________________________________________________

Those registers can still be used :

%rax = 64 bits = the whole
%eax = 32 bits = the least significant 32 bits of %rax
%ax  = 16 bits = the least significant 16 bits of %rax (and of %eax)
%ah =   8 bits = the most significant 8 bits of %ax
%al =   8 bits = the least significant 8 bits of %ax (and of %ax, %eax, and %rax)

# Schema of bit arrangment depending on registers :

1111111111111111111111111111111111111111111111111111111111111111 = %rax = 64 bits

--------------------------------11111111111111111111111111111111 = %eax = 32 bits

------------------------------------------------1111111111111111 = %ax  = 16 bits

------------------------------------------------11111111-------- = %ah  =  8 bits

--------------------------------------------------------11111111 = %al  =  8 bits
________________________________________________________________

# x86_64 has 16 general purpose registers
# 	 8 from the 32-bit architecture
# Those 8 are divided into two classes :

# 4 Computational registers :
#
# - %rax, %rbx, %rcx and %rdx.
# Then can be used as general purpose register, meaning for computation as well as for their specific purpose (see below).
#
# All of those above registers can be divided into less bit containing register as done with '%rax' above.
#
# For example, '%rcx' can become :
  %rcx = 64 bits
  %ecx = 32 bits
  %cx  = 16 bits
  %ch  =  8 most significant bits
  %cl  =  8 least significant bits
#
# But those can also have specific purposes.
#
# Specific purposes :
  %rax = the accumulator, general-purpose register for computation.
  %rbx = the base register, often used for indexed addressing.
  %rcx = counter register, counter during repetitive code as loops.
  %rdx = data register,
       has some special meaning in :
       - certain arithmetic operations
       - input/ouput coordination
       - coordination with '%rax' as with the 'divq' instruction where is held the rest of division.

# 4 Memory address registers
#
# - %rsi, %rdi, %rbp and %rsp.
#
# '%rsi' and '%rdi' can be used for computation as well as specific usage.
# But '%rbp' and '%rsp' has to be left for ONLY specific usage (to be pointers).
#
# Specific usage :
  %rsi = source index register - has special when working with longer spans of memory.
  %rdi = destination index register - often used in conjunction with '%rsi' for working with longer spans of memory.
  %rbp = base pointer
  %rsp = stack pointer
#
# For those register, there are a 16 bits and 32 bits version but not 8 bits (1 byte) available.
# For example :
  %rdi = 64 bits	
  %edi = 32 bits
  %di  = 16 bits
# But there are neither '%dh' nor '%dl' available.
#

# x86_64 has 8 more general purpose registers :
#
# It start at index 8 (the 9th register) to index 15 (the 16th register)
  %r8
  ...
  %r15
#
# Those registers have also 32 and 16 bits version.
#
# Example with '%r11'
  %r11  = 64 bits (all)
  %r11d = 32 bits (least significant) -> 'd' as in 'double-word' (or long)
  %r11l = 16 bits (least significant) -> 'w' as in 'word'
  %r11b = 8 bits (least significant) -> 'b' as in 'byte'

# Special-purpose registers
  %rip = instruction pointer that points to the next memory location the CPU is going to process an instruction from
  %eflags = contains flags about result of precedent operation
  	  ZF = zero flag = set to '1' if result of last ARITHMETIC operation was 0, set to '0' if it was different.
	  CF = carry flag = set to '1' if the result of the last arithmetic operation was a 'carry', that is the result was bigger and could not be held in the destination register.

# Example of memory access
#
.globl _start
# 1. Set memory data
.section .data
NAME-OF-MEMORY-PLACE:
	.quad VALUE1, VALUE2, VALUE3
	# The type of the memory content can be .quad, .double, .word, byte.
# 2. Access memory data
.section .text
_start:
	movq $NAME-OF-MEMORY-PLACE, %rbx
	# The '$' means load immediate value, so here the address and not the content of the memory place.

	# Get the address value content with '(...)'
	movq (%rbx), NEW-REGISTER-FOR-VALUE1
	# Move the address of 8 bytes (for a .quad, it would be different for other type
	addq $8, %rbx

	# Load the value of the next memory space.
	movq (%rbx), NEW-REGISTER-FOR-VALUE2

================================================================
NUMBER FORMAT
________________________________________________________________

# Write binary number
# With '0b'
# Exemple
$10 # This is the value '10' in decimal
$0b10 # Refers to binary value of '10' = 2
#
# We can write binary number from 0 up to 255.
# If the number is higher, there are chances that the function using the register will only consider the 8 last (least significant) bits.


================================================================
SIZES
________________________________________________________________

# In 'addq', 'movq'
# The 'q' refers to the size 'quadword'
# The standard size of a value in an architecture = 'word'
#
# Available sizes :
q = quadwords			= 64 bits
l = double-words (longs) 	= 32 bits
w = words 	 		= 16 bits
b = individual bytes 		= 8 bits

# Existing instructions with 'mov'
#	movb =  8 bit-chuncks (1 byte)
# 	movw = 16 bit-chuncks (2 byte)
#	movl = 32 bit-chuncks (4 byte)
# 	movq = 64 bit-chuncks (8 byte)
#
# movq has two operands, kind of 'movq(source, destination)'
# The source can be :
# 	  - a register
#	  - a memory address
#	  - value (as here '60')
# Here, the destination is a register '%rax' ('%Rax' for 'Register')

# Example of customization :
# Moving a single byte (of value 5) into the %ah register
movb $5, %ah


================================================================
MEMORY
________________________________________________________________

# Add a memory section for data :
  .section .data

# Set values by precising size in memory (below : '.byte') and value ('4).
first_value:
	.byte 1
second_value:
	.word 3
third_value:
	.long 4
final_result:
	.quad 0
#
# Load values by calling the memory address
	movb first_value, %bl # '%rbx' 
	movw second_value, %cx # '%rcx'
	movl third_value, %edx # '%rdx'
#
# Store value in memory
  	movl %ecx, final_result

# IMPORTANT remark about MOV
# for the 'mov(b/w/l/q)' instruction, only one, but not both operands of any instruction can be a memory location.
# So in order to use the addresses, they have to be loaded into registers.
#
# Example :
# As movq only support one address maximum in its arguments,
# movq ARG1, ARG2 => Either ARG1 or ARG2 can be a memory location but not both.
# So we can not manipulate data without at least one register.
# Writing 'movq ADDRESS_REF_1, ADDRESS_REF_2' is wrong.
# Example where '(first|second)_value' are memory location of kind 'first_value: \n\t.quad NUMBER'.
	movq first_value, %rdi
	addq second_value, %rdi

	# Exit system call
	movq $60, %rax
	syscall

# Array
simple_array:
	.quad 1, 2, 3
#
# Accessing the array by getting address of first element
# '$' refer to immediate value, which is the address to which point the pointer 'simple_array'
# '%rdi' is a register to hold the address
     movq $simple_array, %rdi
#
# Get the first element with '(ADDRESS)'
     movq (%rdi), %rax
#
# Move the pointer to next array element by adding X bytes to the pointer.
# IMP : The number of byte has to correspond to the type of the memory accessed (8 bytes here, for the '.quad' array 'simple_array').
addq $8, %rdi # would be 1 for '.byte', 2 for '.word', 4 for '.long' (=double-word)

# Different ways of accesing memory
  immediate mode with '$' in front of it
	  # example :
	  movq $60, %rax
	  # '60' is accessed as an immediate value that is, the value is contained into the instruction itself.
  register mode with '%' in front of it
  	   # example :
	   movq $60, %rax
	  # '%rax' is accessed as a register to find or store a value.
  direct memory mode when referring to a value by its address.
  	  # example :
	  simple_value:
		.quad 3
	  (...)
	        movq simple_value, %rax
	        # Here, 'simple_value' is the address of the .quad of value '3'. It redirects to this value.
  register indirect mode
  	   # example
	   simple_value:
		.quad 3
	  (...)
	        movq $simple_value, %rdi
		movq (%rdi), %rax
		# Here, '%rdi' contains the address of 'simple_value' (accessed with immediate mode '$') and we access to its value by register indirect mode.
		# 'register indirect mode' is used to access the content located at a memory address (here held in '%rdi').
#
# There are other modes existing.
       
	



================================================================
CONDITIONAL INSTRUCTIONS, COMPARISON BRANCHING AND LOOPING
________________________________________________________________

# Basic jump with 'jmp' to a specific instruction.
  jmp NAME-OF-MEMORY-PLACE = jump to the instruction called 'NAME-OF-MEMORY-PLACE'

# Jumps based on result of precedent arithmetic operation and corresponding FLAGS
# See also the 'registers' section.
  jz MEMORY-PLACE = jump if zero flag is set (=1) (last arithmetic operation resulted in '0'
  jnz MEMORY-PLACE = jump if zero flag is NOT set (=0)
  jc MEMORY-PLACE = jump if carry flag is set (=1)
  jnc MEMORY-PLACE = jump if carry flag is NOT set (=0)

# Jump depending on comparison
#
# COMPARISONS
# Compare two numbers to check if there is one that is greater, lower or if they are equal.
  cmpb = for single byte
  cmpw = for word
  cmpl = for double-word
  cmpq = for quadword
#
# Example
cmpq ARG1, ARG2
#
# The jump is comparing SECOND argument to FIRST (it does not seems to be natural).
    je = jump if equal
    jne = jump if not equal
    ja = jump if ARG2 is above ARG1
    jae = jump if above ARG2 or equal ARG1
    jb = jump if ARG2 below ARG1
    jbe = jump if ARG2 below or equal ARG1

# Others conditional instructions
#
# Conditions code : 'e', 'ne', 'a', 'ae', 'b', 'be' -> refer to above with 'je' (...).
#
# There are other conditions code as :
  'g' : greather than
  'ge' : greather or equal
  'l' : lower than
  'le' : lower or equal
#
# CMOV move only if the conditions is respected.
# syntax : cmov(CONDITIONS-CODE)(TYPE-OF-OPERATION) REGISTER-OR-MEMORY-LOCATION-1, ONLY-REGISTER-ACCEPTED
# The cmov (conditional move) instructions in x86_64 assembly have specific requirements for their operands.
# Important : 'cmov' instruction does not support immediate value (as numbers) in its arguments.
# The destination operand must be a register, and the source operand must be either a register or a memory location.
# As a consequence, immediate values (like $255 or $0) are not allowed as source operands for cmov instructions.
#
# Example
  cmovgeq %rax, %rbx
# Decomposition :
# 'c' - 'mov' - 'ge' - 'q'
# depending on precedent comparison 'c'
# will move 'mov'
# if precedent comparison resulted is ARG2 greater or equal ('ge') than ARG1.
# and operation type is 'quadword' = 'q'.
#
# LOOP will decrement (-1) '%rcx' and jump to the specified label if the result of decrement is not 0.
# Basic usage :
loopq LABEL-TO-JUMP-IF-RCX-IF-NOT-ZERO
# Variants
  loopeq LABEL-TO-JUMP-IF-EQUAL -> jumps if zero flag is set to '1' (see '%eflags').
  loopneq LABEL-TO-JUMP-IF-NOT-EQUAL -> if zero flag is not set to '1' (see '%eflags').

================================================================
SYSCALLS SYNTAX
________________________________________________________________

# Syntax of syscall on x86_64 architecture
# (This a convention)
    rax: syscall number
    rdi: first argument
    rsi: second argument
    rdx: third argument
    r10: fourth argument
    r8: fifth argument
    r9: sixth argument
# Example :
# ...
  # Exit with code
  # '%rax' : Syscall number 60 = exit :
  movq $60, %rax
  # '%rdi' : Setting the first argument of exit syscall to 33.
  movq $33, %rdi
  # SYSCALL : calling exit ('%rax') with code of 33 ('%rdi').
  syscall
  

================================================================
LIST OF SYSCALLS AVAILABLE ON LINUX x86_64
________________________________________________________________

# Sorted by syscall number

=========================================================================================
| Syscall Number | Syscall Name      | Description                                      |
|----------------|-------------------|--------------------------------------------------|
| 0              | read              | Read from a file descriptor                      |
| 1              | write             | Write to a file descriptor                       |
| 2              | open              | Open a file                                      |
| 3              | close             | Close a file descriptor                          |
| 4              | stat              | Get file status                                  |
| 5              | fstat             | Get file status                                  |
| 6              | lstat             | Get file status                                  |
| 7              | poll              | Synchronous I/O multiplexing                     |
| 8              | lseek             | Reposition read/write file offset                |
| 9              | mmap              | Map files or devices into memory                 |
| 10             | mprotect          | Set protection on a region of memory             |
| 11             | munmap            | Unmap files or devices from memory               |
| 12             | brk               | Change data segment size                         |
| 13             | rt_sigaction      | Examine and change a signal action               |
| 14             | rt_sigprocmask    | Examine and change blocked signals               |
| 16             | ioctl             | Control device                                   |
| 17             | pread64           | Read from a file descriptor at a given offset    |
| 18             | pwrite64          | Write to a file descriptor at a given offset     |
| 19             | readv             | Read from multiple buffers                       |
| 20             | writev            | Write to multiple buffers                        |
| 21             | access            | Check user's permissions for a file              |
| 22             | pipe              | Create pipe                                      |
| 23             | select            | Synchronous I/O multiplexing                     |
| 24             | sched_yield       | Yield the processor                              |
| 25             | mremap            | Remap a virtual memory address                   |
| 26             | msync             | Synchronize a file with a memory map             |
| 27             | mincore           | Determine whether pages are resident in memory   |
| 28             | madvise           | Advise about use of memory                       |
| 29             | shmget            | Get a System V shared memory segment identifier  |
| 30             | shmat             | Attach a shared memory segment                   |
| 31             | shmctl            | System V shared memory control operations        |
| 32             | dup               | Duplicate a file descriptor                      |
| 33             | dup2              | Duplicate a file descriptor                      |
| 34             | pause             | Wait for a signal                                |
| 35             | nanosleep         | High-resolution sleep                            |
| 39             | getpid            | Get process ID                                   |
| 40             | sendfile          | Transfer data between file descriptors           |
| 41             | socket            | Create an endpoint for communication             |
| 42             | connect           | Connect a socket                                 |
| 43             | accept            | Accept a connection on a socket                  |
| 44             | sendto            | Send a message on a socket                       |
| 45             | recvfrom          | Receive a message from a socket                  |
| 46             | sendmsg           | Send a message                                   |
| 47             | recvmsg           | Receive a message                                |
| 48             | shutdown          | Shut down part of a full-duplex connection       |
| 49             | bind              | Bind a name to a socket                          |
| 50             | listen            | Listen for connections on a socket               |
| 51             | getsockname       | Get socket name                                  |
| 52             | getpeername       | Get name of connected peer                       |
| 53             | socketpair        | Create a pair of connected sockets               |
| 54             | setsockopt        | Set options on sockets                           |
| 55             | getsockopt        | Get options on sockets                           |
| 57             | fork              | Create a child process                           |
| 59             | execve            | Execute a program                                |
| 60             | exit              | Terminate the calling process                    |
| 61             | wait4             | Wait for process to change state                 |
| 62             | kill              | Send a signal to a process                       |
| 63             | uname             | Get name and information about current kernel    |
| 64             | semget            | Get a System V semaphore set identifier          |
| 65             | semop             | System V semaphore operations                    |
| 66             | semctl            | System V semaphore control operations            |
| 67             | shmdt             | Detach a shared memory segment                   |
| 68             | msgget            | Get a System V message queue identifier          |
| 69             | msgsnd            | Send a message to a System V message queue       |
| 70             | msgrcv            | Receive a message from a System V message queue  |
| 71             | msgctl            | System V message control operations              |
| 72             | fcntl             | Manipulate file descriptor                       |
| 73             | flock             | Apply or remove an advisory lock on an open file |
| 75             | fdatasync         | Synchronize a file's in-core state with storage  |
| 77             | ftruncate         | Truncate a file to a specified length            |
| 78             | getdents          | Get directory entries                            |
| 79             | getcwd            | Get current working directory                    |
| 80             | chdir             | Change working directory                         |
| 81             | fchdir            | Change working directory                         |
| 82             | rename            | Rename a file                                    |
| 83             | mkdir             | Create a directory                               |
| 84             | rmdir             | Remove a directory                               |
| 85             | creat             | Create a file                                    |
| 86             | link              | Create a hard link                               |
| 87             | unlink            | Delete a name and possibly the file it refers to |
| 88             | symlink           | Make a new name for a file                       |
| 89             | readlink          | Read value of a symbolic link                    |
| 90             | chmod             | Change permissions of a file                     |
| 91             | fchmod            | Change permissions of a file                     |
| 92             | chown             | Change owner and group of a file                 |
| 93             | fchown            | Change owner and group of a file                 |
| 94             | lchown            | Change owner and group of a file                 |
| 96             | umask             | Set file mode creation mask                      |
| 97             | gettimeofday      | Get time                                         |
| 98             | getrlimit         | Get resource limits                              |
| 99             | getrusage         | Get resource usage                               |
| 100            | sysinfo           | Get system information                           |
| 101            | ptrace            | Process trace                                    |
| 102            | getuid            | Get user ID                                      |
| 104            | getgid            | Get group ID                                     |
| 104            | setitimer         | Set value of an interval timer                   |
| 105            | setuid            | Set user ID                                      |
| 106            | setgid            | Set group ID                                     |
| 107            | geteuid           | Get effective user ID                            |
| 107            | getitimer         | Get value of an interval timer                   |
| 108            | getegid           | Get effective group ID                           |
| 109            | setpgid           | Set process group ID                             |
| 110            | getppid           | Get parent process ID                            |
| 110            | reboot            | Reboot the system                                |
| 111            | getpgrp           | Get process group ID                             |
| 112            | setsid            | Create a session and set the process group ID    |
| 113            | setreuid          | Set real and effective user IDs                  |
| 114            | setregid          | Set real and effective group IDs                 |
| 114            | waitid            | Wait for process to change state                 |
| 115            | getgroups         | Get list of supplementary group IDs              |
| 116            | setgroups         | Set list of supplementary group IDs              |
| 117            | setresuid         | Set real, effective and saved user ID            |
| 118            | getresuid         | Get real, effective and saved user ID            |
| 118            | fsync             | Synchronize a file's in-core state with storage  |
| 119            | setresgid         | Set real, effective and saved group ID           |
| 120            | getresgid         | Get real, effective and saved group ID           |
| 121            | getpgid           | Get process group ID                             |
| 122            | setfsuid          | Set user ID used for file system checks          |
| 123            | setfsgid          | Set group ID used for file system checks         |
| 124            | getsid            | Get session ID                                   |
| 127            | rt_sigpending     | Examine pending signals                          |
| 128            | rt_sigtimedwait   | Synchronously wait for a signal                  |
| 129            | rt_sigqueueinfo   | Queue a signal and data                          |
| 130            | rt_sigsuspend     | Wait for a signal                                |
| 132            | sigaltstack       | Set and/or get signal stack context              |
| 133            | mknod             | Create a special or ordinary file                |
| 135            | personality       | Set the process execution domain                 |
| 137            | vfork             | Create a child process and block parent          |
| 138            | fstatfs           | Get file system statistics                       |
| 140            | getpriority       | Get program scheduling priority                  |
| 141            | setpriority       | Set program scheduling priority                  |
| 142            | sched_setparam    | Set scheduling parameters                        |
| 143            | sched_getparam    | Get scheduling parameters                        |
| 144            | sched_setscheduler | Set scheduling policy                            |
| 145            | sched_getscheduler | Get scheduling policy                            |
| 146            | sched_get_priority_max | Get maximum scheduling priority              |
| 147            | sched_get_priority_min | Get minimum scheduling priority              |
| 148            | sched_rr_get_interval | Get the SCHED_RR interval for the named process |
| 149            | mlock             | Lock memory                                      |
| 150            | munlock           | Unlock memory                                    |
| 151            | mlockall          | Lock all memory                                  |
| 152            | munlockall        | Unlock all memory                                |
| 154            | modify_ldt        | Modify the local descriptor table                |
| 155            | pivot_root        | Change the root filesystem                       |
| 157            | prctl             | Operations on a process                          |
| 158            | arch_prctl        | Set architecture-specific thread state           |
| 160            | setrlimit         | Set resource limits                              |
| 164            | settimeofday      | Set time                                         |
| 165            | mount             | Mount a filesystem                               |
| 169            | reboot            | Reboot the system                                |
| 170            | sethostname       | Set the hostname                                 |
| 171            | setdomainname     | Set the NIS domain name                          |
| 172            | iopl              | Change I/O privilege level                       |
| 173            | ioperm            | Set port input/output permissions                |
| 179            | quotactl          | Quota control                                    |
| 186            | gettid            | Get thread ID                                    |
| 187            | readahead         | Perform file readahead                           |
| 188            | setxattr          | Set extended attributes                          |
| 190            | fsetxattr         | Set extended attributes                          |
| 193            | fgetxattr         | Get extended attributes                          |
| 196            | flistxattr        | List extended attributes                         |
| 197            | removexattr       | Remove extended attributes                       |
| 199            | fremovexattr      | Remove extended attributes                       |
| 200            | tkill             | Send a signal to a thread                        |
| 201            | time              | Get time in seconds                              |
| 202            | futex             | Fast user-space locking                          |
| 203            | sched_setaffinity | Set a process's CPU affinity mask                |
| 204            | sched_getaffinity | Get a process's CPU affinity mask                |
| 205            | set_thread_area   | Set a thread-local storage (TLS) descriptor      |
| 216            | remap_file_pages  | Create a nonlinear file mapping                  |
| 217            | getdents64        | Get directory entries                            |
| 218            | set_tid_address   | Set pointer to thread ID                         |
| 218            | setns             | Reassociate thread with a namespace              |
| 219            | restart_syscall   | Restart a system call after interruption by a stop signal |
| 220            | semtimedop        | System V semaphore operations                    |
| 231            | exit_group        | Exit all threads in a process                    |
| 232            | epoll_wait        | Wait for events on an epoll file descriptor      |
| 237            | mbind             | Set memory policy for a memory range             |
| 238            | set_mempolicy     | Set memory policy for a process                  |
| 246            | kexec_load        | Load a new kernel for later execution            |
| 249            | request_key       | Request a key from the kernel's key management facility |
| 250            | keyctl            | Perform a key management function                |
| 251            | ioprio_set        | Set I/O scheduling class and priority            |
| 252            | ioprio_get        | Get I/O scheduling class and priority            |
| 253            | inotify_init      | Initialize an inotify instance                   |
| 254            | inotify_add_watch | Add a watch to an initialized inotify instance   |
| 255            | inotify_rm_watch  | Remove an existing watch from an inotify instance|
| 256            | migrate_pages     | Move all pages in a process to another node      |
| 257            | openat            | Open a file relative to a directory file descriptor |
| 258            | mkdirat           | Create a directory relative to a directory file descriptor |
| 259            | mknodat           | Create a file relative to a directory file descriptor |
| 260            | fchownat          | Change owner and group of a file relative to a directory file descriptor |
| 261            | futimesat         | Change file timestamps relative to a directory file descriptor |
| 262            | newfstatat        | Get file status relative to a directory file descriptor |
| 263            | unlinkat          | Delete a name and possibly the file it refers to, relative to a directory file descriptor |
| 264            | renameat          | Rename a file relative to a directory file descriptor |
| 265            | linkat            | Create a hard link relative to a directory file descriptor |
| 266            | symlinkat         | Create a symbolic link relative to a directory file descriptor |
| 267            | readlinkat        | Read value of a symbolic link relative to a directory file descriptor |
| 268            | fchmodat          | Change permissions of a file relative to a directory file descriptor |
| 269            | faccessat         | Check user's permissions for a file relative to a directory file descriptor |
| 270
=========================================================================================

# Sorted by names :

=========================================================================================
| Syscall Name      | Syscall Number | Description                                      |
|-------------------|----------------|--------------------------------------------------|
| accept            | 43             | Accept a connection on a socket                  |
| accept4           | 288            | Accept a connection on a socket                  |
| access            | 21             | Check user's permissions for a file              |
| arch_prctl        | 158            | Set architecture-specific thread state           |
| bind              | 49             | Bind a name to a socket                          |
| bpf               | 321            | Perform operations on BPF programs               |
| brk               | 12             | Change data segment size                         |
| chdir             | 79             | Change working directory                         |
| chmod             | 90             | Change permissions of a file                     |
| chown             | 92             | Change owner and group of a file                 |
| clock_adjtime     | 304            | Adjust the system clock                          |
| close             | 3              | Close a file descriptor                          |
| close_range       | 436            | Close a range of file descriptors                |
| connect           | 42             | Connect a socket                                 |
| copy_file_range   | 326            | Copy a range of data from one file to another    |
| creat             | 85             | Create a file                                    |
| dup               | 32             | Duplicate a file descriptor                      |
| dup2              | 33             | Duplicate a file descriptor                      |
| dup3              | 292            | Duplicate a file descriptor                      |
| epoll_create1     | 291            | Create an epoll file descriptor                  |
| epoll_pwait       | 281            | Wait for events on an epoll file descriptor      |
| epoll_pwait2      | 441            | Wait for events on an epoll file descriptor      |
| epoll_wait        | 232            | Wait for events on an epoll file descriptor      |
| eventfd           | 284            | Create a file descriptor for event notification  |
| eventfd2          | 290            | Create a file descriptor for event notification  |
| execve            | 59             | Execute a program                                |
| execveat          | 322            | Execute a program                                |
| exit              | 60             | Terminate the calling process                    |
| exit_group        | 231            | Exit all threads in a process                    |
| faccessat         | 269            | Check user's permissions for a file relative to a directory file descriptor |
| faccessat2        | 439            | Check user's permissions for a file              |
| fallocate         | 285            | Manipulate file space                            |
| fanotify_init     | 300            | Initialize fanotify group                        |
| fanotify_mark     | 301            | Add, remove, or modify an fanotify mark          |
| fchdir            | 80             | Change working directory                         |
| fchmod            | 91             | Change permissions of a file                     |
| fchmodat          | 268            | Change permissions of a file relative to a directory file descriptor |
| fchown            | 93             | Change owner and group of a file                 |
| fchownat          | 260            | Change owner and group of a file relative to a directory file descriptor |
| fcntl             | 72             | Manipulate file descriptor                       |
| fdatasync         | 75             | Synchronize a file's in-core state with storage  |
| fgetxattr         | 193            | Get extended attributes                          |
| finit_module      | 313            | Load a kernel module                             |
| flistxattr        | 196            | List extended attributes                         |
| flock             | 73             | Apply or remove an advisory lock on an open file |
| fork              | 57             | Create a child process                           |
| fremovexattr      | 199            | Remove extended attributes                       |
| fsetxattr         | 190            | Set extended attributes                          |
| fstat             | 5              | Get file status                                  |
| fstatfs           | 138            | Get file system statistics                       |
| fsync             | 118            | Synchronize a file's in-core state with storage  |
| ftruncate         | 77             | Truncate a file to a specified length            |
| futex             | 202            | Fast user-space locking                          |
| futimesat         | 261            | Change file timestamps relative to a directory file descriptor |
| getcpu            | 309            | Determine CPU and NUMA node                      |
| getcwd            | 78             | Get current working directory                    |
| getdents          | 78             | Get directory entries                            |
| getdents64        | 217            | Get directory entries                            |
| getegid           | 108            | Get effective group ID                           |
| geteuid           | 107            | Get effective user ID                            |
| getgid            | 104            | Get group ID                                     |
| getgroups         | 115            | Get list of supplementary group IDs              |
| getitimer         | 107            | Get value of an interval timer                   |
| getpeername       | 52             | Get name of connected peer                       |
| getpgid           | 121            | Get process group ID                             |
| getpgrp           | 111            | Get process group ID                             |
| getpid            | 39             | Get process ID                                   |
| getppid           | 110            | Get parent process ID                            |
| getpriority       | 140            | Get program scheduling priority                  |
| getrandom         | 318            | Obtain random bytes                              |
| getresgid         | 120            | Get real, effective and saved group ID           |
| getresuid         | 118            | Get real, effective and saved user ID            |
| getrlimit         | 97             | Get resource limits                              |
| getrusage         | 98             | Get resource usage                               |
| getsid            | 124            | Get session ID                                   |
| getsockname       | 51             | Get socket name                                  |
| getsockopt        | 55             | Get options on sockets                           |
| gettid            | 186            | Get thread ID                                    |
| gettimeofday      | 96             | Get time                                         |
| getuid            | 102            | Get user ID                                      |
| inotify_add_watch | 254            | Add a watch to an initialized inotify instance   |
| inotify_init      | 253            | Initialize an inotify instance                   |
| inotify_init1     | 294            | Initialize an inotify instance                   |
| inotify_rm_watch  | 255            | Remove an existing watch from an inotify instance|
| ioctl             | 16             | Control device                                   |
| ioperm            | 173            | Set port input/output permissions                |
| iopl              | 172            | Change I/O privilege level                       |
| ioprio_get        | 252            | Get I/O scheduling class and priority            |
| ioprio_set        | 251            | Set I/O scheduling class and priority            |
| kcmp              | 312            | Compare two processes                            |
| kexec_file_load   | 320            | Load a new kernel for later execution            |
| kexec_load        | 246            | Load a new kernel for later execution            |
| keyctl            | 250            | Perform a key management function                |
| kill              | 62             | Send a signal to a process                       |
| lchown            | 94             | Change owner and group of a file                 |
| link              | 86             | Create a hard link                               |
| linkat            | 265            | Create a hard link relative to a directory file descriptor |
| listen            | 50             | Listen for connections on a socket               |
| lseek             | 8              | Reposition read/write file offset                |
| lstat             | 6              | Get file status                                  |
| madvise           | 28             | Advise about use of memory                       |
| mbind             | 237            | Set memory policy for a memory range             |
| memfd_create      | 319            | Create an anonymous file                         |
| migrate_pages     | 256            | Move all pages in a process to another node      |
| mincore           | 27             | Determine whether pages are resident in memory   |
| mkdir             | 83             | Create a directory                               |
| mkdirat           | 258            | Create a directory relative to a directory file descriptor |
| mknod             | 133            | Create a special or ordinary file                |
| mknodat           | 259            | Create a file relative to a directory file descriptor |
| mlock             | 149            | Lock memory                                      |
| mlock2            | 325            | Lock memory                                      |
| mlockall          | 151            | Lock all memory                                  |
| mmap              | 9              | Map files or devices into memory                 |
| modify_ldt        | 154            | Modify the local descriptor table                |
| mount             | 165            | Mount a filesystem                               |
| move_mount        | 429            | Move a mount point                               |
| move_pages        | 279            | Move pages of a process to another node          |
| mprotect          | 10             | Set protection on a region of memory             |
| mremap            | 25             | Remap a virtual memory address                   |
| msgctl            | 71             | System V message control operations              |
| msgget            | 68             | Get a System V message queue identifier          |
| msgrcv            | 70             | Receive a message from a System V message queue  |
| msgsnd            | 69             | Send a message to a System V message queue       |
| msync             | 26             | Synchronize a file with a memory map             |
| munlock           | 150            | Unlock memory                                    |
| munlockall        | 152            | Unlock all memory                                |
| munmap            | 11             | Unmap files or devices from memory               |
| name_to_handle_at | 303            | Obtain handle for a pathname                     |
| nanosleep         | 35             | High-resolution sleep                            |
| newfstatat        | 262            | Get file status relative to a directory file descriptor |
| open              | 2              | Open a file                                      |
| open_by_handle_at | 304            | Open file via a handle                           |
| openat            | 257            | Open a file relative to a directory file descriptor |
| pause             | 34             | Wait for a signal                                |
| perf_event_open   | 298            | Open a performance monitoring event              |
| personality       | 135            | Set the process execution domain                 |
| pipe              | 22             | Create pipe                                      |
| pipe2             | 293            | Create a pipe                                    |
| pivot_root        | 155            | Change the root filesystem                       |
| pkey_alloc        | 330            | Allocate a protection key                        |
| pkey_free         | 331            | Free a protection key                            |
| pkey_mprotect     | 329            | Set protection on a region of memory             |
| poll              | 7              | Synchronous I/O multiplexing                     |
| ppoll             | 271            | Synchronous I/O multiplexing                     |
| prctl             | 157            | Operations on a process                          |
| pread64           | 17             | Read from a file descriptor at a given offset    |
| preadv            | 295            | Read from multiple buffers                       |
| preadv2           | 327            | Read from multiple buffers                       |
| prlimit64         | 302            | Get/set resource limits                          |
| process_madvise   | 440            | Advise about use of memory                       |
| process_vm_readv  | 310            | Read from another process's address space        |
| process_vm_writev | 311            | Write to another process's address space         |
| pselect6          | 270            | Synchronous I/O multiplexing                     |
| ptrace            | 101            | Process trace                                    |
| pwrite64          | 18             | Write to a file descriptor at a given offset     |
| pwritev           | 296            | Write to multiple buffers                        |
| pwritev2          | 328            | Write to multiple buffers                        |
| quotactl          | 179            | Quota control                                    |
| read              | 0              | Read from a file descriptor                      |
| readahead         | 187            | Perform file readahead                           |
| readlink          | 89             | Read value of a symbolic link                    |
| readlinkat        | 267            | Read value of a symbolic link relative to a directory file descriptor |
| readv             | 19             | Read from multiple buffers                       |
| reboot            | 169            | Reboot the system                                |
| recvfrom          | 45             | Receive a message from a socket                  |
| recvmmsg          | 299            | Receive multiple messages                        |
| recvmsg           | 47             | Receive a message                                |
| remap_file_pages  | 216            | Create a nonlinear file mapping                  |
| removexattr       | 197            | Remove extended attributes                       |
| rename            | 82             | Rename a file                                    |
| renameat          | 264            | Rename a file relative to a directory file descriptor |
| renameat2         | 316            | Rename a file                                    |
| request_key       | 249            | Request a key from the kernel's key management facility |
| restart_syscall   | 219            | Restart a system call after interruption by a stop signal |
| rmdir             | 84             | Remove a directory                               |
| rt_sigaction      | 13             | Examine and change a signal action               |
| rt_sigpending     | 127            | Examine pending signals                          |
| rt_sigprocmask    | 14             | Examine and change blocked signals               |
| rt_sigqueueinfo   | 129            | Queue a signal and data                          |
| rt_sigsuspend     | 130            | Wait for a signal                                |
| rt_sigtimedwait   | 128            | Synchronously wait for a signal                  |
| rt_tgsigqueueinfo | 297            | Queue a signal and data                          |
| sched_getaffinity | 204            | Get a process's CPU affinity mask                |
| sched_getattr     | 315            | Get scheduling parameters                        |
| sched_getparam    | 143            | Get scheduling parameters                        |
| sched_get_priority_max | 146        | Get maximum scheduling priority                  |
| sched_get_priority_min | 147        | Get minimum scheduling priority                  |
| sched_getscheduler | 145            | Get scheduling policy                            |
| sched_rr_get_interval | 148         | Get the SCHED_RR interval for the named process  |
| sched_setaffinity | 203            | Set a process's CPU affinity mask                |
| sched_setattr     | 314            | Set scheduling parameters                        |
| sched_setparam    | 142            | Set scheduling parameters                        |
| sched_setscheduler | 144            | Set scheduling policy                            |
| sched_yield       | 24             | Yield the processor                              |
| seccomp           | 317            | Operate on secure computing state                |
| select            | 23             | Synchronous I/O multiplexing                     |
| semctl            | 66             | System V semaphore control operations            |
| semget            | 64             | Get a System V semaphore set identifier          |
| semop             | 65             | System V semaphore operations                    |
| semtimedop        | 220            | System V semaphore operations                    |
| sendfile          | 40             | Transfer data between file descriptors           |
| sendmmsg          | 307            | Send multiple messages                           |
| sendmsg           | 46             | Send a message                                   |
| sendto            | 44             | Send a message on a socket                       |
| set_mempolicy     | 238            | Set memory policy for a process                  |
| set_robust_list   | 273            | Set list of robust futexes                       |
| set_thread_area   | 205            | Set a thread-local storage (TLS) descriptor      |
| set_tid_address   | 218            | Set pointer to thread ID                         |
| setdomainname     | 171            | Set the NIS domain name                          |
| setfsgid          | 123            | Set group ID used for file system checks         |
| setfsuid          | 122            | Set user ID used for file system checks          |
| setgid            | 106            | Set group ID                                     |
| setgroups         | 116            | Set list of supplementary group IDs              |
| sethostname       | 170            | Set the hostname                                 |
| setitimer         | 104            | Set value of an interval timer                   |
| setns             | 308            | Reassociate thread with a namespace              |
| setpgid           | 109            | Set process group ID                             |
| setpriority       | 141            | Set program scheduling priority                  |
| setregid          | 114            | Set real and effective group IDs                 |
| setresgid         | 119            | Set real, effective and saved group ID           |
| setresuid         | 117            | Set real, effective and saved user ID            |
| setreuid          | 113            | Set real and effective user IDs                  |
| setrlimit         | 160            | Set resource limits                              |
| setsid            | 112            | Create a session and set the process group ID    |
| setsockopt        | 54             | Set options on sockets                           |
| settimeofday      | 164            | Set time                                         |
| setuid            | 105            | Set user ID                                      |
| setxattr          | 188            | Set extended attributes                          |
| shmat             | 30             | Attach a shared memory segment                   |
| shmctl            | 31             | System V shared memory control operations        |
| shmdt             | 67             | Detach a shared memory segment                   |
| shmget            | 29             | Get a System V shared memory segment identifier  |
| shutdown          | 48             | Shut down part of a full-duplex connection       |
| sigaltstack       | 132            | Set and/or get signal stack context              |
| signalfd          | 282            | Create
=========================================================================================


================================================================
NEXT SECTION TO BE WRITTEN...
________________________________________________________________
