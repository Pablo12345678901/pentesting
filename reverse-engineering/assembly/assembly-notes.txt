# This is a comment
# Another comment
# Useful command to assembly the code of the current program and run it :
#
# as myexit.s -o myexit.o && ld myexit.o -o myexit && ./myexit && rm -rf myexit.o myexit ; echo $? ;
# as -> assembly instructions.
# ld -> link to produce binary executable file.	
	
# Anything starting with a dot is an instruction to the assembler.
# .globl tell the assembler that the symbol _start should not be discarded after the assembly process is over.
.globl _start  # _start is a special symbol used as 'entry point' to the program.

# Another command to the assembler.
.section .text

# DEFINING THE VALUE OF THE _START SYMBOL
#
_start: 

    # PREPARATION OF THE SYSTEM CALL NUMBER FOR FURTHER CALL LATER.
    #
    # movq = move quadword -> quadword = 8 bytes (64 bits)	
    # Here, move the value 60 into the register named '%rax' -> the 64-bit-register.
    # $60 means that we treat 60 as a value not an address.
    # The number 60 is the system call number of the command to run.
    # the number 60 is the 'exit' system call.
    movq $60, %rax # -> Moving the call to %rax does not make the call. It has to be lauched by next line.

    # A BIT OF THEORY
    #
    # Existing instructions with 'mov'
    #	movb = 8 bit-chuncks (1 byte)
    # 	movw = 16 bit-chuncks (2 byte)
    #	movl = 32 bit-chuncks (4 byte)
    # 	movq = 64 bit-chuncks (8 byte)
    #
    # movq has two operands, kind of movq(source, destination)
    # The source can be : a register, memory address or value (as here '60')
    # Here, the destination is a register 'Rax'
	
    # SET VALUE USED WITHIN SYSTEM CALL.
    #
    # Set the exit code to a number 0-255.
    # movq 1000, %rax -> This provokes 'Segmentation fault' due to non compliant access to memory.
    # In the system call definition of 'exit', '%rdi' holds the exit status of the program. It is a kind of return value.
    # By default = 0 , if the below instruction was not existing.
    movq $33, %rdi # Set exit code. Could be $0, ... $255.
	
    movq $0, %rdi # Re-set good exit code.

    # If there is a type in an instrcuction, this message appears :
    # Error: no such instruction: `mo $0,%rdi'
    # As if uncomment the below line.
    # mo $0, %rdi # 'mo' instruction is not defined, what generate an error.
	
    # PEFORM SYSTEM CALL
    # This gives Linux Kernel the order of syscall.
    # For the syscall, the order of the register setting does not matter.
    # We could have written the movq to the %rdi register (destination) before the movq to the '%rax' register.
    syscall
    # If the syscall is not done, A 'Segmentation fault' error is generated.	

# Arithmetic

# Addition :
# This adds '%rax' to '%rdi' and store the result into '%rdi'
addq %rax, %rdi

# Substraction
subq %rax, %rdi

# Incrementation (+=1)
# No source needed as the incrementation is +1
incq DESTINATION

# Decrementation (-=1)
# No source needed as the decrementation is -1
decq DESTINATION

# For multiplication and division, the destination is assumed to be '%rax'
# So only need to precise which is the source
# WARNING
# The source cannot be a number, it has to be a register or memory location.


# Multiplication
# The final result will be held into '%rax'
# So no need for destination, only source
mulq SOURCE

# Division
# Similar to multiplication
# But the remainer is stored in the '%rdx' register which should be set to zero before the instruction occurs.
divq SOURCE
