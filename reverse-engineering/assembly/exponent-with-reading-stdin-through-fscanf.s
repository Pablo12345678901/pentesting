	# This file has to be linked with :
	# - the standard C library
	# - the 'exponent-function-definition.s' file for the 'exponent' function
	.globl main

	.section .data
prompt_format:
	.ascii "Enter two numbers separated by spaces, then press return to compute the exponent of FIRST_NUMBER^SECOND_NUMBER.\n-> \0"
scan_format:
	.ascii "%d %d\0"
result_format:
	.ascii "The result is :\n %d^%d = %d \n\0"
	
	.section .text
	.equ LOCAL_OFFSET_NUMBER, -8
	.equ LOCAL_OFFSET_EXPONENT, -16
	
main:
	enter $16, $0

	# Print prompt to stdout
	movq stdout, %rdi
	leaq prompt_format, %rsi
	# Set '%rax' to '0' as no floating-point number are used within those variadic function arguments.
	movq $0, %rax
	call fprintf

	# Request inputs (number and exponent)
	movq stdin, %rdi
	leaq scan_format, %rsi
	# Save the address of where the inputs should be saved.
	# Those are pointer to pointer, this is why 'lea' instruction is used instead of 'mov'
	leaq LOCAL_OFFSET_NUMBER(%rbp), %rdx
	leaq LOCAL_OFFSET_NUMBER(%rbp), %rcx
	# Set '%rax' to '0' as no floating-point number are used within those variadic function arguments.
	movq $0, %rax
	call fscanf

	# Set the exponent function arguments from user input
	movq LOCAL_OFFSET_NUMBER(%rbp), %rdi
	movq LOCAL_OFFSET_EXPONENT(%rbp), %rsi
	# REMINDER : exponent function comes from the file 'exponent-function-definition.s'
	call exponent

	# Print result to stdout
	movq stdout, %rdi
	leaq result_format, %rsi
	# Load both the number and exponent
	movq LOCAL_OFFSET_NUMBER(%rbp), %rdx
	movq LOCAL_OFFSET_EXPONENT(%rbp), %rcx
	# Load the 'exponent' function result.
	movq %rax, %r8
	# Set '%rax' to '0' as no floating-point number are used within those variadic function arguments.
	movq $0, %rax
	call fprintf

	# Debug
	# The current final result is wrong - check with gdb why...
	THEREISABUG
	
	leave
	ret
	
