	# This program is an enhancement of the file 'allocate-enhanced-with-16-bytes-alignment.s'.
	# New features :

	# Request whole pages at a time.
	# Two level of allocation :
	# - block allocation
	# - individual memory allocations
	# Then when a request of memory is done :
	# - first it will get first block
	# - then check if within it there is any individual memory allocation available
	# - if so, allocate there
	# - else, check next block
	# - if all blocks were checked and no individual memory allocation is available, request another block.


	# Beginning :
	# No block allocated
	# Compute : requested size + header size = total size -> round up to a 4096 size
	#	- header will be added the block end address.
	# Request such block
	# 
	
	# When a request for specific size is done
	#	- add header to it
	#	- get total size
	#	- round to a block size (4096 multiple)
	
	# DEBUG TO DO



	
	# Old features that still apply : 
	# All addresses are aligned to a 16 bytes multiple as requested by standard C library functions with x86-64 architecture.
	# To do so :
	# - before each memory location as for example 'allocate' was added a directive '.balign 16' just before.
	# - each part of the allocation blocks have size rounded up to a 16 multiple with the function 'round_up_number_to_a_specific_multiple'. All of those (when aligned) are saved on the stack. To help code readibility.
	# - even the program break is rounded up to a 16 multiple with the same function. It is not needed as it is already aligned but was coded for fun. It is saved on stack too.
	# This program tries to reproduce 'malloc' and 'free' implementation.
	# It will first check whether the memory pointers ('memory_start' and 'memory_end', that represents the pointer to were a block starts and were it ends) were initialized.
	# Then, if not, it will initialize them to current 'program break'.
	# Then it will process to a loop until allocation was performed :
	# It will check whether both pointer are equal : whether all blocks were checked so far and if so, save the current program break to be returned and then move it of the total size (total size = requested + header size).
	# Else, it will check the current block composed of a header and the block content.
	# The header size if composed of two quadwords :
	# - first  : a flag that shows whether the block examined is in use ('1') or not ('0').
	# - second : the size of such block (= header + block content)
	# So, it will first check whether the block is available and if not, add its size to the current 'memory start' (start of the block) to obtain address of next block.
	# Else, it will check whether the block content size (second quadword of the header) is enough for the requested size (total size = requested + header).
	# If it is enough, it will allocate the block but setting the first quadword of the header to unavailable (=1) and return the address of the current memory_start + header size = pointer to block content.
	# Else, it will check the next block.
	# This program have to be linked with the 'C' program 'use-allocate-and-deallocate-functions.c' and then this later executed.

# --------------------------------------------------------------------------------------------------
	
	.globl allocate, deallocate
	.type allocate, @function
	.type deallocate, @function
	.type round_up_number_to_a_specific_multiple, @function

# --------------------------------------------------------------------------------------------------
	
	# Allocate two quadword (8 bytes each) within uninitialized data section '.bss'.
	.section .bss
	
.balign	16 # Align to 16 bytes multiple next address
first_block_address:
	.zero 8
	
# --------------------------------------------------------------------------------------------------
	
	.section .rodata
	
.balign	16 # Align to 16 bytes multiple next address
message_print_number_to_be_align:
	.ascii "Number or address to be aligned to a %d multiple : %d = %s.\n\0"
	
.balign	16 # Align to 16 bytes multiple next address	
message_print_number_aligned:
	.ascii "Number or address       aligned to a %d multiple : %d = %s.\n\0"

.balign	16 # Align to 16 bytes multiple next address	
name_requested_size:
	.ascii "requested size\0"

.balign	16 # Align to 16 bytes multiple next address	
name_header:	
	.ascii "header size\0"

.balign	16 # Align to 16 bytes multiple next address	
name_total_size:	
	.ascii "total size\0"

.balign	16 # Align to 16 bytes multiple next address	
name_program_break:	
	.ascii "program break\0"

.balign	16 # Align to 16 bytes multiple next address	
message_new_program_break_set:
	.ascii "\nA new program break was set to the address %d.\n\0"
	
# --------------------------------------------------------------------------------------------------
	
	.section .text

# --------------------------------------------------------------------------------------------------
	
	# Local variable(s) for the function 'round_up_number_to_a_16_multiple'
	.equ LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_TO_ALIGN, -8
	.equ LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_ALIGNED, -16
	.equ LOCAL_OFFSET_ROUND_FUNCTION_NAME_OF_WHAT_IS_ALIGNED, -24
	.equ LOCAL_OFFSET_ROUND_FUNCTION_MULTIPLE_FOR_ALIGNMENT, -32

.balign	16 # Align to 16 bytes multiple next address	
round_up_number_to_a_specific_multiple:
	# This function takes a number and will round it up to a specific multiple.
	# In some case, it is not an address, just a byte(s) number - in other it is an address (=also a number).
	
	# Make space on the stack for variable(s) :
	# - number to align
	# - number aligned
	# - name of what is aligned for printed message
	# - provided multiple to which round the number up
	enter $32, $0

	# Save the address provided on the stack
	movq %rdi, LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_TO_ALIGN(%rbp)
	# Save the name of what is aligned on stack for printed message
	movq %rsi, LOCAL_OFFSET_ROUND_FUNCTION_NAME_OF_WHAT_IS_ALIGNED(%rbp)
	# Save the multiple to which round up the number
	movq %rdx, LOCAL_OFFSET_ROUND_FUNCTION_MULTIPLE_FOR_ALIGNMENT(%rbp)

	# Print initial number to be aligned
	movq stdout, %rdi
	leaq message_print_number_to_be_align, %rsi
	movq LOCAL_OFFSET_ROUND_FUNCTION_MULTIPLE_FOR_ALIGNMENT(%rbp), %rdx
	movq LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_TO_ALIGN(%rbp), %rcx
	movq LOCAL_OFFSET_ROUND_FUNCTION_NAME_OF_WHAT_IS_ALIGNED(%rbp), %r8
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf
	
	# Division
	# Load number to divide on accumulator register
	movq LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_TO_ALIGN(%rbp), %rax
	# Set %rdx to '0' for further division
	movq $0, %rdx
	# Set divisor to specific multiple
	movq LOCAL_OFFSET_ROUND_FUNCTION_MULTIPLE_FOR_ALIGNMENT(%rbp), %rdi
	# Divide address by it
	divq %rdi

	# Re-set %rax to the initial address
	movq LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_TO_ALIGN(%rbp), %rax

	# Check whether is it a multiple of such divisor (if %rdx = 0)
	cmpq $0, %rdx
	# If so - get to final part.
	je final_message_and_return

	# Else, the number is not a multiple of such divisor and there is a remainder in %rdx.
	# So the number has to rounded up to a multiple divisor.
	# So compute what has to be added to it as 'divisor - remainder'
	subq %rdx, %rdi
	
	# And add to it to initial number to get aligned one
	addq %rdi, %rax

.balign	16 # Align to 16 bytes multiple next address	
final_message_and_return:
	# Save aligned address on stack
	movq %rax, LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_ALIGNED(%rbp)
	
	# Print aligned number
	movq stdout, %rdi
	leaq message_print_number_aligned, %rsi
	movq LOCAL_OFFSET_ROUND_FUNCTION_MULTIPLE_FOR_ALIGNMENT(%rbp), %rdx
	movq LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_TO_ALIGN(%rbp), %rcx
	movq LOCAL_OFFSET_ROUND_FUNCTION_NAME_OF_WHAT_IS_ALIGNED(%rbp), %r8
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Return the aligned address
	movq LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_ALIGNED(%rbp), %rax 
	
	leave
	ret

# --------------------------------------------------------------------------------------------------

 	# Local variable(s) for the function 'allocate' (and other code part that it calls)
	# About blocks :
	# - the block header size						- aligned to a 16 bytes multiple
	# - the current block total size					- aligned to a 4096 bytes multiple
	# - current block examined start address 				- aligned to a 4096 bytes multiple
	# - current block examined end address 					- aligned to a 4096 bytes multiple
	# - current individual memory address examined within such block 	- aligned to a 16 bytes multiple
	# About individual memory location within blocks :
	# - requested size by user		- aligned to a 16 bytes multiple
	# - header size				- aligned to a 16 bytes multiple
	# - total size (header + requested 	- aligned to a 16 bytes multiple
	.equ LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_HEADER_SIZE_ALIGNED, -8
	.equ LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_TOTAL_SIZE_ALIGNED, -16
	.equ LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_BLOCK_ADDRESS_ALIGNED, -24
	.equ LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_BLOCK_END_ADDRESS_ALIGNED, -32
	.equ LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_INDIVIDUAL_MEMORY_ADDRESS_ALIGNED, -40
	.equ LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_INDIVIDUAL_MEMORY_ADDRESS_AFTER_HEADER_ALIGNED, -48
	.equ LOCAL_OFFSET_ALLOCATE_FUNCTION_INDIVIDUAL_MEMORY_REQUESTED_SIZE_ALIGNED, -56
	.equ LOCAL_OFFSET_ALLOCATE_FUNCTION_INDIVIDUAL_MEMORY_HEADER_SIZE_ALIGNED, -64
	.equ LOCAL_OFFSET_ALLOCATE_FUNCTION_INDIVIDUAL_MEMORY_TOTAL_SIZE_ALIGNED, -72

	# Each block has a header that is composed of quadwords :
	# - first : a flag that contains the block size
	# - second : the precedent block address
	# - third : the next block address 
	.equ OFFSET_BLOCK_HEADER_SIZE, 0
	.equ OFFSET_BLOCK_HEADER_PRECEDENT_BLOCK_ADDRESS, 8
	.equ OFFSET_BLOCK_HEADER_NEXT_BLOCK_ADDRESS, 16
	# Total header size
	.equ BLOCK_HEADER_SIZE, 24
	
	# Each individual memory allocation has a header that is composed of quadwords :
n	# - first  : a flag that shows whether the block examined is in use ('1') or not ('0').
	# - second : the size of such block (= header + block content)
	.equ OFFSET_INDIVIDUAL_MEMORY_HEADER_IN_USE, 0
	.equ OFFSET_INDIVIDUAL_MEMORY_HEADER_SIZE, 8
	# Total header size
	.equ INDIVIDUAL_MEMORY_HEADER_SIZE, 16
	
	# Those constants are used to help code reading.
	.equ MMAP_SYSCALL, 9
	.equ ALIGNMENT_MULTIPLE_ADDRESS, 16
	.equ ALIGNMENT_MULTIPLE_BLOCK, 4096

.balign	16 # Align to 16 bytes multiple next address	
allocate:
	# Make space for variable(s) on stack
	enter $80, $0
	
	# Align requested size
	#movq %rdi, %rdi # size - not needed to be updated as it is already in %rdi
	leaq name_requested_size, %rsi # name of what is aligned
	leaq ALIGNMENT_MULTIPLE_ADDRESS, %rdx
	call round_up_number_to_a_specific_multiple

	# Save the requested aligned size on the stack
	movq %rax, LOCAL_OFFSET_ALLOCATE_FUNCTION_INDIVIDUAL_MEMORY_REQUESTED_SIZE_ALIGNED(%rbp)
	
	# Align individual memory header size
	leaq INDIVIDUAL_MEMORY_HEADER_SIZE, %rdi
	leaq name_header, %rsi
	leaq ALIGNMENT_MULTIPLE_ADDRESS, %rdx
	call round_up_number_to_a_specific_multiple

	# Save the header aligned size on the stack
	movq %rax, LOCAL_OFFSET_ALLOCATE_FUNCTION_HEADER_SIZE_ALIGNED(%rbp)

	# Set the size to align to the requested one
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_INDIVIDUAL_MEMORY_REQUESTED_SIZE_ALIGNED(%rbp), %rdi
	# Add the header size to this requested size as each block is added a header at the beginning.
	addq LOCAL_OFFSET_ALLOCATE_FUNCTION_INDIVIDUAL_MEMORY_HEADER_SIZE_ALIGNED(%rbp), %rdi

	# Align total size - not needed as both the requested size + the header were aligned - but cool to show anyway.
	leaq name_total_size, %rsi
	leaq ALIGNMENT_MULTIPLE_ADDRESS, %rdx
	call round_up_number_to_a_specific_multiple

	# Save the total size aligned on the stack
	movq %rax, LOCAL_OFFSET_ALLOCATE_FUNCTION_INDIVIDUAL_MEMORY_TOTAL_SIZE_ALIGNED(%rbp)
	
	# Compare the memory start with '0' to check whether the initialization was already not done
	cmpq $0, first_block_address
	# If so, process to initialization
	je allocation_init
	# Else, skip the initialization
	jne allocate_continue

.balign	16 # Align to 16 bytes multiple next address	
allocation_init:
	# The initialization consists in :
	# - round up size of block header to 16 bytes multiple
	# - compute total block size needed and round it to a 4096 bytes multiple
	# - request a block of such size
	# - save address of the first block (=current block)
	# - return address of the first individual memory location after the header.
	
	# Align block header size
	leaq BLOCK_HEADER_SIZE, %rdi
	leaq name_header, %rsi
	leaq ALIGNMENT_MULTIPLE_ADDRESS, %rdx
	call round_up_number_to_a_specific_multiple

	# Save the block header aligned size on the stack
	movq %rax, LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_HEADER_SIZE_ALIGNED(%rbp)

	# Add the total size needed for an individual memory allocation to the block header size to get the whole block size requested
	addq LOCAL_OFFSET_ALLOCATE_FUNCTION_INDIVIDUAL_MEMORY_TOTAL_SIZE_ALIGNED(%rbp), %rax

	# Align such value to a page-size increment (=4096 bytes)
	movq %rax, %rdi
	leaq name_block_total_size, %rsi
	leaq ALIGNMENT_MULTIPLE_BLOCK, %rdx
	call round_up_number_to_a_specific_multiple

	# Save the size of current block on stack
	movq %rax, LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_TOTAL_SIZE_ALIGNED(%rbp)
	
	# Request first block with 'mmap' system call
	movq $9, %rax # Set syscall number
	movq $0, %rdi 	# Let Linux choose the address of the allocation.
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_TOTAL_SIZE_ALIGNED(%rbp), %rsi # Request a specific block length
	movq $0x03, %rdx 	# Set protection flags (=file open mode) to 'read + write'.
	movq $0x22, %r10 	# Set the general flags to 'MAP_ANONYMOUS' (=no file used) and 'MAP_PRIVATE'
	movq $-1, %r8 	# No file descriptor is provided as no file will be mapped.
	movq $0, %r9		# No offset is required as no file will be mapped.
	syscall

	# Save the first block address
	movq %rax, first_block_address
	# Same but as 'current block start address'
	movq %rax, LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_BLOCK_ADDRESS_ALIGNED(%rbp)
	# Set the end address of such block as total size + current address
	addq LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_TOTAL_SIZE_ALIGNED(%rbp), %rax
	# Save current block end address on stack
	movq %rax, LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_BLOCK_END_ADDRESS_ALIGNED(%rbp)
	# Set the current individual memory location examined to start address + block header
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_BLOCK_ADDRESS_ALIGNED(%rbp), %rax
	addq LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_HEADER_SIZE_ALIGNED, %rax
	movq %rax, LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_INDIVIDUAL_MEMORY_ADDRESS_ALIGNED(%rbp)

	# Set first individual memory allocation header
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_INDIVIDUAL_MEMORY_ADDRESS_ALIGNED(%rbp), %rsi
	movq $1, OFFSET_INDIVIDUAL_MEMORY_HEADER_IN_USE(%rsi)
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_INDIVIDUAL_MEMORY_TOTAL_SIZE_ALIGNED(%rbp), %rax
	movq %rax, OFFSET_INDIVIDUAL_MEMORY_HEADER_SIZE(%rsi)
	
	# Compute the address of individual memory location AFTER the header
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_INDIVIDUAL_MEMORY_ADDRESS_ALIGNED(%rbp), %rax
	addq LOCAL_OFFSET_ALLOCATE_FUNCTION_HEADER_SIZE_ALIGNED(%rbp), %rax
	movq %rax, LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_INDIVIDUAL_MEMORY_ADDRESS_AFTER_HEADER_ALIGNED(%rbp)
		
	# Print message to tell user that first block allocation was done.
	movq stdout, %rdi
	leaq message_first_block_allocation_done, %rsi
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_INDIVIDUAL_MEMORY_ADDRESS_AFTER_HEADER_ALIGNED(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Return the address of the individual memory location of current examined memory location after the header
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_INDIVIDUAL_MEMORY_ADDRESS_AFTER_HEADER_ALIGNED(%rbp), %rax
	leave
	ret

.balign	16 # Align to 16 bytes multiple next address	
allocate_continue:
	# Load values of the pointer to :
	# - the start of current memory individual allocation examined
	# - the current block end
	# ... within registers.
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_INDIVIDUAL_MEMORY_ADDRESS_ALIGNED(%rbp), %rsi
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_BLOCK_END_ADDRESS_ALIGNED(%rbp), %rcx

	jmp allocate_loop

.balign	16 # Align to 16 bytes multiple next address
allocate_loop:
	# Check whether the end of memory was reached -> memory start = memory end
	cmpq %rsi, %rcx
	# If it is the case, move the program break
	je allocate_request_another_block
	
	# Else, check whether the next individual memory allocation is available from its 'flag' (OFFSET_HEADER_IN_USE(%rsi)) within the header
	cmpq $0, OFFSET_INDIVIDUAL_MEMORY_HEADER_IN_USE(%rsi)
	# If not, try next individual memory allocation.
	jne try_next_individual_memory_allocation

	# Else, compare the individual memory allocation size with what was requested
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_INDIVIDUAL_MEMORY_TOTAL_SIZE_ALIGNED(%rbp), %rax
	cmpq %rax, OFFSET_INDIVIDUAL_MEMORY_HEADER_SIZE(%rsi)
	# If the block size is below what is requested, try next block.
	jb try_next_individual_memory_allocation
	# Else the block available is sufficiently big for the request.
	# So mark it as unavailable.
	movq $1, OFFSET_INDIVIDUAL_MEMORY_HEADER_IN_USE(%rsi)

	# Compute the address of the individual memory allocation beyond the header
	addq LOCAL_OFFSET_ALLOCATE_FUNCTION_INDIVIDUAL_MEMORY_HEADER_SIZE_ALIGNED(%rbp), %rsi

	# Save it on stack
	movq %rsi, LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_INDIVIDUAL_MEMORY_ADDRESS_AFTER_HEADER_ALIGNED(%rbp)
	
	# Adapt address of current individual memory allocation examined
	# Load the current individual memory allocation address
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_INDIVIDUAL_MEMORY_ADDRESS_ALIGNED(%rbp), %rax
	# Add to it the total individual memory allocation size
	addq LOCAL_OFFSET_ALLOCATE_FUNCTION_INDIVIDUAL_MEMORY_TOTAL_SIZE_ALIGNED(%rbp), %rax
	# Save it on stack
	movq %rax, LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_INDIVIDUAL_MEMORY_ADDRESS_ALIGNED(%rbp), %rsi
	
	# Load the return address of individual memory allocation after the header within '%rax' register to be returned at the end
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_BLOCK_CURRENT_EXAMINED_INDIVIDUAL_MEMORY_ADDRESS_AFTER_HEADER_ALIGNED(%rbp), %rax
	# No need to adapt it to new individual memory location as this will be computed at next function call.
	leave
	ret






	
# DEBUG I AM HERE






	
.balign	16 # Align to 16 bytes multiple next address
allocate_request_another_block:
	# Old break is save in %r8 to be later returned to user
	movq %rcx, %r8

	# Calculate where the new break will be
	# = old break + size
	# Set %rdi to the old break.
	movq %rcx, %rdi

	# Add the size to it.
	addq LOCAL_OFFSET_ALLOCATE_FUNCTION_TOTAL_SIZE_ALIGNED(%rbp), %rdi
	
	# Save this value
	movq %rdi, memory_end

	# Tell Linux where the new break is
	leaq BREAK_SYSCALL, %rax
	syscall

	# Address of new allocation is in %r8
	# Mark the block as unavailable
    	movq $1, OFFSET_HEADER_IN_USE(%r8)

	# Note its size
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_TOTAL_SIZE_ALIGNED(%rbp), %rax
	movq %rax, OFFSET_HEADER_SIZE(%r8)
	
	# Get the block address beyond the header by adding the header size to it.
	addq LOCAL_OFFSET_ALLOCATE_FUNCTION_HEADER_SIZE_ALIGNED(%rbp), %r8
	# Set such value as the returned one.
	movq %r8, %rax

	leave
	ret

.balign	16 # Align to 16 bytes multiple next address	
try_next_individual_memory_allocation:
	# If the block examined before was not convenient (not available or not big enough)
	# Add its size to pointer within %rsi
	addq OFFSET_HEADER_SIZE(%rsi), %rsi
	# Repeat the allocation loop = check whether next block that became current one is available and big enough
	jmp allocate_loop

.balign	16 # Align to 16 bytes multiple next address
deallocate:
	# Freeing an individual memory allocation is simple - we just have to mark it as available
	movq $0, OFFSET_HEADER_IN_USE - HEADER_SIZE(%rdi)
	ret

# DEBUG
# Should I add a function to deallocate a whole block ?
	
	# Set non-executable stack ("") that contains program data "@progbits"
	.section .note.GNU-stack, "", @progbits
