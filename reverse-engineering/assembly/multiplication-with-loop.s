# Test to perform
# number_of_numbers >= 2 -> An addition needs at least two elements.
# numbers_to_multiply[index] >= 0 -> Deny (my decision) to multiply by negative numbers. 

# Registers are :
# %rax = accumulator, the current result.
# %rbx = current element of the array.
# %rcx = counter to loop on the array of numbers to multiply.
# %rdx = counter of times that the current result of the beginning of the loop has to be added to the current REAL result in order to simulate an addition.
# %rdi = the address of current array element processed.
# %r8 = the current result at the beginning of the step - it has to be conserved in a different variable than the '%rax' accumulator as this latter will evolve (increase) at each loop (one loop = one addition of the current result at the beginning of the step with the real current result)

.globl _start

.section .data
number_of_numbers:
	# Set here the size of the array below (the list length of the numbers to multiply)
	# This has to be >=2 as at least 2 numbers are needed for the multiplication.
	# WARNING :
	# if the number is :
	#	bigger than the length of the array, there will be unpredictable result as the program will access not owned memory. It is on you own responsibility to set correctly this result.
	# 	lower than the length of the array, only the first NUMBER elements of the array will be multiplied.
	.quad 7
	
numbers_to_multiply:
	# Set here the list of numbers to multiply.
	.quad 1, 2, 3, 2, 1, 4, 5
	
.section .text
_start:
	# Initialisation of current result (1 * ANYTHING = ANYTHING)
	movq $1, %rax
	
	# The number of elements is taken.
	addq number_of_numbers, %rcx

	# Check if the latter is bigger 1 as a multiplication needs at least 2 elements to be performed. Exit with error else.
	cmp $2, %rcx
	# Jump if ARG2 is below or equal to ARG1 ('cmp ARG1, ARG2')
	jb exit_with_error
	
	# Get the address of first element
	movq $numbers_to_multiply, %rdi

get_next_element_plus_checks:
	# Get current element
	movq (%rdi), %rbx

	# Check if the latter is below '0' and exit with error if so.
	cmp $0, %rbx
	jb exit_with_error

	# Check if the latter is '0' and exit faster because 'ANYTHING * 0 = 0' so no need to continue the multiplication process.
	je exit_fast_return_code_zero
	
	# Save current element as the counter of the addition needed to reproduce the multiplication.
	movq %rbx, %rdx

	# Save the current result at the beggining of each big loop.
	# This one will be added to the current result '%rax' to increase it by adding X times to reproduce a multiplication.
	movq %rax, %r8

	# Perform addition to reproduce a multiplication
	jmp addition_instead_of_multiplication

addition_instead_of_multiplication:
	# Decrease the counter at the beginning of the loop as it has to be '0' at the end so we need to 
	subq $1, %rdx
	# If it becomes zero -> get out of this loop.
	jz check_counter
	
	# Else, add the current result of the beginning of the loop to the current REAL result.
	# It is done by byte 'addb' as my wish is to control whether there is an overflow (unsigned values on 8 bits goes from 0-255)
	addb %r8b, %al
	
	# Check for overflow (only result from 0-255 are accepted)
	# If the carry flag was set, it means that the precedent arithmetic operation resulted in a value bigger than the size of the operation
	jc exit_with_error
	
	# Loop again
	jmp addition_instead_of_multiplication
	
check_counter:	
	# Check the counter to see if there is still another array element to get.
	# If so, get the next address and loop again.
	loopq get_next_address
	# This check is necessary to avoid 'Segmentation fault' trying to access memory not owned after the array end.

	# Else end program.
	jmp end_of_program

get_next_address:	
	addq $8, %rdi
	jmp get_next_element_plus_checks

exit_fast_return_code_zero:
	movq $0, %rax
	jmp end_of_program
	
exit_with_error:
	movq $1, %rax
	jmp end_of_program
	
end_of_program:	
	# Set exit return value
	movq %rax, %rdi
	# Exit system call (60)
	movq $60, %rax
	syscall
	
