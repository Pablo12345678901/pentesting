	# This script count the number of lowercase letter in a string of characters (without space/tab/return) of maximum 49 chars (+1 for the null char) provided by the user.
	# At the end, it will ask the user if he wants to continue - if yes, he provides '1' as answer.
	# Providing anything else will stop the program.
	.globl main

	.section .data

ask_user_input:
	.ascii "Please provide a string of maximum length 49 chars - without space/tab.\n-> \0"

scan_format_string:
	# The maximum size will be 49 chars, that the final string will measure maximum 50 chars - 'null char' included
	.ascii "%49s\0"
	
result_message:
	.ascii "The total number of lowercase letter within the string provided is : %d \n\0"
	
	.section .text

	# The string is 50 bytes long - but the space was rounded to 8 bytes up to 56 in order to facilitate further alignment to 16 bytes.
	.equ LOCAL_OFFSET_STRING, -56
	.equ LOCAL_OFFSET_COUNTER, -64
	.equ LOCAL_OFFSET_CONTINUE, -72

message_ask_whether_to_continue:
	.ascii "Would you like to scan another string ? \nPress 1 to continue or anything else to end this program.\n\0"
	
scan_format_continue:
	.ascii "%d\0"
	
message_confirmation_exit:
	.ascii "You choosed to end this program.\n\0"
	
main:
	# Making space for variables :
	# - one of them containing 50 chars (rounded up to 56 bytes)
	# - the counter of lowercase letters
	# - the continue 'flag' provided by the user
	enter $80, $0

	# Ask user input
	movq stdout, %rdi
	leaq ask_user_input, %rsi
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf
	
	# Scan user input
	movq stdin, %rdi
	leaq scan_format_string, %rsi
	leaq LOCAL_OFFSET_STRING(%rbp), %rdx 
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fscanf
	
	# Get address of first char and keep it within a register
	leaq LOCAL_OFFSET_STRING(%rbp), %rbx
	
	# Set counter of lowercase letter.
	movq $0, LOCAL_OFFSET_COUNTER(%rbp)
	
main_loop:
	# Load the char value into another register to check its value when debugging.
	movb (%rbx), %r8b
	
	# Check if current char is the null char '\0' and exit program if so.
	cmpb $0, %r8b
	je end
	
	cmpb $'a', %r8b
	jb get_next_char_address
	
	cmpb $'z', %r8b
	ja get_next_char_address
	
	# Else increase counter of lowercase letter.
	incq LOCAL_OFFSET_COUNTER(%rbp)

get_next_char_address:
	# Increase = + 1 = get next byte address.
	incq %rbx
	jmp main_loop

end:
	# Print result message
	movq stdout, %rdi
	leaq result_message, %rsi
	movq LOCAL_OFFSET_COUNTER(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Set a clean exit code for 'main'.
	xor %rax, %rax

	# Ask user input - whether to continue or not
	movq stdout, %rdi
	leaq message_ask_whether_to_continue, %rsi
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Set the flag to a non-1 value
	# This is mandatory as soon as the program re-start - else if user write a non-decimal number (a char 'w' for example), it will compare latest value that was already 1 with 1 and continue.
	movq $0, LOCAL_OFFSET_CONTINUE(%rbp)
	
	# Scan user answer
	movq stdin, %rdi
	leaq scan_format_continue, %rsi
	leaq LOCAL_OFFSET_CONTINUE(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fscanf

	# If the value provided by the user is '1', repeat the program from the beginning.
	cmpq $1, LOCAL_OFFSET_CONTINUE(%rbp)
	# Jump conditionaly depending on user input
	je restart
	jne definitive_exit

restart:
	# Re-set stack as in initial state
	leave
	# Re-start program
	jmp main
	
definitive_exit:	
	# Else print exit message
	movq stdout, %rdi
	leaq message_confirmation_exit, %rsi
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Set clean exit return code for 'main'
	xor %rax, %rax
	
	leave
	ret

