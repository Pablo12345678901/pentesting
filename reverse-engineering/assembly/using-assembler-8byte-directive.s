	# This program aims to reproduce exponent computation as in, for example : 2 ^ 5 = 32
	# It uses the '.8byte' directive instead of '.quad' and is very simple.
	.globl _start

	# This section was added to separate the data of the program
	# Adapt data here to compute with other numbers
	# WARNING : result has to be between 0-255, if it is up, it will cause overflow and garbage value will be returned instead as it only consider 8 last bits.	
	.section .data
base:
	.8byte 3
	
exponent:
	.8byte 5
	
	.section .text
_start:
	# '%rbx' holds the base
	movq base, %rbx

	# '%rcx' holds the current exponent count
	movq exponent, %rcx

	# Store the accumulate value into '%rax'
	# By the way, set default result to '1' as it equals all base with exponent '0'.
	# Example : (10000 ^ 0 = 1) -> everything power '0' will always be '1'.
	movq $1, %rax

mainloop:
	# Add '0' to the exponent count in order to compare in next operation while '%rcx was or was not stop and process to the correspondent action.
	addq $0, %rcx

	# Only if the counter '%rcx' was '0' -> finish program
	# 'jz' means 'jump if the precedent operation resulted in zero
	jz complete

	# If the counter '%rcx' was not zero
	# Multiply current result (held in '%rax') by the base
	mulq %rbx
	# %rax = %rbx * %rax

	# Decrease of 1 the counter -> so %rcx-=1
	decq %rcx

	# Repeat the loop until 
	jmp mainloop
	
complete:
	# Save the exit return code value from '%rax' to '%rdi'
	movq %rax, %rdi

	# Set the exit system call (60)
	movq $60, %rax
	syscall
