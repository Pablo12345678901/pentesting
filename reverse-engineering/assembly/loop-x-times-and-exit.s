.globl _start

.section .data

# Adapt here the number of loop wished.
number_of_loop_wished:
	# Test values :
	#.quad 0 # returns error (1) as there is no loop.
	#.quad 1 # returns normal code (itself)
	.quad 128 # returns normal code (itself) - it is the middle of the range 0-255.
	#.quad 254 # returns normal code (itself)
	#.quad 255 # returns normal code (itself)
	#.quad 256 # returns error (1) as it is above 255 (see the 'cmpq $255, %rbx' line), and so, even if the last 8 bits are set to '0' equivalent to '0' number written in byte,
	#	so this check works : 	cmpb $0b00000000, %bl
	#	but this one fails  :	cmpq $255, %rbx
	.quad 257 # returns error (1) as it is above 255 (see the 'cmpq $255, %rbx' line)
	
.section .text

_start:
	# Loading the number of wished loop into the register '%rbx'.
	movq number_of_loop_wished, %rbx

	# Check if loop wished is '0' (8 last bits comparison only).
	cmpb $0b00000000, %bl 
	# Only if '%rbx' is not 0 (8 last bits), set the counter.
	cmovnzq %rbx, %rcx
	# Else exit with error code (zero flag is set)
	jz error_exit
	
	# Check if '%rbx' is above 255 and exit with error if so.
	cmpq $255, %rbx
	ja error_exit
	
loop_again:
	# Decrement '%rcx' and loop as long as it is not '0'
	loopq loop_again
	# After, when '%rcx' is '0', it ends program without executing instructions of next 'dummy_section'.
	jmp normal_exit

dummy_section:
	incq %rcx

error_exit:
	# Set exit return code to error = 1
	movq $1, %rdi
	jmp end_of_program
	
normal_exit:
	# Set exit return code
	movq number_of_loop_wished, %rdi
	jmp end_of_program
	
end_of_program:	
	# Exit system call (60)
	movq $60, %rax
	syscall
