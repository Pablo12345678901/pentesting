	# This script will check at each index of the array if the searched value is the one on the current index.
	# If so, it breaks the loop and return this index as exit code.
	# Else, it returns 255 (as such value such not be one my index).
	# That way, it is known it the value (and its index) was found.
	
	.globl _start

	.section .data

number_of_numbers:
	.quad 7
	
list_of_numbers:
	.quad 200, 20, 33, 80, 52, 10, 100

number_searched:
	# Program test values
	.quad 200
	#.quad 20
	#.quad 100
	#.quad 10
	#.quad 44 # Value not in array - should return 255 exit code.
	
	.section .text
_start:
	# Registers used :
	# %rax : current index content value - and at the end, replaced by the syscall number.
	# %rbx : number to check if it is part of array.
	# %rcx : loop counter
	# %rdi : current result and exit return code
	# %rsi : current index

	# Set the first index explored (last array index + 1)
	movq number_of_numbers, %rcx
	
	# IF array has no value, ends.
	cmp $0, %rcx
	je end_of_program

	# ELSE
	# Set the first index
	movq $0, %rsi
	
	# Set default exit code to 255 as it is the largest code index of a range (0-255) and usually, array in my programs does never has such a big size.
	movq $255, %rdi
	
	# Set searched value
	movq number_searched, %rbx

main_loop:
	# Get current value but start with an offset of '-8' to ensure that only index 0 to X (array max index) and not 1 to X+1 are explored as %rcx start at the number of elements which is also index max+1.
	movq list_of_numbers(, %rsi, 8), %rax

	# Compare current value with searched value.
	cmp %rbx, %rax

	je searched_value_found_set_exit_code_and_exit

	jne loop_control
	
searched_value_found_set_exit_code_and_exit:
	# Set return code to the current 'index -1' because the counter register %rcx goes from range 'index-max+1' to 'index-min+1'
	movq %rsi, %rdi

	# Then exit
	jmp end_of_program

loop_control:	
	# Increase current index for the next loop - if any.
	incq %rsi
	
	# Check if still index to check (%rcx > 0) and if so loop.
	loopq main_loop
	jmp end_of_program
	
end_of_program:
	movq $60, %rax
	syscall
