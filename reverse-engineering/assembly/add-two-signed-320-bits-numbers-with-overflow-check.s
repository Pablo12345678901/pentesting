	# This program will add two signed 320 bits (= 5 * 64 bits) register number and save the value within the registers combination :
	#   %r8:%r9:%r10:%r11:%r12
	# + %rax:%rbx:%rcx:%rdx:%rsi
	#___________________________
	# = %rax:%rbx:%rcx:%rdx:%rsi
	# As this value is 320 bits is too big to be returned, a debugguer is needed to check all 5 results value.
	# The exit return code '%rdi' represents whether an overflow occurs by checking whether the overflow flag is set after the last addition.
	# The value returned is '1' if overflow (overflow flag set) or '0' else.

	.globl _start
	.section .text
	
_start:
	# Set default exit return code value to '0'.
	movq $0, %rdi
	
	# Set all registers.
	
	# FIRST NUMBER REGISTERS (DEST)
	# (un)comment one of the two lines below representing the value of the most significant register of the 320 bits number.
	# Depending on the behaviour wished :
	#	- if no overflow is wished, uncomment first line : the most significant register will contain the 'maximum signed value -1' : '01...10'. As a carry will result from the precedent addition, final result will be 'maximum signed value' : '01...1'.
	#	- else if overflow is wished, uncomment first line : the most significant register will contain the 'maximum signed value' : '01...1'. As a carry will result from the precedent addition, final result will be 'minimum signed value' : '10...0' = OVERFLOW
	movq $0b0111111111111111111111111111111111111111111111111111111111111110, %rax # Uncomment for NO OVERFLOW
	#movq $0b0111111111111111111111111111111111111111111111111111111111111111, %rax # Uncomment for OVERFLOW
	#-----------------------------------------------------------------------------
	# The register 2, 3 and 4/5 will contain '1...0' that when added to '1 + a carry' will result in '0..0' and a carry. 
	movq $0b1111111111111111111111111111111111111111111111111111111111111110, %rbx
	movq $0b1111111111111111111111111111111111111111111111111111111111111110, %rcx
	movq $0b1111111111111111111111111111111111111111111111111111111111111110, %rdx
	# The least significant register will contain '1...1' that when added to '1' will result in '0...0 and a carry.
	movq $0b1111111111111111111111111111111111111111111111111111111111111111, %rsi

	# SECOND NUMBER REGISTERS (SOURCE)
	# Most significant register will contain '0...0' = 0.
	movq $0b0000000000000000000000000000000000000000000000000000000000000000, %r8
	# 4 least significant registers will contain '0...1' = 1.
	movq $0b0000000000000000000000000000000000000000000000000000000000000001, %r9
	movq $0b0000000000000000000000000000000000000000000000000000000000000001, %r10
	movq $0b0000000000000000000000000000000000000000000000000000000000000001, %r11
	movq $0b0000000000000000000000000000000000000000000000000000000000000001, %r12

	# REMARK ABOUT ADDITION
	# All addition except the last one will result in '0 + a carry'.
	# The last addition will result in the maximal signed value (01...1) or the minimum signed value '10...0' with an overflow depending on the (un)commented line defining the value of the '%rax' register.
	
	# Add the two least significant registers of each number (one least with the least of the other number).
	addq %r12, %rsi

	# Add with carry all pairs of 64 bits registers starting from the least significant ones.
	adcq %r11, %rdx
	adcq %r10, %rcx
	adcq %r9, %rbx
	adcq %r8, %rax

	# Check for the overflow flag of last operation and jump to specific section depending on whether it is set.
	jo overflow_occurred
	jno end_of_program
	
overflow_occurred:
	# Set the exit code to '1' if an overflow occurred.
	movq $1, %rdi
	
end_of_program:
	# Exit syscall
	movq $60, %rax
	syscall
