	# This program is an enhancement of the file 'allocate.s'.
	# New features :
	# All addresses are aligned to a 16 bytes multiple as requested by standard C library functions with x86-64 architecture.
	# To do so :
	# - before each memory location as for example 'allocate' was added a directive '.balign 16' just before.
	# - each part of the allocation blocks have size rounded up to a 16 multiple with the function 'round_up_number_to_a_16_multiple'. All of those (when aligned) are saved on the stack. To help code readibility.
	# - even the program break is rounded up to a 16 multiple with the same function. It is not needed as it is already aligned but was coded for fun. It is saved on stack too.
	# Old features that still apply : 
	# This program tries to reproduce 'malloc' and 'free' implementation.
	# It will first check whether the memory pointers ('memory_start' and 'memory_end', that represents the pointer to were a block starts and were it ends) were initialized.
	# Then, if not, it will initialize them to current 'program break'.
	# Then it will process to a loop until allocation was performed :
	# It will check whether both pointer are equal : whether all blocks were checked so far and if so, save the current program break to be returned and then move it of the total size (total size = requested + header size).
	# Else, it will check the current block composed of a header and the block content.
	# The header size if composed of two quadwords :
	# - first  : a flag that shows whether the block examined is in use ('1') or not ('0').
	# - second : the size of such block (= header + block content)
	# So, it will first check whether the block is available and if not, add its size to the current 'memory start' (start of the block) to obtain address of next block.
	# Else, it will check whether the block content size (second quadword of the header) is enough for the requested size (total size = requested + header).
	# If it is enough, it will allocate the block but setting the first quadword of the header to unavailable (=1) and return the address of the current memory_start + header size = pointer to block content.
	# Else, it will check the next block.
	# This program have to be linked with the 'C' program 'use-allocate-and-deallocate-functions.c' and then this later executed.

# --------------------------------------------------------------------------------------------------
	
	.globl allocate, deallocate
	.type allocate, @function
	.type deallocate, @function
	.type round_up_number_to_a_16_multiple, @function

# --------------------------------------------------------------------------------------------------
	
	# Allocate two quadword (8 bytes each) within uninitialized data section '.bss'.
	.section .bss
	
.balign	16 # Align to 16 bytes multiple next address
memory_start:
	.zero 8
.balign	16 # Align to 16 bytes multiple next address
memory_end:
	.zero 8
	
# --------------------------------------------------------------------------------------------------
	
	.section .rodata
	
.balign	16 # Align to 16 bytes multiple next address
message_print_number_to_be_align:
	.ascii "Number or address to be aligned : %d = %s.\n\0"
	
.balign	16 # Align to 16 bytes multiple next address	
message_print_number_aligned:
	.ascii "Number or address       aligned : %d = %s.\n\0"

.balign	16 # Align to 16 bytes multiple next address	
name_requested_size:
	.ascii "requested size\0"

.balign	16 # Align to 16 bytes multiple next address	
name_header:	
	.ascii "header size\0"

.balign	16 # Align to 16 bytes multiple next address	
name_total_size:	
	.ascii "total size\0"

.balign	16 # Align to 16 bytes multiple next address	
name_program_break:	
	.ascii "program break\0"

.balign	16 # Align to 16 bytes multiple next address	
message_new_program_break_set:
	.ascii "\nA new program break was set to the address %d.\n\0"
	
# --------------------------------------------------------------------------------------------------
	
	.section .text

# --------------------------------------------------------------------------------------------------
	
	# Local variable(s) for the function 'round_up_number_to_a_16_multiple'
	.equ LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_TO_ALIGN, -8
	.equ LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_ALIGNED, -16
	.equ LOCAL_OFFSET_ROUND_FUNCTION_NAME_OF_WHAT_IS_ALIGNED, -24


.balign	16 # Align to 16 bytes multiple next address	
round_up_number_to_a_16_multiple:
	# This function takes a number and will round it up to a 16 bytes multiple.
	# In some case, it is not an address, just a byte(s) number - in other it is an address (=also a number).
	
	# Make space on the stack for variable(s) :
	# - number to align
	# - number aligned
	# - name of what is aligned for printed message
	enter $32, $0

	# Save the address provided on the stack
	movq %rdi, LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_TO_ALIGN(%rbp)
	# Save the name of what is aligned on stack for printed message
	movq %rsi, LOCAL_OFFSET_ROUND_FUNCTION_NAME_OF_WHAT_IS_ALIGNED(%rbp)

	# Print initial number to be aligned
	movq stdout, %rdi
	leaq message_print_number_to_be_align, %rsi
	movq LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_TO_ALIGN(%rbp), %rdx
	movq LOCAL_OFFSET_ROUND_FUNCTION_NAME_OF_WHAT_IS_ALIGNED(%rbp), %rcx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf
	
	# Division
	# Load number to divide on accumulator register
	movq LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_TO_ALIGN(%rbp), %rax
	# Set %rdx to '0' for further division
	movq $0, %rdx
	# Set divisor to 16 (bytes)
	movq $16, %rdi
	# Divide address by 16
	divq %rdi

	# Re-set %rax to the initial address
	movq LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_TO_ALIGN(%rbp), %rax

	# Check whether is it a multiple of 16 (if %rdx = 0)
	cmpq $0, %rdx
	# If so - get to final part.
	je final_message_and_return

	# Else, the number is not a 16 multiple and there is a remainder in %rdx.
	# So the number has to rounded up to a 16 multiple.
	# So compute what has to be added to it as '16 - remainder'
	subq %rdx, %rdi
	
	# And add to it to initial number to get aligned one
	addq %rdi, %rax

.balign	16 # Align to 16 bytes multiple next address	
final_message_and_return:
	# Save aligned address on stack
	movq %rax, LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_ALIGNED(%rbp)
	
	# Print aligned number
	movq stdout, %rdi
	leaq message_print_number_aligned, %rsi
	movq LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_ALIGNED(%rbp), %rdx
	movq LOCAL_OFFSET_ROUND_FUNCTION_NAME_OF_WHAT_IS_ALIGNED(%rbp), %rcx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Return the aligned address
	movq LOCAL_OFFSET_ROUND_FUNCTION_ADDRESS_ALIGNED(%rbp), %rax 
	
	leave
	ret

# --------------------------------------------------------------------------------------------------

 	# Local variable(s) for the function 'allocate' (and other code part that it calls)
	# - requested size to align
	# - requested size aligned
	# - break address to align
	# - break address aligned
	.equ LOCAL_OFFSET_ALLOCATE_FUNCTION_REQUESTED_SIZE_ALIGNED, -8
	.equ LOCAL_OFFSET_ALLOCATE_FUNCTION_HEADER_SIZE_ALIGNED, -16
	.equ LOCAL_OFFSET_ALLOCATE_FUNCTION_TOTAL_SIZE_ALIGNED, -24
	.equ LOCAL_OFFSET_ALLOCATE_FUNCTION_BREAK_ADDRESS_ALIGNED, -32
	
	# The header is composed of two quadwords :
	# - first  : a flag that shows whether the block examined is in use ('1') or not ('0').
	# - second : the size of such block (= header + block content)
	.equ OFFSET_HEADER_IN_USE, 0
	.equ OFFSET_HEADER_SIZE, 8
	.equ HEADER_SIZE, 16
	
	# This constant is used to help code reading.
	.equ BREAK_SYSCALL, 12

.balign	16 # Align to 16 bytes multiple next address	
allocate:
	# Make space for variable(s) on stack
	# - requested aligned size
	# - header aligned size
	# - total aligned size
	# - program break aligned
	enter $32, $0
	
	# Align requested size
	#movq %rdi, %rdi # size - not needed to be updated as it is already in %rdi
	leaq name_requested_size, %rsi # name of what is aligned
	call round_up_number_to_a_16_multiple

	# Save the requested aligned size on the stack
	movq %rax, LOCAL_OFFSET_ALLOCATE_FUNCTION_REQUESTED_SIZE_ALIGNED(%rbp)
	
	# Align header size
	leaq HEADER_SIZE, %rdi
	leaq name_header, %rsi
	call round_up_number_to_a_16_multiple

	# Save the header aligned size on the stack
	movq %rax, LOCAL_OFFSET_ALLOCATE_FUNCTION_HEADER_SIZE_ALIGNED(%rbp)

	# Set the size to align to the requested one
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_REQUESTED_SIZE_ALIGNED(%rbp), %rdi
	# Add the header size to this requested size as each block is added a header at the beginning.
	addq LOCAL_OFFSET_ALLOCATE_FUNCTION_HEADER_SIZE_ALIGNED(%rbp), %rdi

	# Align total size - not needed as both the requested size + the header were aligned - but cool to show anyway.
	leaq name_total_size, %rsi
	call round_up_number_to_a_16_multiple

	# Save the total size aligned on the stack
	movq %rax, LOCAL_OFFSET_ALLOCATE_FUNCTION_TOTAL_SIZE_ALIGNED(%rbp)
	
	# Compare the memory start with '0' to check whether the initialization was already not done
	cmpq $0, memory_start
	# If so, process to initialization
	je allocate_init
	# Else, skip the initialization
	jne allocate_continue

.balign	16 # Align to 16 bytes multiple next address	
allocate_init:
	# Get the current program break
	movq $0, %rdi
	leaq BREAK_SYSCALL, %rax
	syscall

	# Align the program break
	movq %rax, %rdi
	leaq name_program_break, %rsi
	# Align address to a 16 bytes multiple
	call round_up_number_to_a_16_multiple
	
	# Save the program break aligned address on the stack
	movq %rax, LOCAL_OFFSET_ALLOCATE_FUNCTION_BREAK_ADDRESS_ALIGNED(%rbp)
	
	# Request such new aligned program break to be set as the current one
	# Get the current program break
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_BREAK_ADDRESS_ALIGNED(%rbp), %rdi
	leaq BREAK_SYSCALL, %rax
	syscall
	# Here we could check whether such program break was applied but I did not want to implement it.

	# The current break will be both the start and end of our memory
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_BREAK_ADDRESS_ALIGNED(%rbp), %rax
	movq %rax, memory_start
	movq %rax, memory_end

	# Print message to tell user that new program break was set.
	movq stdout, %rdi
	leaq message_new_program_break_set, %rsi
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_BREAK_ADDRESS_ALIGNED(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf
		
	jmp allocate_continue

.balign	16 # Align to 16 bytes multiple next address	
allocate_continue:
	# Load values of the pointer to the start and end of memory within registers.
	movq memory_start, %rsi
	movq memory_end, %rcx

	jmp allocate_loop

.balign	16 # Align to 16 bytes multiple next address
allocate_loop:
	# Check whether the end of memory was reached -> memory start = memory end
	cmpq %rsi, %rcx
	# If it is the case, move the program break
	je allocate_move_break
	
	# Else, check whether the next block is available from its 'flag' (OFFSET_HEADER_IN_USE(%rsi)) within the header
	cmpq $0, OFFSET_HEADER_IN_USE(%rsi)
	# If not, try next block.
	jne try_next_block

	# Else, compare the block size with what was requested
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_TOTAL_SIZE_ALIGNED(%rbp), %rax
	cmpq %rax, OFFSET_HEADER_SIZE(%rsi)
	# If the block size is below what is requested, try next block.
	jb try_next_block
	# Else the block available is sufficiently big for the request.
	# So mark it as unavailable.
	movq $1, OFFSET_HEADER_IN_USE(%rsi)
	# Move address beyond the header
	addq LOCAL_OFFSET_ALLOCATE_FUNCTION_HEADER_SIZE_ALIGNED(%rbp), %rsi
	# And return such address
	movq %rsi, %rax

	leave
	ret
	
.balign	16 # Align to 16 bytes multiple next address
allocate_move_break:
	# Old break is save in %r8 to be later returned to user
	movq %rcx, %r8

	# Calculate where the new break will be
	# = old break + size
	# Set %rdi to the old break.
	movq %rcx, %rdi

	# Add the size to it.
	addq LOCAL_OFFSET_ALLOCATE_FUNCTION_TOTAL_SIZE_ALIGNED(%rbp), %rdi
	
	# Save this value
	movq %rdi, memory_end

	# Tell Linux where the new break is
	leaq BREAK_SYSCALL, %rax
	syscall

	# Address of new allocation is in %r8
	# Mark the block as unavailable
    	movq $1, OFFSET_HEADER_IN_USE(%r8)

	# Note its size
	movq LOCAL_OFFSET_ALLOCATE_FUNCTION_TOTAL_SIZE_ALIGNED(%rbp), %rax
	movq %rax, OFFSET_HEADER_SIZE(%r8)
	
	# Get the block address beyond the header by adding the header size to it.
	addq LOCAL_OFFSET_ALLOCATE_FUNCTION_HEADER_SIZE_ALIGNED(%rbp), %r8
	# Set such value as the returned one.
	movq %r8, %rax

	leave
	ret

.balign	16 # Align to 16 bytes multiple next address	
try_next_block:
	# If the block examined before was not convenient (not available or not big enough)
	# Add its size to pointer within %rsi
	addq OFFSET_HEADER_SIZE(%rsi), %rsi
	# Repeat the allocation loop = check whether next block that became current one is available and big enough
	jmp allocate_loop

.balign	16 # Align to 16 bytes multiple next address
deallocate:
	# Freeing a block is simple - we just have to mark it as available
	movq $0, OFFSET_HEADER_IN_USE - HEADER_SIZE(%rdi)
	ret

	# Set non-executable stack ("") that contains program data "@progbits"
	.section .note.GNU-stack, "", @progbits
