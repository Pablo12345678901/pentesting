	# This program aims to reproduce exponent computation (example : 2 ^ 5 = 32) through a function.
	# The later will loop to multiply X times the same number by itself reproducing an exponent computation. 2 * 2 * 2 * 2 * 2 = 2 ^5 = 32
	# It has to be linked with another program using the 'exponent' function.
	.globl exponent
	.type exponent, @function

	.section .text
exponent:
	# %rdi holds the base.
	# %rsi holds the exponent.
	
	# Aligning the stack to a 16 bytes multiple.
	# The stack will hold a local temporary variable initialized to the exponent as this latter will be used to loop (decremented at each loop until reach '0'.)
	enter $16, $0
	# Put (and not push) the exponent onto the stack.
	# As this later is a 8 bytes (64 bits) register, it will be used as an offset of 8 bytes to the '%rbp' (base pointer) = -8(%rbp)
	movq %rsi, -8(%rbp)
	
	# Set the accumulator to '1' as default result. Thay way, 'ANYTHING * 1 = ANYTHING' for the first multiplication.
	# Also, it covers the case where the 'exponent' is '0' => ANYTHING ^ 0 = 1
	movq $1, %rax

	# Check whether the exponent is '0' and leave function if so.
	cmpq $0, -8(%rbp)
	je complete
	
main_loop:
	# Multiply the accumulator by the base number.
	mulq %rdi
	# Decrease the 'exponent' at each multiplication.
	decq -8(%rbp)
	# If exponent is zero, return from function.
	# Repeat the loop until the exponent number is zero
	jnz main_loop
	
complete:
	# 'leave' answers to the above 'enter' instruction.
	leave
	# The function will return to the next instruction address and the result of the exponent computation will be held within '%rax'.
	ret
