# Some useful command for debugging with gdb

# Run gdb :
gdb
...

# WARNING : all commands below has to be runned AFTER typing 'gdb' followed by 'enter'.

# Load a program
# from within gdb...
file PATH-TO-PROGRAM

# Run the program loaded.
run

# Add a breakpoint at the beginning (_start [label/symbol] defined in the program.)
break *_start
# Followed by :
run
# This will stop at the next breakpoint.

# To see all breakpoints :
info break

# To remove a breakpoint
# Ge the breakpoint number from 'info break'
delete BREAKPOINT-NUMBER

# To create a breakpoint on any instruction from its address
# 'break *ADDRESS'
# where address is the memory address of the instruction as given by gdb.
# Example to reach the instruction on the line :
# '    0x000000000040100e <+14>:	mov    $0x0,%rdi'
# (see below) :
break *_start+14
# It is also possible to give an address instead of the name of a function.
# But HERE without '*'
# Example to reach the instruction on the line :
# '   0x0000000000401007 <+7>:	mov    $0x21,%rdi'
# (see below) :
# I did not test it...

# Disassembly the current function - where the breakpoint is.
disassemble
# Exemple of output :
# ------------------------------------------
# Dump of assembler code for function _start:
# => 0x0000000000401000 <+0>:	mov    $0x3c,%rax
#    0x0000000000401007 <+7>:	mov    $0x21,%rdi
#    0x000000000040100e <+14>:	mov    $0x0,%rdi
#    0x0000000000401015 <+21>:	syscall
# End of assembler dump.
# ------------------------------------------
#
# Decomposing this line :
# '=> 0x0000000000401000 <+0>:	mov    $0x3c,%rax'
# '=>' : Points to current instruction.
# '0x00...0' : address of the instruction.
# '<+0>' : offset from the start of the nearest previous label or function (here the '_start'
# Values as '$0x3c' (3*16+12=60), '$0x21' (2*16+1=33) and '$0x0' (=0) are hexadecimal equivalent of values used within the program.
# The values stocked into registers are hexadecimal as computer does not understand decimal - has to be translated.

# To see current registers :
info registers

# Run next line.
stepi

# I can see the changes throught the registers check
info registers

# stepi ... stepi ...
#
# At the end, the program will show a message like :
# [Inferior 1 (process 1867) exited normally]
# 'Inferior 1' is the internal name of the process from within gdb.
# 'exited normally' or 'exited with code NN' shows the exit code that would have been returned to the shell.

# During a debug phase,
# Print individual register value with
# WARNING : register has to be called with '$' instead of '%' for GDB.
print/LETTER $REGISTER
# Possibilities :
print/c -> print as a character
print/d -> print decimal value
print/t -> print binary value
print/x -> print in hexadecimal
# Example
print/t $rax # will print the decimal value of the content of '%rax' register.

# CAST
#
# Casting the quadword to something understandable by GDB (based on C).
print/d (long long)myQuadword
# Other casts includes :
char 	      (single byte)
short 	      (2 bytes)
int or long   (4 bytes)
long long     (8 bytes)
float 	      (4-byte floating-point value)
double 	      (8-byte floating-point value)
int * 	      (8-byte pointer to an int type)
void * 	      (8-byte pointer to an undertermined type)
void **       (8-byte pointer to an eight-byte pointer to an undertermined type)
# Example :
# Get the pointer to an integer with :
# Dereference with '*'
print/d *(int *)$rax
