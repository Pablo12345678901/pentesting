# Summary of basic GDB Commands

(gdb) start                   # Start the program and break at main
(gdb) run (or r)              # Run the program
(gdb) break (or b) function   # Set a breakpoint at a function
(gdb) break *0x12345678       # Set a breakpoint at a memory address
(gdb) continue (or c)         # Continue execution until next breakpoint
(gdb) step (or s)             # Step into the next instruction
(gdb) next (or n)             # Step over the next instruction
(gdb) finish                  # Run until the current function returns
(gdb) print (or p) $reg       # Print value of a register (e.g., p $rax)
(gdb) x/Nfu addr              # Examine memory (N: count, f: format, u: unit size)
(gdb) info registers (or i r) # Display all register values
(gdb) disassemble (or disas)  # Disassemble current function
(gdb) backtrace (or bt)       # Show call stack
(gdb) frame (or f) N          # Select stack frame N
(gdb) info breakpoints        # List all breakpoints
(gdb) delete N                # Delete breakpoint N
(gdb) set disassembly-flavor intel  # Use Intel syntax for disassembly
(gdb) layout asm              # Show assembly in TUI mode
(gdb) layout regs             # Show registers in TUI mode
(gdb) focus cmd               # Switch focus to command window in TUI mode
(gdb) refresh                 # Refresh the screen in TUI mode
(gdb) quit (or q)             # Exit GDB
____________________________________________________________________________

# Some detailed useful command for debugging with gdb

# Run gdb :
gdb
...

# WARNING : all commands below has to be runned AFTER typing 'gdb' followed by 'enter'.

# Set width to a specific size
set width 70

# Load a program
# from within gdb...
file PATH-TO-PROGRAM

# Run the program loaded.
run
# OR
r

# Add a breakpoint at the beginning (_start [label/symbol] defined in the program.)
break *_start
# Followed by :
run
# This will stop at the next breakpoint.

# To see all breakpoints :
info break

# To remove a breakpoint
# Ge the breakpoint number from 'info break'
delete BREAKPOINT-NUMBER

# Break other useful commands :
break *main+123    # Break at offset 123 bytes from start of main
break *0x400500    # Break at specific address
break filename.s:50 # Break at line 50 in your source file
# WARNING :
# 	  For some of those commands, the program has to be compiled with 'debugging symbols' (for example for the command with the file line number).
#	  Those are provided through the gcc '-g' option. Same for 'as' BUT NOT FOR 'ld' as 'ld' will use the debugging symbol present in all object files used.
#
# To create a breakpoint on any instruction from its address
# 'break *ADDRESS'
# where address is the memory address of the instruction as given by gdb.
# Example to reach the instruction on the line :
# '    0x000000000040100e <+14>:	mov    $0x0,%rdi'
#
# (see below) :
break *_start+14
# Or any other label
break *MY_LABEL_DEFINED+OFFSET
#
# It is also possible to give an address instead of the name of a function.
# But HERE without '*'
# Example to reach the instruction on the line :
# '   0x0000000000401007 <+7>:	mov    $0x21,%rdi'
# (see below) :
# I did not test it...

# Jump to next breakpoint
continue
# Or
C

# Disassembly the current function - where the breakpoint is.
disassemble
# Or
disas
# Exemple of output :
# ------------------------------------------
# Dump of assembler code for function _start:
# => 0x0000000000401000 <+0>:	mov    $0x3c,%rax
#    0x0000000000401007 <+7>:	mov    $0x21,%rdi
#    0x000000000040100e <+14>:	mov    $0x0,%rdi
#    0x0000000000401015 <+21>:	syscall
# End of assembler dump.
# ------------------------------------------
#
# Decomposing this line :
# '=> 0x0000000000401000 <+0>:	mov    $0x3c,%rax'
# '=>' : Points to current instruction.
# '0x00...0' : address of the instruction.
# '<+0>' : offset from the start of the nearest previous label or function (here the '_start'
# Values as '$0x3c' (3*16+12=60), '$0x21' (2*16+1=33) and '$0x0' (=0) are hexadecimal equivalent of values used within the program.
# The values stocked into registers are hexadecimal as computer does not understand decimal - has to be translated.

# To see current registers :
info registers

# Print the value of one register
# WARNING : a '$' in used here - no '%'
print $register_name
# or
p $register_name

# Run next line.
stepi
# Or :
si

# Run the next N (=NUMBER) lines
stepi N
# OR
si N

# stepi ... stepi ...
#
# At the end, the program will show a message like :
# [Inferior 1 (process 1867) exited normally]
# 'Inferior 1' is the internal name of the process from within gdb.
# 'exited normally' or 'exited with code NN' shows the exit code that would have been returned to the shell.

___________________________________________________________________

# Usage of breakpoints, 'step', and 'stepi' in the context of assembly and C functions:
#
# IMPORTANT : to get debugging symbols, compile with gcc '-g' option (same for 'as' and 'ld').
#
#    Breakpoints:
#        The command break function_name (or b function_name) works for both assembly and C functions, as long as the symbol information is available.
#        For assembly functions, you need to have labeled your functions in the assembly code.
#        For C functions, the debugging symbols must be present (compiled with -g flag).
#    'step' vs 'stepi':
#        'step' (or 's'):
#            In C code: Steps to the next source line.
#            In assembly: Behaves like 'stepi', executing the next instruction.
#        'stepi' (or 'si'):
#            Always executes a single machine instruction, regardless of whether you're debugging C or assembly.

# When to use which:
#    Use 'step' when:
#        Debugging C code and you want to move line by line through the source.
#        In assembly, it behaves the same as 'stepi', so you can use either.
#    Use 'stepi' when:
#        You specifically want to execute one machine instruction at a time, regardless of the source language.
#        Debugging optimized code where source lines don't correspond directly to instructions.
#        Examining the low-level execution of a program, even if it was written in C.

# In the context of your assembly program:
#    Use 'break main' to set a breakpoint at the start of your main function.
#    Use 'stepi' to step through your assembly code instruction by instruction.
#    If you've defined other functions in your assembly code with labels, you can use 'break function_label' to set breakpoints at those functions.

# When debugging assembly code, 'stepi' is generally more useful as it gives you precise control over the execution of each instruction.
# 'step' and 'stepi' will behave the same in pure assembly code, but 'stepi' is more explicit about its behavior.
___________________________________________________________________

# I can see the changes throught the registers check
info registers

# During a debug phase,
# Print individual register value with
# WARNING : register has to be called with '$' instead of '%' for GDB.
print/LETTER $REGISTER
# Possibilities :
print/c -> print as a character
print/d -> print decimal value
print/t -> print binary value
print/x -> print in hexadecimal
# Example
print/t $rax # will print the decimal value of the content of '%rax' register.

# CAST
#
# Casting the quadword to something understandable by GDB (based on C).
print/d (long long)myQuadword
# Other casts includes :
char 	      (single byte)
short 	      (2 bytes)
int or long   (4 bytes)
long long     (8 bytes)
float 	      (4-byte floating-point value)
double 	      (8-byte floating-point value)
int * 	      (8-byte pointer to an int type)
void * 	      (8-byte pointer to an undertermined type)
void **       (8-byte pointer to an eight-byte pointer to an undertermined type)
# Example :
# Get the pointer to an integer with :
# Dereference with '*'
print/d *(int *)$rax
