	.globl _start

	.section .data
	
number_to_check:	
	.quad 23
	
string_odd:	
	.ascii "The number is odd.\n"
end_string_odd:
	
string_even:
	.ascii "The number is even.\n"
end_string_even:	

	# Set the length of the data to be written as the difference between data start and data end.
	.equ LENGTH_STRING_ODD, end_string_odd - string_odd
	.equ LENGTH_STRING_EVEN, end_string_even - string_even

	.section .text

_start:
	# Check if the number is odd or even.
	# Load number to check into accumulator register
	movq number_to_check, %rax
	# Set a clean state of the reminder of the division ('0')
	movq $0, %rdx
	# Create a register holding '2' - needed during the division.
	movq $2, %rbx
	# Divide '%rax' by '%rbx' (2) to check with the rest ('%rdx') if it is even or odd - does not work if trying to divide by direct number as '$2'
	divq %rbx
	# Compare the reminder with '0'
	cmp $0, %rdx
	# If reminder is '0', then number is even.
	je write_even
	# Else number is odd.
	jne write_odd

write_odd:
	# Set syscall to 'write' (=1)
	movq $1, %rax
	# Set 'file descriptor' to STDOUT (=1)
	movq $1, %rdi
	# Load address of string
	leaq string_odd, %rsi
	# Set the length of the string to be written
	leaq LENGTH_STRING_ODD, %rdx
	syscall
	jmp end

write_even:	
	# Set syscall to 'write' (=1)
	movq $1, %rax
	# Set 'file descriptor' to STDOUT (=1)
	movq $1, %rdi
	# Load address of string
	leaq string_even, %rsi
	# Set the length of the string to be written
	leaq LENGTH_STRING_EVEN, %rdx
	syscall
	jmp end
	
end:	
	# 'exit' syscall
	xor %rdi, %rdi
	movq $60, %rax
	syscall
