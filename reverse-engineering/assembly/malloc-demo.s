	# This program requests the OS 500 bytes of memory with 'malloc' in order to keep what is written on 'stdin'.
	# Then it writes it to 'stdout' and finally 'free' such memory requested.
	.globl main

	.section .data

scan_format:
	# A string of maximum 499 chars + null char = 500
	.ascii "%499s\0"
	
output_format:
	.ascii "%s\n\0"

	.section .text
	.equ LOCAL_OFFSET_BUFFER, -8
main:
	# Make space for variable :
	# - pointer to memory address requested (memory space of 500 bytes)
	enter $16, $0

	# Asking 500 bytes with 'malloc' standard C library function.
	movq $500, %rdi
	call malloc

	# Save buffer address on the stack
	movq %rax, LOCAL_OFFSET_BUFFER(%rbp)

	DEBUG WHY THIS HERE ???
	movq $5, (%rax)

	# Read data from stdin and write it to the buffer
	movq stdin, %rdi
	leaq scan_format, %rsi
	# Save what is written at the buffer address
	movq LOCAL_OFFSET_BUFFER(%rbp), %rdx
	# No floating-point argument with variadic function.
	movq $0, %rax
	call fscanf

	# Write data to stdout
	movq stdout, %rdi
	movq LOCAL_OFFSET_BUFFER(%rbp), %rsi
	# No floating-point argument with variadic function.
	movq $0, %rax
	call fprintf

	# Free the buffer
	movq LOCAL_OFFSET_BUFFER(%rbp), %rdi
	call free

	# Set exit return code from 'main' to '0'.
	xor %rax, %rax
	
	leave
	ret
