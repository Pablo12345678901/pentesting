	# This script count the number of lowercase letter in a string of characters provided by the user.
	.globl main

	.section .data

ask_user_input:
	.ascii "Please provide a string of maximum length 49 chars - without space/tab.\n-> \0"

scan_format:
	# The maximum size will be 49 chars, that the final string will measure maximum 50 chars - 'null char' included
	.ascii "%49s\0"

result_message:
	.ascii "The total number of lowercase letter within the string provided is :\n%d \n\0"
	
	.section .text

	.equ LOCAL_OFFSET_STRING, -8
	.equ LOCAL_OFFSET_COUNTER, -16
	
main:
	# Making space for three variables
	enter $16, $0

	# Ask user input
	movq stdout, %rdi
	leaq ask_user_input, %rsi
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf
	
	# Scan user input
	movq stdin, %rdi
	leaq scan_format, %rsi
	leaq LOCAL_OFFSET_STRING(%rbp), %rdx 
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fscanf

	# Set counter of lowercase letter.
	movq $0, LOCAL_OFFSET_COUNTER(%rbp)
	
main_loop:
	# Load the char value into another register to check its value when debugging.
	movb LOCAL_OFFSET_STRING(%rbp), %r8b
	
	# Check if current char is the null char '\0' and exit program if so.
	cmpb $0, %r8b
	je end
	
	cmpb $'a', %r8b
	jb get_next_char_address
	
	cmpb $'z', %r8b
	ja get_next_char_address
	
	# Else increase counter of lowercase letter.
	incq LOCAL_OFFSET_COUNTER(%rbp)

get_next_char_address:
	# Increase = + 1 = get next byte address.
	# Debug
	# The address of second char to be tested within the string is currently wrong.
	# Currently, the value of such char is increased by 1, not the address such variable contain.
	incq LOCAL_OFFSET_STRING(%rbp)
	jmp main_loop

end:
	# Print result message
	movq stdout, %rdi
	leaq result_message, %rsi
	movq LOCAL_OFFSET_COUNTER(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Set a clean exit code for 'main'.
	xor %rax, %rax
	
	leave
	ret
