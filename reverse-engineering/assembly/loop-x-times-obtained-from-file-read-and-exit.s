	# This program will read a file 'file_read.txt' to obtain a number of times that it has to loop.
	# It checks errors : will exit (with printed message = written to file) with an different error message if the case is that the number provided is '0' or if it is above 255.
	# Else, it will print (write a file 'file_written.txt') a loop message at each loop with the loop number and a final confirmation message (still written to file).
	.globl main

	.section .data

file_read:
	.ascii "file_read.txt\0"
file_read_open_mode:
	.ascii "r\0"
	
file_written:
	.ascii "file_written.txt\0"
file_written_open_mode:
	.ascii "w\0"

scan_format:
	.ascii "%d\0"
	
loop_message:
	.ascii "Loop number %d.\n\0"
	
exit_error_message_zero_provided:
	.ascii "ERROR : The number provided is '0' therefore no loop will be processed.\n\0"
	
exit_error_message_value_too_big_provided:
	.ascii "ERROR : The number provided '%d' is above 255. Please provided a number in the range 1-255.\n\0"

exit_normal_message:
	.ascii "%d loops were sucessfully processed.\n\0"
	
	.section .text

	.equ LOCAL_OFFSET_NUMBER, -8
	.equ LOCAL_OFFSET_LOOP_COUNTER_FOR_PRINTED_MESSAGE, -16
	.equ LOCAL_OFFSET_LOOP_COUNTER_FOR_LOOPQ, -24
	.equ LOCAL_OFFSET_FILE_STRUCT_READ, -32
	.equ LOCAL_OFFSET_FILE_STRUCT_WRITTEN, -40

main:
	# Making space for variables :
	# - the number of requested loop
	# - the loop counter for printed message (increasing)
	# - the loop counter for loopq (decreasing)
	# - two pointers to file struct for read and written files
	enter $48, $0

	# Open read file
	leaq file_read, %rdi
	leaq file_read_open_mode, %rsi
	call fopen
	# Save pointer to 'FILE' struct on stack
	movq %rax, LOCAL_OFFSET_FILE_STRUCT_READ(%rbp)
	
	# Scan input from file
	movq LOCAL_OFFSET_FILE_STRUCT_READ(%rbp), %rdi
	leaq scan_format, %rsi
	leaq LOCAL_OFFSET_NUMBER(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fscanf
	
	# Close read file
	movq LOCAL_OFFSET_FILE_STRUCT_READ(%rbp), %rdi
	call fclose

	# Open written file
	# The file is needed before checking conditions as it will be used for both error and normal result message.
	leaq file_written, %rdi
	leaq file_written_open_mode, %rsi
	call fopen
	# Save pointer to 'FILE' struct on stack
	movq %rax, LOCAL_OFFSET_FILE_STRUCT_WRITTEN(%rbp)

	# Check if loop wished is '0' 
	cmpq $0, LOCAL_OFFSET_NUMBER(%rbp)
	# If so exit with error code
	je error_exit_zero_provided
	# Else set the counter later used through %rcx.
	# This is done that way even if '%rcx' will not be used with such value as it is not possible to 'movq' with two addresses as in 'movq LOCAL_OFFSET_NUMBER(%rbp), LOCAL_OFFSET_LOOP_COUNTER_FOR_LOOPQ(%rbp)' (wrong - will cause an error message 'too many references were provided to movq instruction'.)
	movq LOCAL_OFFSET_NUMBER(%rbp), %rcx
	# And save it into a local variable
	movq %rcx, LOCAL_OFFSET_LOOP_COUNTER_FOR_LOOPQ(%rbp)
	
	# Check if the number provided is above 255 and exit with error if so.
	cmpq $255, LOCAL_OFFSET_NUMBER(%rbp)
	ja error_exit_value_too_big_provided
	
	# Set loop counter for printed messages
	movq $0, LOCAL_OFFSET_LOOP_COUNTER_FOR_PRINTED_MESSAGE(%rbp) 
		
loop_again:
	# Increase loop number for printed messages
	incq LOCAL_OFFSET_LOOP_COUNTER_FOR_PRINTED_MESSAGE(%rbp)

	# Write result message to file
	movq LOCAL_OFFSET_FILE_STRUCT_WRITTEN(%rbp), %rdi
	leaq loop_message, %rsi
	movq LOCAL_OFFSET_LOOP_COUNTER_FOR_PRINTED_MESSAGE(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Load current decreasing counter into %rcx
	movq LOCAL_OFFSET_LOOP_COUNTER_FOR_LOOPQ(%rbp), %rcx
	# Decrease the local counter because it is not done through 'loopq'
	decq LOCAL_OFFSET_LOOP_COUNTER_FOR_LOOPQ(%rbp)
	
	# Decrement '%rcx' and loop as long as it is not '0'
	loopq loop_again
	
	# After, when '%rcx' is '0', it ends program.
	jmp normal_exit

error_exit_zero_provided:
	# Write error message
	movq LOCAL_OFFSET_FILE_STRUCT_WRITTEN(%rbp), %rdi
	leaq exit_error_message_zero_provided, %rsi
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Set exit return code to error = 1
	movq $1, %rax

	leave
	ret

error_exit_value_too_big_provided:
	# Write error message
	movq LOCAL_OFFSET_FILE_STRUCT_WRITTEN(%rbp), %rdi
	leaq exit_error_message_value_too_big_provided, %rsi
	movq LOCAL_OFFSET_NUMBER(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Set exit return code to error = 2
	movq $2, %rax
	
	leave
	ret
	
normal_exit:
	# Write result message to file
	movq LOCAL_OFFSET_FILE_STRUCT_WRITTEN(%rbp), %rdi
	leaq exit_normal_message, %rsi
	movq LOCAL_OFFSET_LOOP_COUNTER_FOR_PRINTED_MESSAGE(%rbp), %rdx
	# No floating-point number in the variadic function arguments.
	movq $0, %rax
	call fprintf

	# Close written file
	movq LOCAL_OFFSET_FILE_STRUCT_WRITTEN(%rbp), %rdi
	call fclose
	
	# Set exit return code to '0' = ok
	xor %rax, %rax
	
	leave
	ret
	
