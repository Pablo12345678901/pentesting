	# Factorial function :
	#  factorial(N) = N * factorial(N-1)
	# 	with a special case of 'factorial(1) = 1'
	# Example helping to understand how the process works here
	# fact(3) =
	#	3 * fact(2)		-> Hold the current number (3) on the stack - then reduce it (3 -> 2) and recall the function with it.
	#	3 * 2 * fact(1)		-> Same here.
	#	3 * 2 * 1 -		> Multiply result by the last element on the stack (located -8(%rbp)).

	.globl factorial
	.type factorial, @function
	
	.section .text

	
factorial:
	# Reserve space for one register (8 bytes, rounded up to 16 bytes)
	enter $16, $0

	# Check whether current number (provided by first parameter %rdi) is '1' and if not, continue to loop on factorial function.
	cmpq $1, %rdi
	jne continue	

	# If current number is '1', set the return value of default case to '1' ('factorial(1) = 1')
	movq $1, %rax
	leave
	ret
	
continue:
	# Store the current number onto stack
	movq %rdi, -8(%rbp)

	# Else reduce current number
	decq %rdi
	
	# Recall factorial function
	call factorial

	# This point will only be reached when factorial(1) will return.
	mulq -8(%rbp)
	leave
	ret


	


